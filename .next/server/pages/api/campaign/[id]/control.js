"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/campaign/[id]/control";
exports.ids = ["pages/api/campaign/[id]/control"];
exports.modules = {

/***/ "bullmq":
/*!*************************!*\
  !*** external "bullmq" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("bullmq");

/***/ }),

/***/ "ioredis":
/*!**************************!*\
  !*** external "ioredis" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("ioredis");

/***/ }),

/***/ "mongodb":
/*!**************************!*\
  !*** external "mongodb" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("mongodb");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fcampaign%2F%5Bid%5D%2Fcontrol&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Ccampaign%5C%5Bid%5D%5Ccontrol.ts&middlewareConfigBase64=e30%3D!":
/*!****************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fcampaign%2F%5Bid%5D%2Fcontrol&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Ccampaign%5C%5Bid%5D%5Ccontrol.ts&middlewareConfigBase64=e30%3D! ***!
  \****************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_campaign_id_control_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages\\api\\campaign\\[id]\\control.ts */ \"(api)/./pages/api/campaign/[id]/control.ts\");\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_campaign_id_control_ts__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_campaign_id_control_ts__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/campaign/[id]/control\",\n        pathname: \"/api/campaign/[id]/control\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _pages_api_campaign_id_control_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRmNhbXBhaWduJTJGJTVCaWQlNUQlMkZjb250cm9sJnByZWZlcnJlZFJlZ2lvbj0mYWJzb2x1dGVQYWdlUGF0aD0uJTJGcGFnZXMlNUNhcGklNUNjYW1wYWlnbiU1QyU1QmlkJTVEJTVDY29udHJvbC50cyZtaWRkbGV3YXJlQ29uZmlnQmFzZTY0PWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdkM7QUFDTDtBQUMxRDtBQUNxRTtBQUNyRTtBQUNBLGlFQUFlLHdFQUFLLENBQUMsOERBQVEsWUFBWSxFQUFDO0FBQzFDO0FBQ08sZUFBZSx3RUFBSyxDQUFDLDhEQUFRO0FBQ3BDO0FBQ08sd0JBQXdCLGdIQUFtQjtBQUNsRDtBQUNBLGNBQWMseUVBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZO0FBQ1osQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldGluZy1tdnAvPzhjNzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFnZXNBUElSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL3BhZ2VzLWFwaS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBob2lzdCB9IGZyb20gXCJuZXh0L2Rpc3QvYnVpbGQvdGVtcGxhdGVzL2hlbHBlcnNcIjtcbi8vIEltcG9ydCB0aGUgdXNlcmxhbmQgY29kZS5cbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIuL3BhZ2VzXFxcXGFwaVxcXFxjYW1wYWlnblxcXFxbaWRdXFxcXGNvbnRyb2wudHNcIjtcbi8vIFJlLWV4cG9ydCB0aGUgaGFuZGxlciAoc2hvdWxkIGJlIHRoZSBkZWZhdWx0IGV4cG9ydCkuXG5leHBvcnQgZGVmYXVsdCBob2lzdCh1c2VybGFuZCwgXCJkZWZhdWx0XCIpO1xuLy8gUmUtZXhwb3J0IGNvbmZpZy5cbmV4cG9ydCBjb25zdCBjb25maWcgPSBob2lzdCh1c2VybGFuZCwgXCJjb25maWdcIik7XG4vLyBDcmVhdGUgYW5kIGV4cG9ydCB0aGUgcm91dGUgbW9kdWxlIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbmV4cG9ydCBjb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBQYWdlc0FQSVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5QQUdFU19BUEksXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9jYW1wYWlnbi9baWRdL2NvbnRyb2xcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9jYW1wYWlnbi9baWRdL2NvbnRyb2xcIixcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBhcmVuJ3QgdXNlZCBpbiBwcm9kdWN0aW9uLlxuICAgICAgICBidW5kbGVQYXRoOiBcIlwiLFxuICAgICAgICBmaWxlbmFtZTogXCJcIlxuICAgIH0sXG4gICAgdXNlcmxhbmRcbn0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdlcy1hcGkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fcampaign%2F%5Bid%5D%2Fcontrol&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Ccampaign%5C%5Bid%5D%5Ccontrol.ts&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./lib/mongo.ts":
/*!**********************!*\
  !*** ./lib/mongo.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mongodb */ \"mongodb\");\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mongodb__WEBPACK_IMPORTED_MODULE_0__);\n// lib/mongo.ts\n\nconst uri = process.env.MONGODB_URI;\nif (!uri) throw new Error(\"MONGODB_URI not set\");\nlet client;\nlet clientPromise;\n// Retry logic in case MongoDB connection fails\nasync function connectWithRetry() {\n    const MAX_RETRIES = 5;\n    let attempts = 0;\n    let lastError = null;\n    while(attempts < MAX_RETRIES){\n        try {\n            const client = new mongodb__WEBPACK_IMPORTED_MODULE_0__.MongoClient(uri, {\n                maxPoolSize: 10,\n                serverSelectionTimeoutMS: 10000,\n                socketTimeoutMS: 45000\n            });\n            await client.connect();\n            return client;\n        } catch (err) {\n            lastError = err;\n            attempts++;\n            console.error(`MongoDB connection failed (attempt ${attempts}/${MAX_RETRIES}):`, err);\n            if (attempts < MAX_RETRIES) {\n                await new Promise((resolve)=>setTimeout(resolve, 5000)); // wait for 5 seconds before retrying\n            }\n        }\n    }\n    // After max retries, throw the last error encountered\n    throw lastError || new Error(\"MongoDB connection failed after maximum retry attempts\");\n}\nif (!global._mongoClientPromise) {\n    global._mongoClientPromise = connectWithRetry();\n    // Optional: log connection events\n    global._mongoClientPromise.then((client)=>{\n        client.on(\"serverOpening\", (event)=>console.log(\"MongoDB server opening\", event));\n        client.on(\"serverClosed\", (event)=>console.warn(\"MongoDB server closed\", event));\n        client.on(\"topologyClosed\", ()=>console.warn(\"MongoDB topology closed\"));\n        client.on(\"topologyOpening\", ()=>console.log(\"MongoDB topology opening\"));\n        client.on(\"error\", (err)=>console.error(\"MongoDB error\", err));\n    }).catch((err)=>{\n        console.error(\"MongoDB client failed to connect after retries\", err);\n    });\n}\nclientPromise = global._mongoClientPromise;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (clientPromise);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9saWIvbW9uZ28udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZUFBZTtBQUN1QjtBQUV0QyxNQUFNQyxNQUFNQyxRQUFRQyxHQUFHLENBQUNDLFdBQVc7QUFDbkMsSUFBSSxDQUFDSCxLQUFLLE1BQU0sSUFBSUksTUFBTTtBQUUxQixJQUFJQztBQUNKLElBQUlDO0FBT0osK0NBQStDO0FBQy9DLGVBQWVDO0lBQ2IsTUFBTUMsY0FBYztJQUNwQixJQUFJQyxXQUFXO0lBQ2YsSUFBSUMsWUFBMEI7SUFFOUIsTUFBT0QsV0FBV0QsWUFBYTtRQUM3QixJQUFJO1lBQ0YsTUFBTUgsU0FBUyxJQUFJTixnREFBV0EsQ0FBQ0MsS0FBSztnQkFDbENXLGFBQWE7Z0JBQ2JDLDBCQUEwQjtnQkFDMUJDLGlCQUFpQjtZQUNuQjtZQUNBLE1BQU1SLE9BQU9TLE9BQU87WUFDcEIsT0FBT1Q7UUFDVCxFQUFFLE9BQU9VLEtBQVU7WUFDakJMLFlBQVlLO1lBQ1pOO1lBQ0FPLFFBQVFDLEtBQUssQ0FBQyxDQUFDLG1DQUFtQyxFQUFFUixTQUFTLENBQUMsRUFBRUQsWUFBWSxFQUFFLENBQUMsRUFBRU87WUFDakYsSUFBSU4sV0FBV0QsYUFBYTtnQkFDMUIsTUFBTSxJQUFJVSxRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTLFFBQVEscUNBQXFDO1lBQ2hHO1FBQ0Y7SUFDRjtJQUVBLHNEQUFzRDtJQUN0RCxNQUFNVCxhQUFhLElBQUlOLE1BQU07QUFDL0I7QUFFQSxJQUFJLENBQUNpQixPQUFPQyxtQkFBbUIsRUFBRTtJQUMvQkQsT0FBT0MsbUJBQW1CLEdBQUdmO0lBRTdCLGtDQUFrQztJQUNsQ2MsT0FBT0MsbUJBQW1CLENBQ3ZCQyxJQUFJLENBQUNsQixDQUFBQTtRQUNKQSxPQUFPbUIsRUFBRSxDQUFDLGlCQUFpQixDQUFDQyxRQUFVVCxRQUFRVSxHQUFHLENBQUMsMEJBQTBCRDtRQUM1RXBCLE9BQU9tQixFQUFFLENBQUMsZ0JBQWdCLENBQUNDLFFBQVVULFFBQVFXLElBQUksQ0FBQyx5QkFBeUJGO1FBQzNFcEIsT0FBT21CLEVBQUUsQ0FBQyxrQkFBa0IsSUFBTVIsUUFBUVcsSUFBSSxDQUFDO1FBQy9DdEIsT0FBT21CLEVBQUUsQ0FBQyxtQkFBbUIsSUFBTVIsUUFBUVUsR0FBRyxDQUFDO1FBQy9DckIsT0FBT21CLEVBQUUsQ0FBQyxTQUFTLENBQUNULE1BQVFDLFFBQVFDLEtBQUssQ0FBQyxpQkFBaUJGO0lBQzdELEdBQ0NhLEtBQUssQ0FBQ2IsQ0FBQUE7UUFDTEMsUUFBUUMsS0FBSyxDQUFDLGtEQUFrREY7SUFDbEU7QUFDSjtBQUVBVCxnQkFBZ0JlLE9BQU9DLG1CQUFtQjtBQUUxQyxpRUFBZWhCLGFBQWFBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRpbmctbXZwLy4vbGliL21vbmdvLnRzPzU3ZmUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbGliL21vbmdvLnRzXHJcbmltcG9ydCB7IE1vbmdvQ2xpZW50IH0gZnJvbSAnbW9uZ29kYic7XHJcblxyXG5jb25zdCB1cmkgPSBwcm9jZXNzLmVudi5NT05HT0RCX1VSSTtcclxuaWYgKCF1cmkpIHRocm93IG5ldyBFcnJvcignTU9OR09EQl9VUkkgbm90IHNldCcpO1xyXG5cclxubGV0IGNsaWVudDogTW9uZ29DbGllbnQ7XHJcbmxldCBjbGllbnRQcm9taXNlOiBQcm9taXNlPE1vbmdvQ2xpZW50PjtcclxuXHJcbmRlY2xhcmUgZ2xvYmFsIHtcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdmFyXHJcbiAgdmFyIF9tb25nb0NsaWVudFByb21pc2U6IFByb21pc2U8TW9uZ29DbGllbnQ+IHwgdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vLyBSZXRyeSBsb2dpYyBpbiBjYXNlIE1vbmdvREIgY29ubmVjdGlvbiBmYWlsc1xyXG5hc3luYyBmdW5jdGlvbiBjb25uZWN0V2l0aFJldHJ5KCk6IFByb21pc2U8TW9uZ29DbGllbnQ+IHtcclxuICBjb25zdCBNQVhfUkVUUklFUyA9IDU7XHJcbiAgbGV0IGF0dGVtcHRzID0gMDtcclxuICBsZXQgbGFzdEVycm9yOiBFcnJvciB8IG51bGwgPSBudWxsO1xyXG5cclxuICB3aGlsZSAoYXR0ZW1wdHMgPCBNQVhfUkVUUklFUykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgY2xpZW50ID0gbmV3IE1vbmdvQ2xpZW50KHVyaSwge1xyXG4gICAgICAgIG1heFBvb2xTaXplOiAxMCxcclxuICAgICAgICBzZXJ2ZXJTZWxlY3Rpb25UaW1lb3V0TVM6IDEwMDAwLFxyXG4gICAgICAgIHNvY2tldFRpbWVvdXRNUzogNDUwMDAsXHJcbiAgICAgIH0pO1xyXG4gICAgICBhd2FpdCBjbGllbnQuY29ubmVjdCgpO1xyXG4gICAgICByZXR1cm4gY2xpZW50O1xyXG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcclxuICAgICAgbGFzdEVycm9yID0gZXJyO1xyXG4gICAgICBhdHRlbXB0cysrO1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBNb25nb0RCIGNvbm5lY3Rpb24gZmFpbGVkIChhdHRlbXB0ICR7YXR0ZW1wdHN9LyR7TUFYX1JFVFJJRVN9KTpgLCBlcnIpO1xyXG4gICAgICBpZiAoYXR0ZW1wdHMgPCBNQVhfUkVUUklFUykge1xyXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDAwKSk7IC8vIHdhaXQgZm9yIDUgc2Vjb25kcyBiZWZvcmUgcmV0cnlpbmdcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQWZ0ZXIgbWF4IHJldHJpZXMsIHRocm93IHRoZSBsYXN0IGVycm9yIGVuY291bnRlcmVkXHJcbiAgdGhyb3cgbGFzdEVycm9yIHx8IG5ldyBFcnJvcignTW9uZ29EQiBjb25uZWN0aW9uIGZhaWxlZCBhZnRlciBtYXhpbXVtIHJldHJ5IGF0dGVtcHRzJyk7XHJcbn1cclxuXHJcbmlmICghZ2xvYmFsLl9tb25nb0NsaWVudFByb21pc2UpIHtcclxuICBnbG9iYWwuX21vbmdvQ2xpZW50UHJvbWlzZSA9IGNvbm5lY3RXaXRoUmV0cnkoKTtcclxuICBcclxuICAvLyBPcHRpb25hbDogbG9nIGNvbm5lY3Rpb24gZXZlbnRzXHJcbiAgZ2xvYmFsLl9tb25nb0NsaWVudFByb21pc2VcclxuICAgIC50aGVuKGNsaWVudCA9PiB7XHJcbiAgICAgIGNsaWVudC5vbignc2VydmVyT3BlbmluZycsIChldmVudCkgPT4gY29uc29sZS5sb2coJ01vbmdvREIgc2VydmVyIG9wZW5pbmcnLCBldmVudCkpO1xyXG4gICAgICBjbGllbnQub24oJ3NlcnZlckNsb3NlZCcsIChldmVudCkgPT4gY29uc29sZS53YXJuKCdNb25nb0RCIHNlcnZlciBjbG9zZWQnLCBldmVudCkpO1xyXG4gICAgICBjbGllbnQub24oJ3RvcG9sb2d5Q2xvc2VkJywgKCkgPT4gY29uc29sZS53YXJuKCdNb25nb0RCIHRvcG9sb2d5IGNsb3NlZCcpKTtcclxuICAgICAgY2xpZW50Lm9uKCd0b3BvbG9neU9wZW5pbmcnLCAoKSA9PiBjb25zb2xlLmxvZygnTW9uZ29EQiB0b3BvbG9neSBvcGVuaW5nJykpO1xyXG4gICAgICBjbGllbnQub24oJ2Vycm9yJywgKGVycikgPT4gY29uc29sZS5lcnJvcignTW9uZ29EQiBlcnJvcicsIGVycikpO1xyXG4gICAgfSlcclxuICAgIC5jYXRjaChlcnIgPT4ge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdNb25nb0RCIGNsaWVudCBmYWlsZWQgdG8gY29ubmVjdCBhZnRlciByZXRyaWVzJywgZXJyKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5jbGllbnRQcm9taXNlID0gZ2xvYmFsLl9tb25nb0NsaWVudFByb21pc2U7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGllbnRQcm9taXNlOyJdLCJuYW1lcyI6WyJNb25nb0NsaWVudCIsInVyaSIsInByb2Nlc3MiLCJlbnYiLCJNT05HT0RCX1VSSSIsIkVycm9yIiwiY2xpZW50IiwiY2xpZW50UHJvbWlzZSIsImNvbm5lY3RXaXRoUmV0cnkiLCJNQVhfUkVUUklFUyIsImF0dGVtcHRzIiwibGFzdEVycm9yIiwibWF4UG9vbFNpemUiLCJzZXJ2ZXJTZWxlY3Rpb25UaW1lb3V0TVMiLCJzb2NrZXRUaW1lb3V0TVMiLCJjb25uZWN0IiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZ2xvYmFsIiwiX21vbmdvQ2xpZW50UHJvbWlzZSIsInRoZW4iLCJvbiIsImV2ZW50IiwibG9nIiwid2FybiIsImNhdGNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./lib/mongo.ts\n");

/***/ }),

/***/ "(api)/./lib/redis.ts":
/*!**********************!*\
  !*** ./lib/redis.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   redis: () => (/* binding */ redis),\n/* harmony export */   subscribe: () => (/* binding */ subscribe),\n/* harmony export */   subscribeToChannels: () => (/* binding */ subscribeToChannels)\n/* harmony export */ });\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ioredis */ \"ioredis\");\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ioredis__WEBPACK_IMPORTED_MODULE_0__);\n// lib/redis.ts\n\nconst redis = new (ioredis__WEBPACK_IMPORTED_MODULE_0___default())(process.env.REDIS_URL || \"redis://127.0.0.1:6379\", {\n    maxRetriesPerRequest: null,\n    lazyConnect: true,\n    reconnectOnError: (err)=>{\n        const targetErrors = [\n            \"READONLY\",\n            \"ECONNRESET\",\n            \"ETIMEDOUT\"\n        ];\n        try {\n            if (err && typeof err.message === \"string\") {\n                return targetErrors.some((e)=>err.message.includes(e));\n            }\n        } catch  {\n        // fall through\n        }\n        return false;\n    }\n});\nredis.on(\"connect\", ()=>console.log(\"Redis connected\"));\nredis.on(\"ready\", ()=>console.log(\"Redis ready\"));\nredis.on(\"error\", (err)=>console.error(\"Redis error\", err));\nredis.on(\"close\", ()=>console.warn(\"Redis connection closed\"));\nredis.on(\"reconnecting\", ()=>console.log(\"Redis reconnecting\"));\n/**\r\n * Subscribe to a single Redis channel (ioredis-style).\r\n *\r\n * Returns an async unsubscribe function that will remove listener, unsubscribe and quit the duplicate client.\r\n *\r\n * This implementation avoids calling `subscribe(channel, callback)` (which mismatches TS overloads)\r\n * and instead calls `await sub.subscribe(channel)` then listens to the 'message' event.\r\n */ async function subscribe(channel, handler) {\n    const sub = redis.duplicate();\n    // message listener that delegates to handler with parsed JSON when possible\n    const onMessage = (msgChannel, message)=>{\n        if (msgChannel !== channel) return;\n        try {\n            handler(JSON.parse(message));\n        } catch  {\n            handler(message);\n        }\n    };\n    // attach error logging early\n    sub.on(\"error\", (err)=>{\n        console.error(`Redis subscriber error for channel ${channel}`, err);\n    });\n    // attach the message handler and subscribe\n    sub.on(\"message\", onMessage);\n    try {\n        // ioredis duplicate may be lazy; connect explicitly\n        if (typeof sub.connect === \"function\") {\n            // connect() is a no-op if already connected\n            // ignore errors - the caller will see lack of events\n            // but log for debugging\n            await sub.connect().catch((err)=>{\n                console.warn(\"Subscriber connect error (continuing):\", err);\n            });\n        }\n        // call subscribe without a callback to satisfy TS overloads\n        await sub.subscribe(channel);\n    } catch (err) {\n        console.error(`Failed to subscribe to Redis channel ${channel}`, err);\n    }\n    // Return unsubscribe function\n    return async ()=>{\n        try {\n            sub.off(\"message\", onMessage);\n            try {\n                await sub.unsubscribe(channel);\n            } catch (e) {\n            // ignore\n            }\n            try {\n                await sub.quit();\n            } catch (e) {\n            // ignore\n            }\n        } catch (err) {\n            console.warn(`Failed to cleanly unsubscribe from Redis channel ${channel}`, err);\n        }\n    };\n}\n/**\r\n * Robust multi-channel subscription helper.\r\n * Supports ioredis style duplicate subscriber.\r\n *\r\n * sub: a pre-created subscriber client (e.g. redis.duplicate()) OR any compatible client.\r\n * channels: list of channel names\r\n * handler: (channel, message) => void\r\n *\r\n * This function will subscribe to each channel and also attach a fallback 'message' handler\r\n * (useful when some redis clients call back with different signatures).\r\n *\r\n * NOTE: This function does NOT call sub.quit()/sub.unsubscribe for you — the caller is responsible for cleanup.\r\n */ async function subscribeToChannels(sub, channels, handler) {\n    if (!sub || !channels || channels.length === 0) return;\n    // ensure connection if possible\n    try {\n        if (typeof sub.connect === \"function\") {\n            await sub.connect().catch((err)=>{\n                console.warn(\"subscribeToChannels: subscriber connect warning\", err);\n            });\n        }\n    } catch (e) {\n    // ignore connect errors\n    }\n    // Per-channel subscribe (ioredis subscribe returns a Promise)\n    for (const ch of channels){\n        try {\n            if (typeof sub.subscribe === \"function\") {\n                // call subscribe without callback to keep TS happy\n                await sub.subscribe(ch).catch((err)=>{\n                    // some clients may reject; try to continue\n                    console.warn(`subscribeToChannels: subscribe(${ch}) failed`, err);\n                });\n            } else {\n                // fallback: some clients may have different API\n                try {\n                    await sub.subscribe(ch);\n                } catch (e) {\n                    console.warn(`subscribeToChannels: fallback subscribe for ${ch} failed`, e);\n                }\n            }\n        } catch (e) {\n            console.warn(`subscribe failed for channel ${ch}, will attempt fallback`, e);\n        }\n    }\n    // Attach 'message' listener for ioredis-style events: (channel, message)\n    try {\n        if (typeof sub.on === \"function\") {\n            const onMsg = (a, b)=>{\n                // a may be channel or message depending on client; prefer (channel, message)\n                if (typeof a === \"string\" && typeof b === \"string\") {\n                    handler(a, b);\n                } else if (typeof b === \"string\" && channels.includes(b)) {\n                    // unusual ordering, try to map\n                    handler(b, a);\n                } else {\n                    // best-effort fallback: stringify inputs\n                    handler(String(a), String(b));\n                }\n            };\n            // store reference so caller may remove later if needed\n            sub.__subscribe_to_channels_on_message = onMsg;\n            sub.on(\"message\", onMsg);\n        }\n    } catch (e) {\n        console.warn(\"Fallback Redis message hook failed\", e);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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USxDQUFDMEIsSUFBSTtvQkFDeEQsK0JBQStCO29CQUMvQmxCLFFBQVFrQixHQUFHRDtnQkFDYixPQUFPO29CQUNMLHlDQUF5QztvQkFDekNqQixRQUFRbUIsT0FBT0YsSUFBSUUsT0FBT0Q7Z0JBQzVCO1lBQ0Y7WUFDQSx1REFBdUQ7WUFDdERqQixJQUFZbUIsa0NBQWtDLEdBQUdKO1lBQ2xEZixJQUFJUixFQUFFLENBQUMsV0FBV3VCO1FBQ3BCO0lBQ0YsRUFBRSxPQUFPekIsR0FBRztRQUNWRyxRQUFRRyxJQUFJLENBQUMsc0NBQXNDTjtJQUNyRDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0aW5nLW12cC8uL2xpYi9yZWRpcy50cz81MWU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGxpYi9yZWRpcy50c1xyXG5pbXBvcnQgSU9SZWRpcyBmcm9tICdpb3JlZGlzJztcclxuXHJcbmV4cG9ydCBjb25zdCByZWRpcyA9IG5ldyBJT1JlZGlzKHByb2Nlc3MuZW52LlJFRElTX1VSTCB8fCAncmVkaXM6Ly8xMjcuMC4wLjE6NjM3OScsIHtcclxuICBtYXhSZXRyaWVzUGVyUmVxdWVzdDogbnVsbCxcclxuICBsYXp5Q29ubmVjdDogdHJ1ZSxcclxuICByZWNvbm5lY3RPbkVycm9yOiAoZXJyOiBhbnkpID0+IHtcclxuICAgIGNvbnN0IHRhcmdldEVycm9ycyA9IFsnUkVBRE9OTFknLCAnRUNPTk5SRVNFVCcsICdFVElNRURPVVQnXTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGlmIChlcnIgJiYgdHlwZW9mIGVyci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXRFcnJvcnMuc29tZShlID0+IGVyci5tZXNzYWdlLmluY2x1ZGVzKGUpKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIC8vIGZhbGwgdGhyb3VnaFxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sXHJcbn0pO1xyXG5cclxucmVkaXMub24oJ2Nvbm5lY3QnLCAoKSA9PiBjb25zb2xlLmxvZygnUmVkaXMgY29ubmVjdGVkJykpO1xyXG5yZWRpcy5vbigncmVhZHknLCAoKSA9PiBjb25zb2xlLmxvZygnUmVkaXMgcmVhZHknKSk7XHJcbnJlZGlzLm9uKCdlcnJvcicsIChlcnIpID0+IGNvbnNvbGUuZXJyb3IoJ1JlZGlzIGVycm9yJywgZXJyKSk7XHJcbnJlZGlzLm9uKCdjbG9zZScsICgpID0+IGNvbnNvbGUud2FybignUmVkaXMgY29ubmVjdGlvbiBjbG9zZWQnKSk7XHJcbnJlZGlzLm9uKCdyZWNvbm5lY3RpbmcnLCAoKSA9PiBjb25zb2xlLmxvZygnUmVkaXMgcmVjb25uZWN0aW5nJykpO1xyXG5cclxuLyoqXHJcbiAqIFN1YnNjcmliZSB0byBhIHNpbmdsZSBSZWRpcyBjaGFubmVsIChpb3JlZGlzLXN0eWxlKS5cclxuICpcclxuICogUmV0dXJucyBhbiBhc3luYyB1bnN1YnNjcmliZSBmdW5jdGlvbiB0aGF0IHdpbGwgcmVtb3ZlIGxpc3RlbmVyLCB1bnN1YnNjcmliZSBhbmQgcXVpdCB0aGUgZHVwbGljYXRlIGNsaWVudC5cclxuICpcclxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBhdm9pZHMgY2FsbGluZyBgc3Vic2NyaWJlKGNoYW5uZWwsIGNhbGxiYWNrKWAgKHdoaWNoIG1pc21hdGNoZXMgVFMgb3ZlcmxvYWRzKVxyXG4gKiBhbmQgaW5zdGVhZCBjYWxscyBgYXdhaXQgc3ViLnN1YnNjcmliZShjaGFubmVsKWAgdGhlbiBsaXN0ZW5zIHRvIHRoZSAnbWVzc2FnZScgZXZlbnQuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3Vic2NyaWJlKGNoYW5uZWw6IHN0cmluZywgaGFuZGxlcjogKGRhdGE6IGFueSkgPT4gdm9pZCk6IFByb21pc2U8KCkgPT4gUHJvbWlzZTx2b2lkPj4ge1xyXG4gIGNvbnN0IHN1YiA9IHJlZGlzLmR1cGxpY2F0ZSgpO1xyXG5cclxuICAvLyBtZXNzYWdlIGxpc3RlbmVyIHRoYXQgZGVsZWdhdGVzIHRvIGhhbmRsZXIgd2l0aCBwYXJzZWQgSlNPTiB3aGVuIHBvc3NpYmxlXHJcbiAgY29uc3Qgb25NZXNzYWdlID0gKG1zZ0NoYW5uZWw6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nKSA9PiB7XHJcbiAgICBpZiAobXNnQ2hhbm5lbCAhPT0gY2hhbm5lbCkgcmV0dXJuO1xyXG4gICAgdHJ5IHtcclxuICAgICAgaGFuZGxlcihKU09OLnBhcnNlKG1lc3NhZ2UpKTtcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICBoYW5kbGVyKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIGF0dGFjaCBlcnJvciBsb2dnaW5nIGVhcmx5XHJcbiAgc3ViLm9uKCdlcnJvcicsIChlcnI6IGFueSkgPT4ge1xyXG4gICAgY29uc29sZS5lcnJvcihgUmVkaXMgc3Vic2NyaWJlciBlcnJvciBmb3IgY2hhbm5lbCAke2NoYW5uZWx9YCwgZXJyKTtcclxuICB9KTtcclxuXHJcbiAgLy8gYXR0YWNoIHRoZSBtZXNzYWdlIGhhbmRsZXIgYW5kIHN1YnNjcmliZVxyXG4gIHN1Yi5vbignbWVzc2FnZScsIG9uTWVzc2FnZSk7XHJcblxyXG4gIHRyeSB7XHJcbiAgICAvLyBpb3JlZGlzIGR1cGxpY2F0ZSBtYXkgYmUgbGF6eTsgY29ubmVjdCBleHBsaWNpdGx5XHJcbiAgICBpZiAodHlwZW9mIChzdWIgYXMgYW55KS5jb25uZWN0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIC8vIGNvbm5lY3QoKSBpcyBhIG5vLW9wIGlmIGFscmVhZHkgY29ubmVjdGVkXHJcbiAgICAgIC8vIGlnbm9yZSBlcnJvcnMgLSB0aGUgY2FsbGVyIHdpbGwgc2VlIGxhY2sgb2YgZXZlbnRzXHJcbiAgICAgIC8vIGJ1dCBsb2cgZm9yIGRlYnVnZ2luZ1xyXG4gICAgICBhd2FpdCAoc3ViIGFzIGFueSkuY29ubmVjdCgpLmNhdGNoKChlcnI6IGFueSkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignU3Vic2NyaWJlciBjb25uZWN0IGVycm9yIChjb250aW51aW5nKTonLCBlcnIpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIGNhbGwgc3Vic2NyaWJlIHdpdGhvdXQgYSBjYWxsYmFjayB0byBzYXRpc2Z5IFRTIG92ZXJsb2Fkc1xyXG4gICAgYXdhaXQgKHN1YiBhcyBhbnkpLnN1YnNjcmliZShjaGFubmVsKTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBzdWJzY3JpYmUgdG8gUmVkaXMgY2hhbm5lbCAke2NoYW5uZWx9YCwgZXJyKTtcclxuICB9XHJcblxyXG4gIC8vIFJldHVybiB1bnN1YnNjcmliZSBmdW5jdGlvblxyXG4gIHJldHVybiBhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBzdWIub2ZmKCdtZXNzYWdlJywgb25NZXNzYWdlKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCAoc3ViIGFzIGFueSkudW5zdWJzY3JpYmUoY2hhbm5lbCk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAvLyBpZ25vcmVcclxuICAgICAgfVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IChzdWIgYXMgYW55KS5xdWl0KCk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAvLyBpZ25vcmVcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGNsZWFubHkgdW5zdWJzY3JpYmUgZnJvbSBSZWRpcyBjaGFubmVsICR7Y2hhbm5lbH1gLCBlcnIpO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSb2J1c3QgbXVsdGktY2hhbm5lbCBzdWJzY3JpcHRpb24gaGVscGVyLlxyXG4gKiBTdXBwb3J0cyBpb3JlZGlzIHN0eWxlIGR1cGxpY2F0ZSBzdWJzY3JpYmVyLlxyXG4gKlxyXG4gKiBzdWI6IGEgcHJlLWNyZWF0ZWQgc3Vic2NyaWJlciBjbGllbnQgKGUuZy4gcmVkaXMuZHVwbGljYXRlKCkpIE9SIGFueSBjb21wYXRpYmxlIGNsaWVudC5cclxuICogY2hhbm5lbHM6IGxpc3Qgb2YgY2hhbm5lbCBuYW1lc1xyXG4gKiBoYW5kbGVyOiAoY2hhbm5lbCwgbWVzc2FnZSkgPT4gdm9pZFxyXG4gKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgc3Vic2NyaWJlIHRvIGVhY2ggY2hhbm5lbCBhbmQgYWxzbyBhdHRhY2ggYSBmYWxsYmFjayAnbWVzc2FnZScgaGFuZGxlclxyXG4gKiAodXNlZnVsIHdoZW4gc29tZSByZWRpcyBjbGllbnRzIGNhbGwgYmFjayB3aXRoIGRpZmZlcmVudCBzaWduYXR1cmVzKS5cclxuICpcclxuICogTk9URTogVGhpcyBmdW5jdGlvbiBkb2VzIE5PVCBjYWxsIHN1Yi5xdWl0KCkvc3ViLnVuc3Vic2NyaWJlIGZvciB5b3Ug4oCUIHRoZSBjYWxsZXIgaXMgcmVzcG9uc2libGUgZm9yIGNsZWFudXAuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3Vic2NyaWJlVG9DaGFubmVscyhcclxuICBzdWI6IGFueSxcclxuICBjaGFubmVsczogc3RyaW5nW10sXHJcbiAgaGFuZGxlcjogKGNoYW5uZWw6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkXHJcbik6IFByb21pc2U8dm9pZD4ge1xyXG4gIGlmICghc3ViIHx8ICFjaGFubmVscyB8fCBjaGFubmVscy5sZW5ndGggPT09IDApIHJldHVybjtcclxuXHJcbiAgLy8gZW5zdXJlIGNvbm5lY3Rpb24gaWYgcG9zc2libGVcclxuICB0cnkge1xyXG4gICAgaWYgKHR5cGVvZiBzdWIuY29ubmVjdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBhd2FpdCBzdWIuY29ubmVjdCgpLmNhdGNoKChlcnI6IGFueSkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUud2Fybignc3Vic2NyaWJlVG9DaGFubmVsczogc3Vic2NyaWJlciBjb25uZWN0IHdhcm5pbmcnLCBlcnIpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICAvLyBpZ25vcmUgY29ubmVjdCBlcnJvcnNcclxuICB9XHJcblxyXG4gIC8vIFBlci1jaGFubmVsIHN1YnNjcmliZSAoaW9yZWRpcyBzdWJzY3JpYmUgcmV0dXJucyBhIFByb21pc2UpXHJcbiAgZm9yIChjb25zdCBjaCBvZiBjaGFubmVscykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKHR5cGVvZiBzdWIuc3Vic2NyaWJlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgLy8gY2FsbCBzdWJzY3JpYmUgd2l0aG91dCBjYWxsYmFjayB0byBrZWVwIFRTIGhhcHB5XHJcbiAgICAgICAgYXdhaXQgc3ViLnN1YnNjcmliZShjaCkuY2F0Y2goKGVycjogYW55KSA9PiB7XHJcbiAgICAgICAgICAvLyBzb21lIGNsaWVudHMgbWF5IHJlamVjdDsgdHJ5IHRvIGNvbnRpbnVlXHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oYHN1YnNjcmliZVRvQ2hhbm5lbHM6IHN1YnNjcmliZSgke2NofSkgZmFpbGVkYCwgZXJyKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBmYWxsYmFjazogc29tZSBjbGllbnRzIG1heSBoYXZlIGRpZmZlcmVudCBBUElcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgYXdhaXQgKHN1YiBhcyBhbnkpLnN1YnNjcmliZShjaCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKGBzdWJzY3JpYmVUb0NoYW5uZWxzOiBmYWxsYmFjayBzdWJzY3JpYmUgZm9yICR7Y2h9IGZhaWxlZGAsIGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBjb25zb2xlLndhcm4oYHN1YnNjcmliZSBmYWlsZWQgZm9yIGNoYW5uZWwgJHtjaH0sIHdpbGwgYXR0ZW1wdCBmYWxsYmFja2AsIGUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQXR0YWNoICdtZXNzYWdlJyBsaXN0ZW5lciBmb3IgaW9yZWRpcy1zdHlsZSBldmVudHM6IChjaGFubmVsLCBtZXNzYWdlKVxyXG4gIHRyeSB7XHJcbiAgICBpZiAodHlwZW9mIHN1Yi5vbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBjb25zdCBvbk1zZyA9IChhOiBhbnksIGI6IGFueSkgPT4ge1xyXG4gICAgICAgIC8vIGEgbWF5IGJlIGNoYW5uZWwgb3IgbWVzc2FnZSBkZXBlbmRpbmcgb24gY2xpZW50OyBwcmVmZXIgKGNoYW5uZWwsIG1lc3NhZ2UpXHJcbiAgICAgICAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIGhhbmRsZXIoYSwgYik7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYiA9PT0gJ3N0cmluZycgJiYgY2hhbm5lbHMuaW5jbHVkZXMoYikpIHtcclxuICAgICAgICAgIC8vIHVudXN1YWwgb3JkZXJpbmcsIHRyeSB0byBtYXBcclxuICAgICAgICAgIGhhbmRsZXIoYiwgYSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIGJlc3QtZWZmb3J0IGZhbGxiYWNrOiBzdHJpbmdpZnkgaW5wdXRzXHJcbiAgICAgICAgICBoYW5kbGVyKFN0cmluZyhhKSwgU3RyaW5nKGIpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICAgIC8vIHN0b3JlIHJlZmVyZW5jZSBzbyBjYWxsZXIgbWF5IHJlbW92ZSBsYXRlciBpZiBuZWVkZWRcclxuICAgICAgKHN1YiBhcyBhbnkpLl9fc3Vic2NyaWJlX3RvX2NoYW5uZWxzX29uX21lc3NhZ2UgPSBvbk1zZztcclxuICAgICAgc3ViLm9uKCdtZXNzYWdlJywgb25Nc2cpO1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGNvbnNvbGUud2FybignRmFsbGJhY2sgUmVkaXMgbWVzc2FnZSBob29rIGZhaWxlZCcsIGUpO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsiSU9SZWRpcyIsInJlZGlzIiwicHJvY2VzcyIsImVudiIsIlJFRElTX1VSTCIsIm1heFJldHJpZXNQZXJSZXF1ZXN0IiwibGF6eUNvbm5lY3QiLCJyZWNvbm5lY3RPbkVycm9yIiwiZXJyIiwidGFyZ2V0RXJyb3JzIiwibWVzc2FnZSIsInNvbWUiLCJlIiwiaW5jbHVkZXMiLCJvbiIsImNvbnNvbGUiLCJsb2ciLCJlcnJvciIsIndhcm4iLCJzdWJzY3JpYmUiLCJjaGFubmVsIiwiaGFuZGxlciIsInN1YiIsImR1cGxpY2F0ZSIsIm9uTWVzc2FnZSIsIm1zZ0NoYW5uZWwiLCJKU09OIiwicGFyc2UiLCJjb25uZWN0IiwiY2F0Y2giLCJvZmYiLCJ1bnN1YnNjcmliZSIsInF1aXQiLCJzdWJzY3JpYmVUb0NoYW5uZWxzIiwiY2hhbm5lbHMiLCJsZW5ndGgiLCJjaCIsIm9uTXNnIiwiYSIsImIiLCJTdHJpbmciLCJfX3N1YnNjcmliZV90b19jaGFubmVsc19vbl9tZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./lib/redis.ts\n");

/***/ }),

/***/ "(api)/./pages/api/campaign/[id]/control.ts":
/*!********************************************!*\
  !*** ./pages/api/campaign/[id]/control.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var _lib_mongo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../lib/mongo */ \"(api)/./lib/mongo.ts\");\n/* harmony import */ var _lib_redis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../lib/redis */ \"(api)/./lib/redis.ts\");\n/* harmony import */ var bullmq__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bullmq */ \"bullmq\");\n/* harmony import */ var bullmq__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(bullmq__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! mongodb */ \"mongodb\");\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(mongodb__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\nconst queue = new bullmq__WEBPACK_IMPORTED_MODULE_2__.Queue(\"campaigns\", {\n    connection: _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis\n});\n// keep parity with worker; allow env override\nconst MAX_ATTEMPTS = Number(process.env.MAX_ATTEMPTS || 3);\n// server-side cap for batch retries per request\nconst BATCH_RETRY_LIMIT = Number(process.env.BATCH_RETRY_LIMIT || 5000);\n// when resuming, limit how many pending jobs we'll try to (re)enqueue\nconst RESUME_ENQUEUE_LIMIT = Number(process.env.RESUME_ENQUEUE_LIMIT || 5000);\n// how long before a 'sending' row is considered stale and eligible for recovery (ms)\nconst STALE_SENDING_MS = Number(process.env.STALE_SENDING_MS || 90000);\nasync function safeHSet(key, obj) {\n    try {\n        await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hset(key, obj);\n    } catch (err) {\n        console.warn(\"Redis unavailable while setting meta\", err);\n    }\n}\nasync function safePublish(channel, payload) {\n    try {\n        await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.publish(channel, JSON.stringify(payload));\n    } catch (err) {\n        console.warn(\"Redis publish failed\", err);\n    }\n}\n// Remove waiting/delayed/active jobs for a campaignId (best-effort)\nasync function removeQueuedJobsForCampaign(campaignId) {\n    try {\n        // get waiting/delayed/active jobs\n        const jobs = await queue.getJobs([\n            \"waiting\",\n            \"delayed\",\n            \"active\",\n            \"paused\"\n        ], 0, -1);\n        const matched = jobs.filter((j)=>{\n            try {\n                return j.data?.campaignId === campaignId;\n            } catch  {\n                return false;\n            }\n        });\n        for (const j of matched){\n            try {\n                // if the job is active, remove may fail - still try\n                await j.remove();\n            } catch (e) {\n                // best-effort — ignore\n                console.warn(`Failed to remove job ${j.id}`, e);\n            }\n        }\n        return matched.length;\n    } catch (err) {\n        console.warn(\"Failed to enumerate/remove jobs for campaign\", err);\n        return 0;\n    }\n}\n// safe read of redis meta integer field\nasync function safeGetMetaInt(redisKey, field) {\n    try {\n        const v = await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hget(redisKey, field);\n        return Number(v || 0);\n    } catch (e) {\n        return 0;\n    }\n}\n/**\r\n * Ensure there is a usable `campaign:{id}:definition` in Redis.\r\n * If missing, attempt to construct one from the Mongo campaign document.\r\n * Returns true if definition exists or was written successfully.\r\n */ async function ensureCampaignDefinition(id, campaignDoc) {\n    const key = `campaign:${id}:definition`;\n    try {\n        const existing = await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.get(key);\n        if (existing) return true;\n        // Attempt to build a minimal compatible definition\n        // Worker expects { initial: { subject, body }, followUps: [...] }\n        let built = null;\n        // Prefer explicit shapes commonly used\n        if (campaignDoc?.definition && typeof campaignDoc.definition === \"object\") {\n            built = campaignDoc.definition;\n        } else if (campaignDoc?.initial && typeof campaignDoc.initial === \"object\") {\n            built = {\n                initial: campaignDoc.initial,\n                followUps: campaignDoc.followUps || []\n            };\n        } else if (campaignDoc?.template && typeof campaignDoc.template === \"object\") {\n            built = {\n                initial: {\n                    subject: campaignDoc.template.subject || campaignDoc.name,\n                    body: campaignDoc.template.body || campaignDoc.content || \"\"\n                },\n                followUps: campaignDoc.template.followUps || campaignDoc.followUps || []\n            };\n        } else {\n            // fallback: try to glean subject/body from common fields\n            const subject = campaignDoc?.subject || campaignDoc?.title || campaignDoc?.name || `Campaign ${id}`;\n            const body = campaignDoc?.body || campaignDoc?.content || campaignDoc?.html || \"\";\n            const followUps = campaignDoc?.followUps || campaignDoc?.steps || [];\n            built = {\n                initial: {\n                    subject,\n                    body\n                },\n                followUps\n            };\n        }\n        // If built doesn't look right (no initial subject/body), fail safe\n        if (!built || !built.initial || built.initial.subject == null && built.initial.body == null) {\n            console.warn(\"Unable to construct campaign definition from campaign document\", {\n                campaignId: id,\n                sample: campaignDoc ? Object.keys(campaignDoc).slice(0, 8) : null\n            });\n            return false;\n        }\n        // Persist into Redis (no expiry) so worker can read it\n        try {\n            await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.set(key, JSON.stringify(built));\n            console.log(`Wrote fallback campaign definition into redis for ${id}`);\n            return true;\n        } catch (e) {\n            console.warn(\"Failed to write campaign definition to redis\", e);\n            return false;\n        }\n    } catch (e) {\n        console.warn(\"Error checking/writing campaign definition in redis\", e);\n        return false;\n    }\n}\n/**\r\n * Get a set of contactId strings for jobs currently enqueued for this campaign.\r\n * Used to avoid enqueuing duplicates when resuming.\r\n */ async function getQueuedContactIdsForCampaign(campaignId) {\n    const set = new Set();\n    try {\n        const jobs = await queue.getJobs([\n            \"waiting\",\n            \"delayed\",\n            \"active\",\n            \"paused\"\n        ], 0, -1);\n        for (const j of jobs){\n            try {\n                if (j.data?.campaignId === campaignId && j.data?.contactId) {\n                    set.add(String(j.data.contactId));\n                }\n            } catch  {\n            // ignore malformed jobs\n            }\n        }\n    } catch (e) {\n        console.warn(\"Failed to list queued jobs for campaign when checking duplicates\", e);\n    }\n    return set;\n}\nasync function handler(req, res) {\n    if (req.method !== \"POST\") {\n        return res.status(405).json({\n            error: \"Method not allowed\"\n        });\n    }\n    const { id } = req.query;\n    if (!id || typeof id !== \"string\") {\n        return res.status(400).json({\n            error: \"Invalid campaign id\"\n        });\n    }\n    const { action, confirm, contactId } = req.body;\n    if (!action || ![\n        \"pause\",\n        \"resume\",\n        \"cancel\",\n        \"delete\",\n        \"retryFailed\",\n        \"retryContact\",\n        \"reconcile\"\n    ].includes(action)) {\n        return res.status(400).json({\n            error: \"Invalid action\"\n        });\n    }\n    const client = await _lib_mongo__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    const db = client.db(\"PlatformData\");\n    const campaignObjectId = new mongodb__WEBPACK_IMPORTED_MODULE_3__.ObjectId(id);\n    try {\n        // Reload campaign from Mongo (authoritative)\n        const campaign = await db.collection(\"campaigns\").findOne({\n            _id: campaignObjectId\n        });\n        if (!campaign) {\n            return res.status(404).json({\n                error: \"Campaign not found\"\n            });\n        }\n        // Lightweight helpers\n        const redisKey = `campaign:${id}:meta`;\n        // ACTION: Pause\n        if (action === \"pause\") {\n            if (campaign.status === \"paused\") {\n                return res.status(200).json({\n                    ok: true,\n                    message: \"Already paused\"\n                });\n            }\n            await db.collection(\"campaigns\").updateOne({\n                _id: campaignObjectId\n            }, {\n                $set: {\n                    status: \"paused\"\n                }\n            });\n            await safeHSet(redisKey, {\n                status: \"paused\"\n            });\n            // publish campaign-level event so UI disables retry buttons and updates state\n            await safePublish(\"campaign:new\", {\n                id,\n                status: \"paused\"\n            });\n            return res.status(200).json({\n                ok: true,\n                action: \"paused\"\n            });\n        }\n        // ACTION: Resume\n        if (action === \"resume\") {\n            if (campaign.status === \"running\") {\n                return res.status(200).json({\n                    ok: true,\n                    message: \"Already running\"\n                });\n            }\n            // set running in DB + redis\n            await db.collection(\"campaigns\").updateOne({\n                _id: campaignObjectId\n            }, {\n                $set: {\n                    status: \"running\"\n                }\n            });\n            await safeHSet(redisKey, {\n                status: \"running\"\n            });\n            await safePublish(\"campaign:new\", {\n                id,\n                status: \"running\"\n            });\n            // Re-enqueue pending contacts that currently have no queued job for this campaign.\n            // This addresses cases where jobs were removed or not enqueued while the campaign was paused,\n            // ensuring pending rows actually get processed again after resume.\n            try {\n                const queuedSet = await getQueuedContactIdsForCampaign(id);\n                // fetch pending docs (limit to a sane cap)\n                const pendingCursor = db.collection(\"campaign_contacts\").find({\n                    campaignId: campaignObjectId,\n                    status: \"pending\"\n                }, {\n                    projection: {\n                        _id: 1,\n                        contactId: 1,\n                        step: 1\n                    }\n                }).limit(RESUME_ENQUEUE_LIMIT);\n                const pending = await pendingCursor.toArray();\n                const enqueuePromises = [];\n                for (const d of pending){\n                    const cid = d.contactId ? d.contactId.toString ? d.contactId.toString() : String(d.contactId) : d._id.toString ? d._id.toString() : String(d._id);\n                    if (queuedSet.has(cid)) continue; // already queued\n                    try {\n                        enqueuePromises.push(queue.add(d.step ? \"followup\" : \"initial\", {\n                            campaignId: id,\n                            contactId: cid,\n                            step: d.step\n                        }, {\n                            removeOnComplete: true,\n                            removeOnFail: true,\n                            attempts: MAX_ATTEMPTS,\n                            backoff: {\n                                type: \"exponential\",\n                                delay: 60000\n                            }\n                        }));\n                    } catch (e) {\n                        console.warn(\"Failed to enqueue pending contact on resume\", e);\n                    }\n                }\n                // attempt to enqueue in parallel (best-effort)\n                if (enqueuePromises.length > 0) {\n                    await Promise.allSettled(enqueuePromises);\n                    // notify UI that contacts have been re-queued (counts unchanged, but UI may want to refresh)\n                    await safePublish(\"campaign:new\", {\n                        id,\n                        action: \"resume_requeued\",\n                        requeued: enqueuePromises.length\n                    });\n                }\n            } catch (e) {\n                console.warn(\"Failed to re-enqueue pending contacts on resume\", e);\n            }\n            // Recover stale 'sending' ledger rows that may have been left in 'sending' by a crashed worker or killed process.\n            // Criteria: status === 'sending' AND lastAttemptAt older than STALE_SENDING_MS AND bgAttempts < MAX_ATTEMPTS\n            // We'll set them back to 'pending', reset bgAttempts to 0 (so background cycle restarts), and enqueue jobs.\n            try {\n                const cutoff = new Date(Date.now() - STALE_SENDING_MS);\n                const staleCursor = db.collection(\"campaign_contacts\").find({\n                    campaignId: campaignObjectId,\n                    status: \"sending\",\n                    lastAttemptAt: {\n                        $lt: cutoff\n                    }\n                }, {\n                    projection: {\n                        _id: 1,\n                        contactId: 1,\n                        step: 1,\n                        bgAttempts: 1\n                    }\n                }).limit(RESUME_ENQUEUE_LIMIT);\n                const staleDocs = await staleCursor.toArray();\n                if (staleDocs.length > 0) {\n                    const ids = staleDocs.map((d)=>d._id);\n                    // Reset to pending and clear lastError, reset bgAttempts so background retries start fresh\n                    await db.collection(\"campaign_contacts\").updateMany({\n                        _id: {\n                            $in: ids\n                        }\n                    }, {\n                        $set: {\n                            status: \"pending\",\n                            lastError: null,\n                            bgAttempts: 0\n                        }\n                    });\n                    // Enqueue each stale doc if not already queued\n                    const queuedSet2 = await getQueuedContactIdsForCampaign(id);\n                    const requeuePromises = [];\n                    for (const d of staleDocs){\n                        const cid = d.contactId ? d.contactId.toString ? d.contactId.toString() : String(d.contactId) : d._id.toString ? d._id.toString() : String(d._id);\n                        if (queuedSet2.has(cid)) continue;\n                        try {\n                            requeuePromises.push(queue.add(d.step ? \"followup\" : \"initial\", {\n                                campaignId: id,\n                                contactId: cid,\n                                step: d.step\n                            }, {\n                                removeOnComplete: true,\n                                removeOnFail: true,\n                                attempts: MAX_ATTEMPTS,\n                                backoff: {\n                                    type: \"exponential\",\n                                    delay: 60000\n                                }\n                            }));\n                        } catch (e) {\n                            console.warn(\"Failed to enqueue stale sending contact on resume\", e);\n                        }\n                        // publish contact-level update hint so UI reflects it's now pending\n                        try {\n                            safePublish(`campaign:${id}:contact_update`, {\n                                contactId: cid,\n                                status: \"pending\",\n                                bgAttempts: 0,\n                                attempts: undefined\n                            });\n                        } catch (_) {}\n                    }\n                    if (requeuePromises.length > 0) await Promise.allSettled(requeuePromises);\n                    await safePublish(\"campaign:new\", {\n                        id,\n                        action: \"resume_recovered_sending\",\n                        recovered: staleDocs.length\n                    });\n                }\n            } catch (e) {\n                console.warn(\"Failed to recover stale sending rows on resume\", e);\n            }\n            return res.status(200).json({\n                ok: true,\n                action: \"resumed\"\n            });\n        }\n        // ACTION: Reconcile (lightweight, single-request reconciliation)\n        if (action === \"reconcile\") {\n            try {\n                // 1) Recover stale 'sending' rows -> pending\n                const cutoff = new Date(Date.now() - STALE_SENDING_MS);\n                const staleSending = await db.collection(\"campaign_contacts\").find({\n                    campaignId: campaignObjectId,\n                    status: \"sending\",\n                    lastAttemptAt: {\n                        $lt: cutoff\n                    }\n                }).project({\n                    _id: 1,\n                    contactId: 1,\n                    step: 1\n                }).limit(RESUME_ENQUEUE_LIMIT).toArray();\n                if (staleSending.length > 0) {\n                    const ids = staleSending.map((d)=>d._id);\n                    await db.collection(\"campaign_contacts\").updateMany({\n                        _id: {\n                            $in: ids\n                        }\n                    }, {\n                        $set: {\n                            status: \"pending\",\n                            lastError: null,\n                            bgAttempts: 0\n                        }\n                    });\n                }\n                // 2) Enqueue pending docs that do not currently have a job\n                const queuedSet = await getQueuedContactIdsForCampaign(id);\n                const pendingCursor = db.collection(\"campaign_contacts\").find({\n                    campaignId: campaignObjectId,\n                    status: \"pending\"\n                }, {\n                    projection: {\n                        _id: 1,\n                        contactId: 1,\n                        step: 1\n                    }\n                }).limit(RESUME_ENQUEUE_LIMIT);\n                const pendingRows = await pendingCursor.toArray();\n                const enqueuePromises = [];\n                for (const d of pendingRows){\n                    const cid = d.contactId ? d.contactId.toString ? d.contactId.toString() : String(d.contactId) : d._id.toString ? d._id.toString() : String(d._id);\n                    if (queuedSet.has(cid)) continue;\n                    try {\n                        enqueuePromises.push(queue.add(d.step ? \"followup\" : \"initial\", {\n                            campaignId: id,\n                            contactId: cid,\n                            step: d.step\n                        }, {\n                            removeOnComplete: true,\n                            removeOnFail: true,\n                            attempts: MAX_ATTEMPTS,\n                            backoff: {\n                                type: \"exponential\",\n                                delay: 60000\n                            }\n                        }));\n                    } catch (e) {\n                        console.warn(\"Reconcile: failed to enqueue\", e);\n                    }\n                }\n                if (enqueuePromises.length) await Promise.allSettled(enqueuePromises);\n                // 3) Recalculate totals from DB (authoritative)\n                const agg = await db.collection(\"campaign_contacts\").aggregate([\n                    {\n                        $match: {\n                            campaignId: campaignObjectId\n                        }\n                    },\n                    {\n                        $group: {\n                            _id: \"$status\",\n                            count: {\n                                $sum: 1\n                            }\n                        }\n                    }\n                ]).toArray();\n                let pending = 0, sent = 0, failed = 0;\n                for (const r of agg){\n                    if (r._id === \"pending\") pending = r.count;\n                    else if (r._id === \"sent\") sent = r.count;\n                    else if (r._id === \"failed\") failed = r.count;\n                }\n                const processed = sent + failed;\n                const intended = campaign.totals?.intended ?? await db.collection(\"campaign_contacts\").countDocuments({\n                    campaignId: campaignObjectId\n                });\n                // Write back authoritative totals to DB\n                await db.collection(\"campaigns\").updateOne({\n                    _id: campaignObjectId\n                }, {\n                    $set: {\n                        \"totals.processed\": processed,\n                        \"totals.sent\": sent,\n                        \"totals.failed\": failed\n                    }\n                });\n                // Best-effort write to Redis meta\n                try {\n                    await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hset(redisKey, {\n                        processed: String(processed),\n                        sent: String(sent),\n                        failed: String(failed),\n                        total: String(intended)\n                    });\n                } catch (_) {}\n                // 4) Decide canonical campaign status\n                let newStatus = campaign.status;\n                if (processed >= intended) {\n                    if (failed > 0) newStatus = \"completed_with_failures\";\n                    else newStatus = \"completed\";\n                } else {\n                    newStatus = \"running\";\n                }\n                // persist status if changed\n                if (newStatus !== campaign.status) {\n                    await db.collection(\"campaigns\").updateOne({\n                        _id: campaignObjectId\n                    }, {\n                        $set: {\n                            status: newStatus,\n                            completedAt: newStatus.startsWith(\"completed\") ? new Date() : null\n                        }\n                    });\n                    await safeHSet(redisKey, {\n                        status: newStatus\n                    });\n                }\n                await safePublish(\"campaign:new\", {\n                    id,\n                    action: \"reconcile\",\n                    requeued: enqueuePromises.length,\n                    recovered: staleSending.length,\n                    status: newStatus\n                });\n                return res.status(200).json({\n                    ok: true,\n                    requeued: enqueuePromises.length,\n                    recovered: staleSending.length,\n                    status: newStatus\n                });\n            } catch (e) {\n                console.error(\"Reconcile failed\", e);\n                return res.status(500).json({\n                    error: \"reconcile-failed\"\n                });\n            }\n        }\n        // ACTION: Cancel\n        if (action === \"cancel\") {\n            if (campaign.status === \"cancelled\") {\n                return res.status(200).json({\n                    ok: true,\n                    message: \"Already cancelled\"\n                });\n            }\n            // 1) Mark campaign cancelled and completedAt\n            const completedAt = new Date();\n            await db.collection(\"campaigns\").updateOne({\n                _id: campaignObjectId\n            }, {\n                $set: {\n                    status: \"cancelled\",\n                    completedAt\n                }\n            });\n            await safeHSet(redisKey, {\n                status: \"cancelled\"\n            });\n            // 2) Find and atomically mark pending ledger rows as failed (single updateMany)\n            const filter = {\n                campaignId: campaignObjectId,\n                status: \"pending\"\n            };\n            const update = {\n                $set: {\n                    status: \"failed\",\n                    lastError: \"cancelled\",\n                    lastAttemptAt: completedAt\n                },\n                $inc: {\n                    attempts: 1\n                }\n            };\n            const updateResult = await db.collection(\"campaign_contacts\").updateMany(filter, update);\n            const cancelledCount = updateResult.modifiedCount ?? 0;\n            // 3) Update Redis counters (best-effort)\n            try {\n                if (cancelledCount > 0) {\n                    await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hincrby(redisKey, \"processed\", cancelledCount);\n                    await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hincrby(redisKey, \"failed\", cancelledCount);\n                }\n            } catch (e) {\n                console.warn(\"Failed to update redis counters during cancel\", e);\n            }\n            // 4) Persist totals snapshot to campaigns.totals (read redis if available, fallback to db)\n            let meta = {};\n            try {\n                meta = await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hgetall(redisKey) || {};\n            } catch  {\n                meta = {};\n            }\n            // Compute totals final values combining persisted totals and our cancelledCount as fallback\n            const processedNow = Number(meta[\"processed\"] ?? (campaign.totals?.processed ?? 0) + cancelledCount);\n            const sentNow = Number(meta[\"sent\"] ?? campaign.totals?.sent ?? 0);\n            const failedNow = Number(meta[\"failed\"] ?? (campaign.totals?.failed ?? 0) + cancelledCount);\n            await db.collection(\"campaigns\").updateOne({\n                _id: campaignObjectId\n            }, {\n                $set: {\n                    \"totals.processed\": processedNow,\n                    \"totals.sent\": sentNow,\n                    \"totals.failed\": failedNow,\n                    completedAt\n                }\n            });\n            // 5) Remove queued jobs for this campaign (best-effort)\n            const removedJobs = await removeQueuedJobsForCampaign(id);\n            // 6) Publish event\n            await safePublish(\"campaign:new\", {\n                id,\n                status: \"cancelled\",\n                cancelledCount,\n                removedJobs\n            });\n            return res.status(200).json({\n                ok: true,\n                action: \"cancelled\",\n                cancelledCount,\n                removedJobs\n            });\n        }\n        // ACTION: Delete\n        if (action === \"delete\") {\n            // Require explicit confirmation — safeguards in UI must set confirm=true\n            if (confirm !== true) {\n                return res.status(400).json({\n                    error: \"Deletion requires confirm=true in request body\"\n                });\n            }\n            // Prevent accidental deletion while running\n            if (campaign.status === \"running\") {\n                return res.status(400).json({\n                    error: \"Cancel the campaign before deletion\"\n                });\n            }\n            // Remove queued jobs (best-effort)\n            const removedJobs = await removeQueuedJobsForCampaign(id);\n            // Delete Redis keys (best-effort)\n            try {\n                await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.del(`campaign:${id}:meta`);\n                await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.del(`campaign:${id}:definition`);\n                await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.srem(\"campaign:all\", id);\n            } catch (e) {\n                console.warn(\"Redis cleanup on delete failed\", e);\n            }\n            // Delete Mongo docs\n            const [campaignDel, ledgerDel] = await Promise.all([\n                db.collection(\"campaigns\").deleteOne({\n                    _id: campaignObjectId\n                }),\n                db.collection(\"campaign_contacts\").deleteMany({\n                    campaignId: campaignObjectId\n                })\n            ]);\n            await safePublish(\"campaign:new\", {\n                id,\n                status: \"deleted\"\n            });\n            return res.status(200).json({\n                ok: true,\n                action: \"deleted\",\n                campaignDeleted: campaignDel.deletedCount ?? 0,\n                ledgerDeleted: ledgerDel.deletedCount ?? 0,\n                removedJobs\n            });\n        }\n        // ACTION: Retry all failed contacts that are below MAX_ATTEMPTS\n        if (action === \"retryFailed\") {\n            // Disallow retrying if campaign is cancelled/deleted/paused\n            if (campaign.status === \"cancelled\" || campaign.status === \"deleted\" || campaign.status === \"paused\") {\n                return res.status(400).json({\n                    error: \"Cannot retry contacts for cancelled/deleted/paused campaign\"\n                });\n            }\n            // Ensure a Redis campaign definition exists (worker requires it)\n            const hasDef = await ensureCampaignDefinition(id, campaign);\n            if (!hasDef) {\n                return res.status(500).json({\n                    error: \"Missing campaign definition in Redis and unable to construct one from campaign document. Retry cannot proceed.\"\n                });\n            }\n            // find failed contacts with attempts < MAX_ATTEMPTS AND where bgAttempts >= MAX_ATTEMPTS (meaning background cycle finished)\n            // If bgAttempts is missing (undefined/null), treat it as finished (conservative). But prefer explicit >=.\n            const filter = {\n                campaignId: campaignObjectId,\n                status: \"failed\",\n                attempts: {\n                    $lt: MAX_ATTEMPTS\n                },\n                $or: [\n                    {\n                        bgAttempts: {\n                            $exists: false\n                        }\n                    },\n                    {\n                        bgAttempts: {\n                            $gte: MAX_ATTEMPTS\n                        }\n                    }\n                ]\n            };\n            const failedDocs = await db.collection(\"campaign_contacts\").find(filter, {\n                projection: {\n                    _id: 1,\n                    contactId: 1,\n                    step: 1\n                }\n            }).toArray();\n            const toRetryCount = failedDocs.length;\n            if (toRetryCount === 0) {\n                return res.status(200).json({\n                    ok: true,\n                    retried: 0,\n                    message: \"No eligible failed contacts to retry (either none failed, reached max attempts, or background retries still in progress).\"\n                });\n            }\n            // server-side cap enforcement\n            if (toRetryCount > BATCH_RETRY_LIMIT) {\n                return res.status(400).json({\n                    error: \"Batch retry exceeds server limit\",\n                    message: `Trying to retry ${toRetryCount} contacts exceeds server cap of ${BATCH_RETRY_LIMIT}. Use pagination to retry in smaller batches.`,\n                    toRetryCount,\n                    limit: BATCH_RETRY_LIMIT\n                });\n            }\n            // Atomically mark them pending and increment core `attempts` and reset bgAttempts\n            const ids = failedDocs.map((d)=>d._id);\n            const updateResult = await db.collection(\"campaign_contacts\").updateMany({\n                _id: {\n                    $in: ids\n                }\n            }, {\n                $set: {\n                    status: \"pending\",\n                    lastError: null,\n                    bgAttempts: 0\n                },\n                $inc: {\n                    attempts: 1\n                }\n            });\n            const updated = updateResult.modifiedCount ?? 0;\n            // Enqueue jobs (batch), ensure each job has MQ attempts/backoff set\n            const jobs = [];\n            const CHUNK = 200; // reasonable chunking\n            for(let i = 0; i < failedDocs.length; i += CHUNK){\n                const chunk = failedDocs.slice(i, i + CHUNK);\n                for (const doc of chunk){\n                    const contactObjId = doc.contactId ? doc.contactId : doc._id;\n                    try {\n                        if (doc.step) {\n                            jobs.push(queue.add(\"followup\", {\n                                campaignId: id,\n                                contactId: contactObjId.toString ? contactObjId.toString() : String(contactObjId),\n                                step: doc.step\n                            }, {\n                                removeOnComplete: true,\n                                removeOnFail: true,\n                                attempts: MAX_ATTEMPTS,\n                                backoff: {\n                                    type: \"exponential\",\n                                    delay: 60000\n                                }\n                            }));\n                        } else {\n                            jobs.push(queue.add(\"initial\", {\n                                campaignId: id,\n                                contactId: contactObjId.toString ? contactObjId.toString() : String(contactObjId)\n                            }, {\n                                removeOnComplete: true,\n                                removeOnFail: true,\n                                attempts: MAX_ATTEMPTS,\n                                backoff: {\n                                    type: \"exponential\",\n                                    delay: 60000\n                                }\n                            }));\n                        }\n                    } catch (e) {\n                        console.warn(\"Failed to queue job for retryFailed chunk item\", e);\n                    }\n                }\n            }\n            // Wait for enqueues (best-effort)\n            try {\n                await Promise.all(jobs);\n            } catch (e) {\n                console.warn(\"Some queue.add calls failed during retryFailed\", e);\n            }\n            // Update redis counters: decrease failed by updated (best-effort, but avoid negative)\n            try {\n                const currentFailed = await safeGetMetaInt(redisKey, \"failed\");\n                const dec = Math.min(updated, currentFailed);\n                if (dec > 0) {\n                    await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hincrby(redisKey, \"failed\", -dec);\n                }\n            } catch (e) {\n                console.warn(\"Failed to update redis counters during retryFailed\", e);\n            }\n            // Also correct processed counter because we are moving final failed -> pending (processed should drop)\n            try {\n                const currentProcessed = await safeGetMetaInt(redisKey, \"processed\");\n                const decProc = Math.min(updated, currentProcessed);\n                if (decProc > 0) {\n                    await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hincrby(redisKey, \"processed\", -decProc);\n                }\n            } catch (e) {\n                console.warn(\"Failed to update processed counter during retryFailed\", e);\n            }\n            // Publish contact-level updates for each retried contact (best-effort)\n            try {\n                for (const doc of failedDocs){\n                    const cid = doc.contactId ? doc.contactId.toString ? doc.contactId.toString() : String(doc.contactId) : doc._id.toString ? doc._id.toString() : String(doc._id);\n                    await safePublish(`campaign:${id}:contact_update`, {\n                        contactId: cid,\n                        status: \"pending\",\n                        bgAttempts: 0,\n                        attempts: 1\n                    });\n                }\n            } catch (_) {\n            // ignore publish errors\n            }\n            await safePublish(\"campaign:new\", {\n                id,\n                action: \"retryFailed\",\n                retried: updated\n            });\n            return res.status(200).json({\n                ok: true,\n                retried: updated,\n                attemptedEnqueue: toRetryCount\n            });\n        }\n        // ACTION: Retry a single failed contact by contactId\n        if (action === \"retryContact\") {\n            if (!contactId || typeof contactId !== \"string\") {\n                return res.status(400).json({\n                    error: \"Missing contactId for retryContact\"\n                });\n            }\n            // Disallow retrying if campaign is cancelled/deleted/paused\n            if (campaign.status === \"cancelled\" || campaign.status === \"deleted\" || campaign.status === \"paused\") {\n                return res.status(400).json({\n                    error: \"Cannot retry contacts for cancelled/deleted/paused campaign\"\n                });\n            }\n            // Ensure a Redis campaign definition exists (worker requires it)\n            const hasDef = await ensureCampaignDefinition(id, campaign);\n            if (!hasDef) {\n                return res.status(500).json({\n                    error: \"Missing campaign definition in Redis and unable to construct one from campaign document. Retry cannot proceed.\"\n                });\n            }\n            // Find the ledger row\n            let contactObjId;\n            try {\n                // try parse as ObjectId first\n                contactObjId = new mongodb__WEBPACK_IMPORTED_MODULE_3__.ObjectId(contactId);\n            } catch  {\n                // fallback: use raw string\n                contactObjId = contactId;\n            }\n            const doc = await db.collection(\"campaign_contacts\").findOne({\n                campaignId: campaignObjectId,\n                contactId: contactObjId\n            });\n            if (!doc) {\n                return res.status(404).json({\n                    error: \"Contact ledger row not found for campaign\"\n                });\n            }\n            if (doc.status !== \"failed\") {\n                return res.status(400).json({\n                    error: \"Contact is not in failed state\"\n                });\n            }\n            if ((doc.attempts || 0) >= MAX_ATTEMPTS) {\n                return res.status(400).json({\n                    error: \"Contact has reached max manual attempts and cannot be retried\"\n                });\n            }\n            // Prevent manual retry while BullMQ background retries are still running for this contact\n            // Require bgAttempts >= MAX_ATTEMPTS (or missing) before allowing manual retry\n            const bgDone = typeof doc.bgAttempts === \"number\" ? doc.bgAttempts >= MAX_ATTEMPTS : true;\n            if (!bgDone) {\n                return res.status(400).json({\n                    error: \"Background retries are still in progress for this contact. Please wait until the background retry cycle completes.\"\n                });\n            }\n            // Update single doc to pending, increment core attempts, reset bgAttempts\n            await db.collection(\"campaign_contacts\").updateOne({\n                _id: doc._id\n            }, {\n                $set: {\n                    status: \"pending\",\n                    lastError: null,\n                    bgAttempts: 0\n                },\n                $inc: {\n                    attempts: 1\n                }\n            });\n            // Enqueue appropriate job (use doc.step if present) and ensure MQ attempts/backoff are set\n            try {\n                if (doc.step) {\n                    await queue.add(\"followup\", {\n                        campaignId: id,\n                        contactId: contactObjId.toString ? contactObjId.toString() : String(contactObjId),\n                        step: doc.step\n                    }, {\n                        removeOnComplete: true,\n                        removeOnFail: true,\n                        attempts: MAX_ATTEMPTS,\n                        backoff: {\n                            type: \"exponential\",\n                            delay: 60000\n                        }\n                    });\n                } else {\n                    await queue.add(\"initial\", {\n                        campaignId: id,\n                        contactId: contactObjId.toString ? contactObjId.toString() : String(contactObjId)\n                    }, {\n                        removeOnComplete: true,\n                        removeOnFail: true,\n                        attempts: MAX_ATTEMPTS,\n                        backoff: {\n                            type: \"exponential\",\n                            delay: 60000\n                        }\n                    });\n                }\n            } catch (e) {\n                console.warn(\"Failed to enqueue retry job for contact\", e);\n                // Rollback: try to revert the ledger row changes (best-effort)\n                try {\n                    await db.collection(\"campaign_contacts\").updateOne({\n                        _id: doc._id\n                    }, {\n                        $set: {\n                            status: \"failed\",\n                            lastError: \"enqueue-failed\"\n                        },\n                        $inc: {\n                            attempts: -1\n                        },\n                        $set: {\n                            bgAttempts: doc.bgAttempts ?? 0\n                        }\n                    });\n                } catch (_) {}\n                return res.status(500).json({\n                    error: \"Failed to enqueue retry job\"\n                });\n            }\n            // Update redis counters: decrease failed by 1 if possible (we moved it from failed -> pending)\n            try {\n                const currentFailed = await safeGetMetaInt(redisKey, \"failed\");\n                if (currentFailed > 0) {\n                    await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hincrby(redisKey, \"failed\", -1);\n                }\n            } catch (e) {\n                console.warn(\"Failed to update redis counters during retryContact\", e);\n            }\n            // Also decrement processed so totals align (we are un-finalizing a contact)\n            try {\n                const currentProcessed = await safeGetMetaInt(redisKey, \"processed\");\n                if (currentProcessed > 0) {\n                    await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hincrby(redisKey, \"processed\", -1);\n                }\n            } catch (e) {\n                console.warn(\"Failed to update processed counter during retryContact\", e);\n            }\n            // Publish contact update\n            try {\n                const cidStr = contactObjId.toString ? contactObjId.toString() : String(contactObjId);\n                await safePublish(`campaign:${id}:contact_update`, {\n                    contactId: cidStr,\n                    status: \"pending\",\n                    attempts: (doc.attempts || 0) + 1,\n                    bgAttempts: 0\n                });\n            } catch (_) {}\n            await safePublish(\"campaign:new\", {\n                id,\n                action: \"retryContact\",\n                contactId\n            });\n            return res.status(200).json({\n                ok: true,\n                retried: 1,\n                contactId\n            });\n        }\n        // Should not reach here\n        return res.status(400).json({\n            error: \"Unsupported action\"\n        });\n    } catch (err) {\n        console.error(\"Campaign control error\", err);\n        return res.status(500).json({\n            error: \"Internal server error\"\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9wYWdlcy9hcGkvY2FtcGFpZ24vW2lkXS9jb250cm9sLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFDa0Q7QUFDSjtBQUNmO0FBQ0k7QUFFbkMsTUFBTUksUUFBUSxJQUFJRix5Q0FBS0EsQ0FBQyxhQUFhO0lBQUVHLFlBQVlKLDZDQUFLQTtBQUFDO0FBRXpELDhDQUE4QztBQUM5QyxNQUFNSyxlQUFlQyxPQUFPQyxRQUFRQyxHQUFHLENBQUNILFlBQVksSUFBSTtBQUN4RCxnREFBZ0Q7QUFDaEQsTUFBTUksb0JBQW9CSCxPQUFPQyxRQUFRQyxHQUFHLENBQUNDLGlCQUFpQixJQUFJO0FBQ2xFLHNFQUFzRTtBQUN0RSxNQUFNQyx1QkFBdUJKLE9BQU9DLFFBQVFDLEdBQUcsQ0FBQ0Usb0JBQW9CLElBQUk7QUFDeEUscUZBQXFGO0FBQ3JGLE1BQU1DLG1CQUFtQkwsT0FBT0MsUUFBUUMsR0FBRyxDQUFDRyxnQkFBZ0IsSUFBSTtBQUloRSxlQUFlQyxTQUFTQyxHQUFXLEVBQUVDLEdBQTJCO0lBQzlELElBQUk7UUFDRixNQUFNZCw2Q0FBS0EsQ0FBQ2UsSUFBSSxDQUFDRixLQUFLQztJQUN4QixFQUFFLE9BQU9FLEtBQUs7UUFDWkMsUUFBUUMsSUFBSSxDQUFDLHdDQUF3Q0Y7SUFDdkQ7QUFDRjtBQUVBLGVBQWVHLFlBQVlDLE9BQWUsRUFBRUMsT0FBWTtJQUN0RCxJQUFJO1FBQ0YsTUFBTXJCLDZDQUFLQSxDQUFDc0IsT0FBTyxDQUFDRixTQUFTRyxLQUFLQyxTQUFTLENBQUNIO0lBQzlDLEVBQUUsT0FBT0wsS0FBSztRQUNaQyxRQUFRQyxJQUFJLENBQUMsd0JBQXdCRjtJQUN2QztBQUNGO0FBRUEsb0VBQW9FO0FBQ3BFLGVBQWVTLDRCQUE0QkMsVUFBa0I7SUFDM0QsSUFBSTtRQUNGLGtDQUFrQztRQUNsQyxNQUFNQyxPQUFPLE1BQU14QixNQUFNeUIsT0FBTyxDQUM5QjtZQUFDO1lBQVc7WUFBVztZQUFVO1NBQVMsRUFDMUMsR0FDQSxDQUFD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LE1BQU0xSixlQUFlQyxVQUFVO2dCQUN4RCxJQUFJeUosbUJBQW1CLEdBQUc7b0JBQ3hCLE1BQU0vTCw2Q0FBS0EsQ0FBQzZKLE9BQU8sQ0FBQ3ZILFVBQVUsYUFBYSxDQUFDO2dCQUM5QztZQUNGLEVBQUUsT0FBT0osR0FBRztnQkFDVmpCLFFBQVFDLElBQUksQ0FBQywwREFBMERnQjtZQUN6RTtZQUVBLHlCQUF5QjtZQUN6QixJQUFJO2dCQUNGLE1BQU1pSyxTQUFTVCxhQUFhcEYsUUFBUSxHQUFHb0YsYUFBYXBGLFFBQVEsS0FBS2xDLE9BQU9zSDtnQkFDeEUsTUFBTXZLLFlBQVksQ0FBQyxTQUFTLEVBQUVnQixHQUFHLGVBQWUsQ0FBQyxFQUFFO29CQUFFK0IsV0FBV2lJO29CQUFRMUgsUUFBUTtvQkFBV2tDLFVBQVUsQ0FBQzhFLElBQUk5RSxRQUFRLElBQUksS0FBSztvQkFBR2EsWUFBWTtnQkFBRTtZQUM5SSxFQUFFLE9BQU9VLEdBQUcsQ0FBQztZQUViLE1BQU0vRyxZQUFZLGdCQUFnQjtnQkFBRWdCO2dCQUFJMEMsUUFBUTtnQkFBZ0JYO1lBQVU7WUFFMUUsT0FBT0ssSUFBSUUsTUFBTSxDQUFDLEtBQUtDLElBQUksQ0FBQztnQkFBRWEsSUFBSTtnQkFBTTZGLFNBQVM7Z0JBQUdsSDtZQUFVO1FBQ2hFO1FBRUEsd0JBQXdCO1FBQ3hCLE9BQU9LLElBQUlFLE1BQU0sQ0FBQyxLQUFLQyxJQUFJLENBQUM7WUFBRUMsT0FBTztRQUFxQjtJQUM1RCxFQUFFLE9BQU8zRCxLQUFLO1FBQ1pDLFFBQVEwRCxLQUFLLENBQUMsMEJBQTBCM0Q7UUFDeEMsT0FBT3VELElBQUlFLE1BQU0sQ0FBQyxLQUFLQyxJQUFJLENBQUM7WUFBRUMsT0FBTztRQUF3QjtJQUMvRDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0aW5nLW12cC8uL3BhZ2VzL2FwaS9jYW1wYWlnbi9baWRdL2NvbnRyb2wudHM/NjcxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IE5leHRBcGlSZXF1ZXN0LCBOZXh0QXBpUmVzcG9uc2UgfSBmcm9tICduZXh0JztcclxuaW1wb3J0IGNsaWVudFByb21pc2UgZnJvbSAnLi4vLi4vLi4vLi4vbGliL21vbmdvJztcclxuaW1wb3J0IHsgcmVkaXMgfSBmcm9tICcuLi8uLi8uLi8uLi9saWIvcmVkaXMnO1xyXG5pbXBvcnQgeyBRdWV1ZSB9IGZyb20gJ2J1bGxtcSc7XHJcbmltcG9ydCB7IE9iamVjdElkIH0gZnJvbSAnbW9uZ29kYic7XHJcblxyXG5jb25zdCBxdWV1ZSA9IG5ldyBRdWV1ZSgnY2FtcGFpZ25zJywgeyBjb25uZWN0aW9uOiByZWRpcyB9KTtcclxuXHJcbi8vIGtlZXAgcGFyaXR5IHdpdGggd29ya2VyOyBhbGxvdyBlbnYgb3ZlcnJpZGVcclxuY29uc3QgTUFYX0FUVEVNUFRTID0gTnVtYmVyKHByb2Nlc3MuZW52Lk1BWF9BVFRFTVBUUyB8fCAzKTtcclxuLy8gc2VydmVyLXNpZGUgY2FwIGZvciBiYXRjaCByZXRyaWVzIHBlciByZXF1ZXN0XHJcbmNvbnN0IEJBVENIX1JFVFJZX0xJTUlUID0gTnVtYmVyKHByb2Nlc3MuZW52LkJBVENIX1JFVFJZX0xJTUlUIHx8IDUwMDApO1xyXG4vLyB3aGVuIHJlc3VtaW5nLCBsaW1pdCBob3cgbWFueSBwZW5kaW5nIGpvYnMgd2UnbGwgdHJ5IHRvIChyZSllbnF1ZXVlXHJcbmNvbnN0IFJFU1VNRV9FTlFVRVVFX0xJTUlUID0gTnVtYmVyKHByb2Nlc3MuZW52LlJFU1VNRV9FTlFVRVVFX0xJTUlUIHx8IDUwMDApO1xyXG4vLyBob3cgbG9uZyBiZWZvcmUgYSAnc2VuZGluZycgcm93IGlzIGNvbnNpZGVyZWQgc3RhbGUgYW5kIGVsaWdpYmxlIGZvciByZWNvdmVyeSAobXMpXHJcbmNvbnN0IFNUQUxFX1NFTkRJTkdfTVMgPSBOdW1iZXIocHJvY2Vzcy5lbnYuU1RBTEVfU0VORElOR19NUyB8fCA5MF8wMDApO1xyXG5cclxudHlwZSBBY3Rpb24gPSAncGF1c2UnIHwgJ3Jlc3VtZScgfCAnY2FuY2VsJyB8ICdkZWxldGUnIHwgJ3JldHJ5RmFpbGVkJyB8ICdyZXRyeUNvbnRhY3QnIHwgJ3JlY29uY2lsZSc7XHJcblxyXG5hc3luYyBmdW5jdGlvbiBzYWZlSFNldChrZXk6IHN0cmluZywgb2JqOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KSB7XHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IHJlZGlzLmhzZXQoa2V5LCBvYmopO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgY29uc29sZS53YXJuKCdSZWRpcyB1bmF2YWlsYWJsZSB3aGlsZSBzZXR0aW5nIG1ldGEnLCBlcnIpO1xyXG4gIH1cclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gc2FmZVB1Ymxpc2goY2hhbm5lbDogc3RyaW5nLCBwYXlsb2FkOiBhbnkpIHtcclxuICB0cnkge1xyXG4gICAgYXdhaXQgcmVkaXMucHVibGlzaChjaGFubmVsLCBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ1JlZGlzIHB1Ymxpc2ggZmFpbGVkJywgZXJyKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIFJlbW92ZSB3YWl0aW5nL2RlbGF5ZWQvYWN0aXZlIGpvYnMgZm9yIGEgY2FtcGFpZ25JZCAoYmVzdC1lZmZvcnQpXHJcbmFzeW5jIGZ1bmN0aW9uIHJlbW92ZVF1ZXVlZEpvYnNGb3JDYW1wYWlnbihjYW1wYWlnbklkOiBzdHJpbmcpIHtcclxuICB0cnkge1xyXG4gICAgLy8gZ2V0IHdhaXRpbmcvZGVsYXllZC9hY3RpdmUgam9ic1xyXG4gICAgY29uc3Qgam9icyA9IGF3YWl0IHF1ZXVlLmdldEpvYnMoXHJcbiAgICAgIFsnd2FpdGluZycsICdkZWxheWVkJywgJ2FjdGl2ZScsICdwYXVzZWQnXSxcclxuICAgICAgMCxcclxuICAgICAgLTFcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgbWF0Y2hlZCA9IGpvYnMuZmlsdGVyKChqKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIGouZGF0YT8uY2FtcGFpZ25JZCA9PT0gY2FtcGFpZ25JZDtcclxuICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IGogb2YgbWF0Y2hlZCkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIGlmIHRoZSBqb2IgaXMgYWN0aXZlLCByZW1vdmUgbWF5IGZhaWwgLSBzdGlsbCB0cnlcclxuICAgICAgICBhd2FpdCBqLnJlbW92ZSgpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gYmVzdC1lZmZvcnQg4oCUIGlnbm9yZVxyXG4gICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIHJlbW92ZSBqb2IgJHtqLmlkfWAsIGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWF0Y2hlZC5sZW5ndGg7XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBlbnVtZXJhdGUvcmVtb3ZlIGpvYnMgZm9yIGNhbXBhaWduJywgZXJyKTtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxufVxyXG5cclxuLy8gc2FmZSByZWFkIG9mIHJlZGlzIG1ldGEgaW50ZWdlciBmaWVsZFxyXG5hc3luYyBmdW5jdGlvbiBzYWZlR2V0TWV0YUludChyZWRpc0tleTogc3RyaW5nLCBmaWVsZDogc3RyaW5nKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHYgPSBhd2FpdCByZWRpcy5oZ2V0KHJlZGlzS2V5LCBmaWVsZCk7XHJcbiAgICByZXR1cm4gTnVtYmVyKHYgfHwgMCk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRW5zdXJlIHRoZXJlIGlzIGEgdXNhYmxlIGBjYW1wYWlnbjp7aWR9OmRlZmluaXRpb25gIGluIFJlZGlzLlxyXG4gKiBJZiBtaXNzaW5nLCBhdHRlbXB0IHRvIGNvbnN0cnVjdCBvbmUgZnJvbSB0aGUgTW9uZ28gY2FtcGFpZ24gZG9jdW1lbnQuXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiBkZWZpbml0aW9uIGV4aXN0cyBvciB3YXMgd3JpdHRlbiBzdWNjZXNzZnVsbHkuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBlbnN1cmVDYW1wYWlnbkRlZmluaXRpb24oaWQ6IHN0cmluZywgY2FtcGFpZ25Eb2M6IGFueSk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gIGNvbnN0IGtleSA9IGBjYW1wYWlnbjoke2lkfTpkZWZpbml0aW9uYDtcclxuICB0cnkge1xyXG4gICAgY29uc3QgZXhpc3RpbmcgPSBhd2FpdCByZWRpcy5nZXQoa2V5KTtcclxuICAgIGlmIChleGlzdGluZykgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgLy8gQXR0ZW1wdCB0byBidWlsZCBhIG1pbmltYWwgY29tcGF0aWJsZSBkZWZpbml0aW9uXHJcbiAgICAvLyBXb3JrZXIgZXhwZWN0cyB7IGluaXRpYWw6IHsgc3ViamVjdCwgYm9keSB9LCBmb2xsb3dVcHM6IFsuLi5dIH1cclxuICAgIGxldCBidWlsdDogYW55ID0gbnVsbDtcclxuXHJcbiAgICAvLyBQcmVmZXIgZXhwbGljaXQgc2hhcGVzIGNvbW1vbmx5IHVzZWRcclxuICAgIGlmIChjYW1wYWlnbkRvYz8uZGVmaW5pdGlvbiAmJiB0eXBlb2YgY2FtcGFpZ25Eb2MuZGVmaW5pdGlvbiA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgYnVpbHQgPSBjYW1wYWlnbkRvYy5kZWZpbml0aW9uO1xyXG4gICAgfSBlbHNlIGlmIChjYW1wYWlnbkRvYz8uaW5pdGlhbCAmJiB0eXBlb2YgY2FtcGFpZ25Eb2MuaW5pdGlhbCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgYnVpbHQgPSB7IGluaXRpYWw6IGNhbXBhaWduRG9jLmluaXRpYWwsIGZvbGxvd1VwczogY2FtcGFpZ25Eb2MuZm9sbG93VXBzIHx8IFtdIH07XHJcbiAgICB9IGVsc2UgaWYgKGNhbXBhaWduRG9jPy50ZW1wbGF0ZSAmJiB0eXBlb2YgY2FtcGFpZ25Eb2MudGVtcGxhdGUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIGJ1aWx0ID0geyBpbml0aWFsOiB7IHN1YmplY3Q6IGNhbXBhaWduRG9jLnRlbXBsYXRlLnN1YmplY3QgfHwgY2FtcGFpZ25Eb2MubmFtZSwgYm9keTogY2FtcGFpZ25Eb2MudGVtcGxhdGUuYm9keSB8fCBjYW1wYWlnbkRvYy5jb250ZW50IHx8ICcnIH0sIGZvbGxvd1VwczogY2FtcGFpZ25Eb2MudGVtcGxhdGUuZm9sbG93VXBzIHx8IGNhbXBhaWduRG9jLmZvbGxvd1VwcyB8fCBbXSB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gZmFsbGJhY2s6IHRyeSB0byBnbGVhbiBzdWJqZWN0L2JvZHkgZnJvbSBjb21tb24gZmllbGRzXHJcbiAgICAgIGNvbnN0IHN1YmplY3QgPSBjYW1wYWlnbkRvYz8uc3ViamVjdCB8fCBjYW1wYWlnbkRvYz8udGl0bGUgfHwgY2FtcGFpZ25Eb2M/Lm5hbWUgfHwgYENhbXBhaWduICR7aWR9YDtcclxuICAgICAgY29uc3QgYm9keSA9IGNhbXBhaWduRG9jPy5ib2R5IHx8IGNhbXBhaWduRG9jPy5jb250ZW50IHx8IGNhbXBhaWduRG9jPy5odG1sIHx8ICcnO1xyXG4gICAgICBjb25zdCBmb2xsb3dVcHMgPSBjYW1wYWlnbkRvYz8uZm9sbG93VXBzIHx8IGNhbXBhaWduRG9jPy5zdGVwcyB8fCBbXTtcclxuICAgICAgYnVpbHQgPSB7IGluaXRpYWw6IHsgc3ViamVjdCwgYm9keSB9LCBmb2xsb3dVcHMgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBidWlsdCBkb2Vzbid0IGxvb2sgcmlnaHQgKG5vIGluaXRpYWwgc3ViamVjdC9ib2R5KSwgZmFpbCBzYWZlXHJcbiAgICBpZiAoIWJ1aWx0IHx8ICFidWlsdC5pbml0aWFsIHx8IChidWlsdC5pbml0aWFsLnN1YmplY3QgPT0gbnVsbCAmJiBidWlsdC5pbml0aWFsLmJvZHkgPT0gbnVsbCkpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gY29uc3RydWN0IGNhbXBhaWduIGRlZmluaXRpb24gZnJvbSBjYW1wYWlnbiBkb2N1bWVudCcsIHsgY2FtcGFpZ25JZDogaWQsIHNhbXBsZTogY2FtcGFpZ25Eb2MgPyBPYmplY3Qua2V5cyhjYW1wYWlnbkRvYykuc2xpY2UoMCwgOCkgOiBudWxsIH0pO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGVyc2lzdCBpbnRvIFJlZGlzIChubyBleHBpcnkpIHNvIHdvcmtlciBjYW4gcmVhZCBpdFxyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgcmVkaXMuc2V0KGtleSwgSlNPTi5zdHJpbmdpZnkoYnVpbHQpKTtcclxuICAgICAgY29uc29sZS5sb2coYFdyb3RlIGZhbGxiYWNrIGNhbXBhaWduIGRlZmluaXRpb24gaW50byByZWRpcyBmb3IgJHtpZH1gKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHdyaXRlIGNhbXBhaWduIGRlZmluaXRpb24gdG8gcmVkaXMnLCBlKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGNvbnNvbGUud2FybignRXJyb3IgY2hlY2tpbmcvd3JpdGluZyBjYW1wYWlnbiBkZWZpbml0aW9uIGluIHJlZGlzJywgZSk7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IGEgc2V0IG9mIGNvbnRhY3RJZCBzdHJpbmdzIGZvciBqb2JzIGN1cnJlbnRseSBlbnF1ZXVlZCBmb3IgdGhpcyBjYW1wYWlnbi5cclxuICogVXNlZCB0byBhdm9pZCBlbnF1ZXVpbmcgZHVwbGljYXRlcyB3aGVuIHJlc3VtaW5nLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZ2V0UXVldWVkQ29udGFjdElkc0ZvckNhbXBhaWduKGNhbXBhaWduSWQ6IHN0cmluZyk6IFByb21pc2U8U2V0PHN0cmluZz4+IHtcclxuICBjb25zdCBzZXQgPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgam9icyA9IGF3YWl0IHF1ZXVlLmdldEpvYnMoWyd3YWl0aW5nJywgJ2RlbGF5ZWQnLCAnYWN0aXZlJywgJ3BhdXNlZCddLCAwLCAtMSk7XHJcbiAgICBmb3IgKGNvbnN0IGogb2Ygam9icykge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmIChqLmRhdGE/LmNhbXBhaWduSWQgPT09IGNhbXBhaWduSWQgJiYgai5kYXRhPy5jb250YWN0SWQpIHtcclxuICAgICAgICAgIHNldC5hZGQoU3RyaW5nKGouZGF0YS5jb250YWN0SWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgIC8vIGlnbm9yZSBtYWxmb3JtZWQgam9ic1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gbGlzdCBxdWV1ZWQgam9icyBmb3IgY2FtcGFpZ24gd2hlbiBjaGVja2luZyBkdXBsaWNhdGVzJywgZSk7XHJcbiAgfVxyXG4gIHJldHVybiBzZXQ7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIoXHJcbiAgcmVxOiBOZXh0QXBpUmVxdWVzdCxcclxuICByZXM6IE5leHRBcGlSZXNwb25zZVxyXG4pIHtcclxuICBpZiAocmVxLm1ldGhvZCAhPT0gJ1BPU1QnKSB7XHJcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDUpLmpzb24oeyBlcnJvcjogJ01ldGhvZCBub3QgYWxsb3dlZCcgfSk7XHJcbiAgfVxyXG5cclxuICBjb25zdCB7IGlkIH0gPSByZXEucXVlcnk7XHJcbiAgaWYgKCFpZCB8fCB0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBlcnJvcjogJ0ludmFsaWQgY2FtcGFpZ24gaWQnIH0pO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgeyBhY3Rpb24sIGNvbmZpcm0sIGNvbnRhY3RJZCB9ID0gcmVxLmJvZHkgYXMge1xyXG4gICAgYWN0aW9uPzogQWN0aW9uO1xyXG4gICAgY29uZmlybT86IGJvb2xlYW47XHJcbiAgICBjb250YWN0SWQ/OiBzdHJpbmc7XHJcbiAgfTtcclxuXHJcbiAgaWYgKCFhY3Rpb24gfHwgIVsncGF1c2UnLCAncmVzdW1lJywgJ2NhbmNlbCcsICdkZWxldGUnLCAncmV0cnlGYWlsZWQnLCAncmV0cnlDb250YWN0JywgJ3JlY29uY2lsZSddLmluY2x1ZGVzKGFjdGlvbikpIHtcclxuICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IGVycm9yOiAnSW52YWxpZCBhY3Rpb24nIH0pO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgY2xpZW50ID0gYXdhaXQgY2xpZW50UHJvbWlzZTtcclxuICBjb25zdCBkYiA9IGNsaWVudC5kYignUGxhdGZvcm1EYXRhJyk7XHJcbiAgY29uc3QgY2FtcGFpZ25PYmplY3RJZCA9IG5ldyBPYmplY3RJZChpZCk7XHJcblxyXG4gIHRyeSB7XHJcbiAgICAvLyBSZWxvYWQgY2FtcGFpZ24gZnJvbSBNb25nbyAoYXV0aG9yaXRhdGl2ZSlcclxuICAgIGNvbnN0IGNhbXBhaWduID0gYXdhaXQgZGJcclxuICAgICAgLmNvbGxlY3Rpb24oJ2NhbXBhaWducycpXHJcbiAgICAgIC5maW5kT25lKHsgX2lkOiBjYW1wYWlnbk9iamVjdElkIH0pO1xyXG5cclxuICAgIGlmICghY2FtcGFpZ24pIHtcclxuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA0KS5qc29uKHsgZXJyb3I6ICdDYW1wYWlnbiBub3QgZm91bmQnIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIExpZ2h0d2VpZ2h0IGhlbHBlcnNcclxuICAgIGNvbnN0IHJlZGlzS2V5ID0gYGNhbXBhaWduOiR7aWR9Om1ldGFgO1xyXG5cclxuICAgIC8vIEFDVElPTjogUGF1c2VcclxuICAgIGlmIChhY3Rpb24gPT09ICdwYXVzZScpIHtcclxuICAgICAgaWYgKGNhbXBhaWduLnN0YXR1cyA9PT0gJ3BhdXNlZCcpIHtcclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oeyBvazogdHJ1ZSwgbWVzc2FnZTogJ0FscmVhZHkgcGF1c2VkJyB9KTtcclxuICAgICAgfVxyXG4gICAgICBhd2FpdCBkYi5jb2xsZWN0aW9uKCdjYW1wYWlnbnMnKS51cGRhdGVPbmUoXHJcbiAgICAgICAgeyBfaWQ6IGNhbXBhaWduT2JqZWN0SWQgfSxcclxuICAgICAgICB7ICRzZXQ6IHsgc3RhdHVzOiAncGF1c2VkJyB9IH1cclxuICAgICAgKTtcclxuICAgICAgYXdhaXQgc2FmZUhTZXQocmVkaXNLZXksIHsgc3RhdHVzOiAncGF1c2VkJyB9KTtcclxuICAgICAgLy8gcHVibGlzaCBjYW1wYWlnbi1sZXZlbCBldmVudCBzbyBVSSBkaXNhYmxlcyByZXRyeSBidXR0b25zIGFuZCB1cGRhdGVzIHN0YXRlXHJcbiAgICAgIGF3YWl0IHNhZmVQdWJsaXNoKCdjYW1wYWlnbjpuZXcnLCB7IGlkLCBzdGF0dXM6ICdwYXVzZWQnIH0pO1xyXG4gICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oeyBvazogdHJ1ZSwgYWN0aW9uOiAncGF1c2VkJyB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBQ1RJT046IFJlc3VtZVxyXG4gICAgaWYgKGFjdGlvbiA9PT0gJ3Jlc3VtZScpIHtcclxuICAgICAgaWYgKGNhbXBhaWduLnN0YXR1cyA9PT0gJ3J1bm5pbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHsgb2s6IHRydWUsIG1lc3NhZ2U6ICdBbHJlYWR5IHJ1bm5pbmcnIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBzZXQgcnVubmluZyBpbiBEQiArIHJlZGlzXHJcbiAgICAgIGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWducycpLnVwZGF0ZU9uZShcclxuICAgICAgICB7IF9pZDogY2FtcGFpZ25PYmplY3RJZCB9LFxyXG4gICAgICAgIHsgJHNldDogeyBzdGF0dXM6ICdydW5uaW5nJyB9IH1cclxuICAgICAgKTtcclxuICAgICAgYXdhaXQgc2FmZUhTZXQocmVkaXNLZXksIHsgc3RhdHVzOiAncnVubmluZycgfSk7XHJcbiAgICAgIGF3YWl0IHNhZmVQdWJsaXNoKCdjYW1wYWlnbjpuZXcnLCB7IGlkLCBzdGF0dXM6ICdydW5uaW5nJyB9KTtcclxuXHJcbiAgICAgIC8vIFJlLWVucXVldWUgcGVuZGluZyBjb250YWN0cyB0aGF0IGN1cnJlbnRseSBoYXZlIG5vIHF1ZXVlZCBqb2IgZm9yIHRoaXMgY2FtcGFpZ24uXHJcbiAgICAgIC8vIFRoaXMgYWRkcmVzc2VzIGNhc2VzIHdoZXJlIGpvYnMgd2VyZSByZW1vdmVkIG9yIG5vdCBlbnF1ZXVlZCB3aGlsZSB0aGUgY2FtcGFpZ24gd2FzIHBhdXNlZCxcclxuICAgICAgLy8gZW5zdXJpbmcgcGVuZGluZyByb3dzIGFjdHVhbGx5IGdldCBwcm9jZXNzZWQgYWdhaW4gYWZ0ZXIgcmVzdW1lLlxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHF1ZXVlZFNldCA9IGF3YWl0IGdldFF1ZXVlZENvbnRhY3RJZHNGb3JDYW1wYWlnbihpZCk7XHJcblxyXG4gICAgICAgIC8vIGZldGNoIHBlbmRpbmcgZG9jcyAobGltaXQgdG8gYSBzYW5lIGNhcClcclxuICAgICAgICBjb25zdCBwZW5kaW5nQ3Vyc29yID0gZGIuY29sbGVjdGlvbignY2FtcGFpZ25fY29udGFjdHMnKS5maW5kKFxyXG4gICAgICAgICAgeyBjYW1wYWlnbklkOiBjYW1wYWlnbk9iamVjdElkLCBzdGF0dXM6ICdwZW5kaW5nJyB9LFxyXG4gICAgICAgICAgeyBwcm9qZWN0aW9uOiB7IF9pZDogMSwgY29udGFjdElkOiAxLCBzdGVwOiAxIH0gfVxyXG4gICAgICAgICkubGltaXQoUkVTVU1FX0VOUVVFVUVfTElNSVQpO1xyXG5cclxuICAgICAgICBjb25zdCBwZW5kaW5nOiBhbnlbXSA9IGF3YWl0IHBlbmRpbmdDdXJzb3IudG9BcnJheSgpO1xyXG5cclxuICAgICAgICBjb25zdCBlbnF1ZXVlUHJvbWlzZXM6IFByb21pc2U8YW55PltdID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBkIG9mIHBlbmRpbmcpIHtcclxuICAgICAgICAgIGNvbnN0IGNpZCA9IGQuY29udGFjdElkID8gKGQuY29udGFjdElkLnRvU3RyaW5nID8gZC5jb250YWN0SWQudG9TdHJpbmcoKSA6IFN0cmluZyhkLmNvbnRhY3RJZCkpIDogKGQuX2lkLnRvU3RyaW5nID8gZC5faWQudG9TdHJpbmcoKSA6IFN0cmluZyhkLl9pZCkpO1xyXG4gICAgICAgICAgaWYgKHF1ZXVlZFNldC5oYXMoY2lkKSkgY29udGludWU7IC8vIGFscmVhZHkgcXVldWVkXHJcblxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZW5xdWV1ZVByb21pc2VzLnB1c2goXHJcbiAgICAgICAgICAgICAgcXVldWUuYWRkKFxyXG4gICAgICAgICAgICAgICAgZC5zdGVwID8gJ2ZvbGxvd3VwJyA6ICdpbml0aWFsJyxcclxuICAgICAgICAgICAgICAgIHsgY2FtcGFpZ25JZDogaWQsIGNvbnRhY3RJZDogY2lkLCBzdGVwOiBkLnN0ZXAgfSxcclxuICAgICAgICAgICAgICAgIHsgcmVtb3ZlT25Db21wbGV0ZTogdHJ1ZSwgcmVtb3ZlT25GYWlsOiB0cnVlLCBhdHRlbXB0czogTUFYX0FUVEVNUFRTLCBiYWNrb2ZmOiB7IHR5cGU6ICdleHBvbmVudGlhbCcsIGRlbGF5OiA2MF8wMDAgfSB9XHJcbiAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBlbnF1ZXVlIHBlbmRpbmcgY29udGFjdCBvbiByZXN1bWUnLCBlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGF0dGVtcHQgdG8gZW5xdWV1ZSBpbiBwYXJhbGxlbCAoYmVzdC1lZmZvcnQpXHJcbiAgICAgICAgaWYgKGVucXVldWVQcm9taXNlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoZW5xdWV1ZVByb21pc2VzKTtcclxuICAgICAgICAgIC8vIG5vdGlmeSBVSSB0aGF0IGNvbnRhY3RzIGhhdmUgYmVlbiByZS1xdWV1ZWQgKGNvdW50cyB1bmNoYW5nZWQsIGJ1dCBVSSBtYXkgd2FudCB0byByZWZyZXNoKVxyXG4gICAgICAgICAgYXdhaXQgc2FmZVB1Ymxpc2goJ2NhbXBhaWduOm5ldycsIHsgaWQsIGFjdGlvbjogJ3Jlc3VtZV9yZXF1ZXVlZCcsIHJlcXVldWVkOiBlbnF1ZXVlUHJvbWlzZXMubGVuZ3RoIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHJlLWVucXVldWUgcGVuZGluZyBjb250YWN0cyBvbiByZXN1bWUnLCBlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVjb3ZlciBzdGFsZSAnc2VuZGluZycgbGVkZ2VyIHJvd3MgdGhhdCBtYXkgaGF2ZSBiZWVuIGxlZnQgaW4gJ3NlbmRpbmcnIGJ5IGEgY3Jhc2hlZCB3b3JrZXIgb3Iga2lsbGVkIHByb2Nlc3MuXHJcbiAgICAgIC8vIENyaXRlcmlhOiBzdGF0dXMgPT09ICdzZW5kaW5nJyBBTkQgbGFzdEF0dGVtcHRBdCBvbGRlciB0aGFuIFNUQUxFX1NFTkRJTkdfTVMgQU5EIGJnQXR0ZW1wdHMgPCBNQVhfQVRURU1QVFNcclxuICAgICAgLy8gV2UnbGwgc2V0IHRoZW0gYmFjayB0byAncGVuZGluZycsIHJlc2V0IGJnQXR0ZW1wdHMgdG8gMCAoc28gYmFja2dyb3VuZCBjeWNsZSByZXN0YXJ0cyksIGFuZCBlbnF1ZXVlIGpvYnMuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgY3V0b2ZmID0gbmV3IERhdGUoRGF0ZS5ub3coKSAtIFNUQUxFX1NFTkRJTkdfTVMpO1xyXG4gICAgICAgIGNvbnN0IHN0YWxlQ3Vyc29yID0gZGIuY29sbGVjdGlvbignY2FtcGFpZ25fY29udGFjdHMnKS5maW5kKFxyXG4gICAgICAgICAgeyBjYW1wYWlnbklkOiBjYW1wYWlnbk9iamVjdElkLCBzdGF0dXM6ICdzZW5kaW5nJywgbGFzdEF0dGVtcHRBdDogeyAkbHQ6IGN1dG9mZiB9IH0sXHJcbiAgICAgICAgICB7IHByb2plY3Rpb246IHsgX2lkOiAxLCBjb250YWN0SWQ6IDEsIHN0ZXA6IDEsIGJnQXR0ZW1wdHM6IDEgfSB9XHJcbiAgICAgICAgKS5saW1pdChSRVNVTUVfRU5RVUVVRV9MSU1JVCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHN0YWxlRG9jcyA9IGF3YWl0IHN0YWxlQ3Vyc29yLnRvQXJyYXkoKTtcclxuICAgICAgICBpZiAoc3RhbGVEb2NzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGNvbnN0IGlkcyA9IHN0YWxlRG9jcy5tYXAoZCA9PiBkLl9pZCk7XHJcbiAgICAgICAgICAvLyBSZXNldCB0byBwZW5kaW5nIGFuZCBjbGVhciBsYXN0RXJyb3IsIHJlc2V0IGJnQXR0ZW1wdHMgc28gYmFja2dyb3VuZCByZXRyaWVzIHN0YXJ0IGZyZXNoXHJcbiAgICAgICAgICBhd2FpdCBkYi5jb2xsZWN0aW9uKCdjYW1wYWlnbl9jb250YWN0cycpLnVwZGF0ZU1hbnkoXHJcbiAgICAgICAgICAgIHsgX2lkOiB7ICRpbjogaWRzIH0gfSxcclxuICAgICAgICAgICAgeyAkc2V0OiB7IHN0YXR1czogJ3BlbmRpbmcnLCBsYXN0RXJyb3I6IG51bGwsIGJnQXR0ZW1wdHM6IDAgfSB9XHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIC8vIEVucXVldWUgZWFjaCBzdGFsZSBkb2MgaWYgbm90IGFscmVhZHkgcXVldWVkXHJcbiAgICAgICAgICBjb25zdCBxdWV1ZWRTZXQyID0gYXdhaXQgZ2V0UXVldWVkQ29udGFjdElkc0ZvckNhbXBhaWduKGlkKTtcclxuICAgICAgICAgIGNvbnN0IHJlcXVldWVQcm9taXNlczogUHJvbWlzZTxhbnk+W10gPSBbXTtcclxuICAgICAgICAgIGZvciAoY29uc3QgZCBvZiBzdGFsZURvY3MpIHtcclxuICAgICAgICAgICAgY29uc3QgY2lkID0gZC5jb250YWN0SWQgPyAoZC5jb250YWN0SWQudG9TdHJpbmcgPyBkLmNvbnRhY3RJZC50b1N0cmluZygpIDogU3RyaW5nKGQuY29udGFjdElkKSkgOiAoZC5faWQudG9TdHJpbmcgPyBkLl9pZC50b1N0cmluZygpIDogU3RyaW5nKGQuX2lkKSk7XHJcbiAgICAgICAgICAgIGlmIChxdWV1ZWRTZXQyLmhhcyhjaWQpKSBjb250aW51ZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICByZXF1ZXVlUHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICAgIHF1ZXVlLmFkZChcclxuICAgICAgICAgICAgICAgICAgZC5zdGVwID8gJ2ZvbGxvd3VwJyA6ICdpbml0aWFsJyxcclxuICAgICAgICAgICAgICAgICAgeyBjYW1wYWlnbklkOiBpZCwgY29udGFjdElkOiBjaWQsIHN0ZXA6IGQuc3RlcCB9LFxyXG4gICAgICAgICAgICAgICAgICB7IHJlbW92ZU9uQ29tcGxldGU6IHRydWUsIHJlbW92ZU9uRmFpbDogdHJ1ZSwgYXR0ZW1wdHM6IE1BWF9BVFRFTVBUUywgYmFja29mZjogeyB0eXBlOiAnZXhwb25lbnRpYWwnLCBkZWxheTogNjBfMDAwIH0gfVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBlbnF1ZXVlIHN0YWxlIHNlbmRpbmcgY29udGFjdCBvbiByZXN1bWUnLCBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwdWJsaXNoIGNvbnRhY3QtbGV2ZWwgdXBkYXRlIGhpbnQgc28gVUkgcmVmbGVjdHMgaXQncyBub3cgcGVuZGluZ1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIHNhZmVQdWJsaXNoKGBjYW1wYWlnbjoke2lkfTpjb250YWN0X3VwZGF0ZWAsIHsgY29udGFjdElkOiBjaWQsIHN0YXR1czogJ3BlbmRpbmcnLCBiZ0F0dGVtcHRzOiAwLCBhdHRlbXB0czogdW5kZWZpbmVkIH0pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChfKSB7fVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChyZXF1ZXVlUHJvbWlzZXMubGVuZ3RoID4gMCkgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHJlcXVldWVQcm9taXNlcyk7XHJcbiAgICAgICAgICBhd2FpdCBzYWZlUHVibGlzaCgnY2FtcGFpZ246bmV3JywgeyBpZCwgYWN0aW9uOiAncmVzdW1lX3JlY292ZXJlZF9zZW5kaW5nJywgcmVjb3ZlcmVkOiBzdGFsZURvY3MubGVuZ3RoIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHJlY292ZXIgc3RhbGUgc2VuZGluZyByb3dzIG9uIHJlc3VtZScsIGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oeyBvazogdHJ1ZSwgYWN0aW9uOiAncmVzdW1lZCcgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQUNUSU9OOiBSZWNvbmNpbGUgKGxpZ2h0d2VpZ2h0LCBzaW5nbGUtcmVxdWVzdCByZWNvbmNpbGlhdGlvbilcclxuICAgIGlmIChhY3Rpb24gPT09ICdyZWNvbmNpbGUnKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gMSkgUmVjb3ZlciBzdGFsZSAnc2VuZGluZycgcm93cyAtPiBwZW5kaW5nXHJcbiAgICAgICAgY29uc3QgY3V0b2ZmID0gbmV3IERhdGUoRGF0ZS5ub3coKSAtIFNUQUxFX1NFTkRJTkdfTVMpO1xyXG4gICAgICAgIGNvbnN0IHN0YWxlU2VuZGluZyA9IGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWduX2NvbnRhY3RzJykuZmluZCh7XHJcbiAgICAgICAgICBjYW1wYWlnbklkOiBjYW1wYWlnbk9iamVjdElkLFxyXG4gICAgICAgICAgc3RhdHVzOiAnc2VuZGluZycsXHJcbiAgICAgICAgICBsYXN0QXR0ZW1wdEF0OiB7ICRsdDogY3V0b2ZmIH0sXHJcbiAgICAgICAgfSkucHJvamVjdCh7IF9pZDogMSwgY29udGFjdElkOiAxLCBzdGVwOiAxIH0pLmxpbWl0KFJFU1VNRV9FTlFVRVVFX0xJTUlUKS50b0FycmF5KCk7XHJcblxyXG4gICAgICAgIGlmIChzdGFsZVNlbmRpbmcubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgY29uc3QgaWRzID0gc3RhbGVTZW5kaW5nLm1hcChkID0+IGQuX2lkKTtcclxuICAgICAgICAgIGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWduX2NvbnRhY3RzJykudXBkYXRlTWFueShcclxuICAgICAgICAgICAgeyBfaWQ6IHsgJGluOiBpZHMgfSB9LFxyXG4gICAgICAgICAgICB7ICRzZXQ6IHsgc3RhdHVzOiAncGVuZGluZycsIGxhc3RFcnJvcjogbnVsbCwgYmdBdHRlbXB0czogMCB9IH1cclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAyKSBFbnF1ZXVlIHBlbmRpbmcgZG9jcyB0aGF0IGRvIG5vdCBjdXJyZW50bHkgaGF2ZSBhIGpvYlxyXG4gICAgICAgIGNvbnN0IHF1ZXVlZFNldCA9IGF3YWl0IGdldFF1ZXVlZENvbnRhY3RJZHNGb3JDYW1wYWlnbihpZCk7XHJcbiAgICAgICAgY29uc3QgcGVuZGluZ0N1cnNvciA9IGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWduX2NvbnRhY3RzJykuZmluZChcclxuICAgICAgICAgIHsgY2FtcGFpZ25JZDogY2FtcGFpZ25PYmplY3RJZCwgc3RhdHVzOiAncGVuZGluZycgfSxcclxuICAgICAgICAgIHsgcHJvamVjdGlvbjogeyBfaWQ6IDEsIGNvbnRhY3RJZDogMSwgc3RlcDogMSB9IH1cclxuICAgICAgICApLmxpbWl0KFJFU1VNRV9FTlFVRVVFX0xJTUlUKTtcclxuICAgICAgICBjb25zdCBwZW5kaW5nUm93cyA9IGF3YWl0IHBlbmRpbmdDdXJzb3IudG9BcnJheSgpO1xyXG5cclxuICAgICAgICBjb25zdCBlbnF1ZXVlUHJvbWlzZXM6IFByb21pc2U8YW55PltdID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBkIG9mIHBlbmRpbmdSb3dzKSB7XHJcbiAgICAgICAgICBjb25zdCBjaWQgPSBkLmNvbnRhY3RJZCA/IChkLmNvbnRhY3RJZC50b1N0cmluZyA/IGQuY29udGFjdElkLnRvU3RyaW5nKCkgOiBTdHJpbmcoZC5jb250YWN0SWQpKSA6IChkLl9pZC50b1N0cmluZyA/IGQuX2lkLnRvU3RyaW5nKCkgOiBTdHJpbmcoZC5faWQpKTtcclxuICAgICAgICAgIGlmIChxdWV1ZWRTZXQuaGFzKGNpZCkpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZW5xdWV1ZVByb21pc2VzLnB1c2goXHJcbiAgICAgICAgICAgICAgcXVldWUuYWRkKFxyXG4gICAgICAgICAgICAgICAgZC5zdGVwID8gJ2ZvbGxvd3VwJyA6ICdpbml0aWFsJyxcclxuICAgICAgICAgICAgICAgIHsgY2FtcGFpZ25JZDogaWQsIGNvbnRhY3RJZDogY2lkLCBzdGVwOiBkLnN0ZXAgfSxcclxuICAgICAgICAgICAgICAgIHsgcmVtb3ZlT25Db21wbGV0ZTogdHJ1ZSwgcmVtb3ZlT25GYWlsOiB0cnVlLCBhdHRlbXB0czogTUFYX0FUVEVNUFRTLCBiYWNrb2ZmOiB7IHR5cGU6ICdleHBvbmVudGlhbCcsIGRlbGF5OiA2MF8wMDAgfSB9XHJcbiAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1JlY29uY2lsZTogZmFpbGVkIHRvIGVucXVldWUnLCBlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVucXVldWVQcm9taXNlcy5sZW5ndGgpIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChlbnF1ZXVlUHJvbWlzZXMpO1xyXG5cclxuICAgICAgICAvLyAzKSBSZWNhbGN1bGF0ZSB0b3RhbHMgZnJvbSBEQiAoYXV0aG9yaXRhdGl2ZSlcclxuICAgICAgICBjb25zdCBhZ2cgPSBhd2FpdCBkYi5jb2xsZWN0aW9uKCdjYW1wYWlnbl9jb250YWN0cycpLmFnZ3JlZ2F0ZShbXHJcbiAgICAgICAgICB7ICRtYXRjaDogeyBjYW1wYWlnbklkOiBjYW1wYWlnbk9iamVjdElkIH0gfSxcclxuICAgICAgICAgIHsgJGdyb3VwOiB7IF9pZDogJyRzdGF0dXMnLCBjb3VudDogeyAkc3VtOiAxIH0gfSB9XHJcbiAgICAgICAgXSkudG9BcnJheSgpO1xyXG5cclxuICAgICAgICBsZXQgcGVuZGluZyA9IDAsIHNlbnQgPSAwLCBmYWlsZWQgPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3QgciBvZiBhZ2cpIHtcclxuICAgICAgICAgIGlmIChyLl9pZCA9PT0gJ3BlbmRpbmcnKSBwZW5kaW5nID0gci5jb3VudDtcclxuICAgICAgICAgIGVsc2UgaWYgKHIuX2lkID09PSAnc2VudCcpIHNlbnQgPSByLmNvdW50O1xyXG4gICAgICAgICAgZWxzZSBpZiAoci5faWQgPT09ICdmYWlsZWQnKSBmYWlsZWQgPSByLmNvdW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBzZW50ICsgZmFpbGVkO1xyXG4gICAgICAgIGNvbnN0IGludGVuZGVkID0gY2FtcGFpZ24udG90YWxzPy5pbnRlbmRlZCA/PyAoYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25fY29udGFjdHMnKS5jb3VudERvY3VtZW50cyh7IGNhbXBhaWduSWQ6IGNhbXBhaWduT2JqZWN0SWQgfSkpO1xyXG5cclxuICAgICAgICAvLyBXcml0ZSBiYWNrIGF1dGhvcml0YXRpdmUgdG90YWxzIHRvIERCXHJcbiAgICAgICAgYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25zJykudXBkYXRlT25lKFxyXG4gICAgICAgICAgeyBfaWQ6IGNhbXBhaWduT2JqZWN0SWQgfSxcclxuICAgICAgICAgIHsgJHNldDogeyAndG90YWxzLnByb2Nlc3NlZCc6IHByb2Nlc3NlZCwgJ3RvdGFscy5zZW50Jzogc2VudCwgJ3RvdGFscy5mYWlsZWQnOiBmYWlsZWQgfSB9XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gQmVzdC1lZmZvcnQgd3JpdGUgdG8gUmVkaXMgbWV0YVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBhd2FpdCByZWRpcy5oc2V0KHJlZGlzS2V5LCB7IHByb2Nlc3NlZDogU3RyaW5nKHByb2Nlc3NlZCksIHNlbnQ6IFN0cmluZyhzZW50KSwgZmFpbGVkOiBTdHJpbmcoZmFpbGVkKSwgdG90YWw6IFN0cmluZyhpbnRlbmRlZCkgfSk7XHJcbiAgICAgICAgfSBjYXRjaCAoXykge31cclxuXHJcbiAgICAgICAgLy8gNCkgRGVjaWRlIGNhbm9uaWNhbCBjYW1wYWlnbiBzdGF0dXNcclxuICAgICAgICBsZXQgbmV3U3RhdHVzID0gY2FtcGFpZ24uc3RhdHVzO1xyXG4gICAgICAgIGlmIChwcm9jZXNzZWQgPj0gaW50ZW5kZWQpIHtcclxuICAgICAgICAgIGlmIChmYWlsZWQgPiAwKSBuZXdTdGF0dXMgPSAnY29tcGxldGVkX3dpdGhfZmFpbHVyZXMnO1xyXG4gICAgICAgICAgZWxzZSBuZXdTdGF0dXMgPSAnY29tcGxldGVkJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbmV3U3RhdHVzID0gJ3J1bm5pbmcnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcGVyc2lzdCBzdGF0dXMgaWYgY2hhbmdlZFxyXG4gICAgICAgIGlmIChuZXdTdGF0dXMgIT09IGNhbXBhaWduLnN0YXR1cykge1xyXG4gICAgICAgICAgYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25zJykudXBkYXRlT25lKHsgX2lkOiBjYW1wYWlnbk9iamVjdElkIH0sIHsgJHNldDogeyBzdGF0dXM6IG5ld1N0YXR1cywgY29tcGxldGVkQXQ6IChuZXdTdGF0dXMuc3RhcnRzV2l0aCgnY29tcGxldGVkJykgPyBuZXcgRGF0ZSgpIDogbnVsbCkgfSB9IGFzIGFueSk7XHJcbiAgICAgICAgICBhd2FpdCBzYWZlSFNldChyZWRpc0tleSwgeyBzdGF0dXM6IG5ld1N0YXR1cyB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGF3YWl0IHNhZmVQdWJsaXNoKCdjYW1wYWlnbjpuZXcnLCB7IGlkLCBhY3Rpb246ICdyZWNvbmNpbGUnLCByZXF1ZXVlZDogZW5xdWV1ZVByb21pc2VzLmxlbmd0aCwgcmVjb3ZlcmVkOiBzdGFsZVNlbmRpbmcubGVuZ3RoLCBzdGF0dXM6IG5ld1N0YXR1cyB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHsgb2s6IHRydWUsIHJlcXVldWVkOiBlbnF1ZXVlUHJvbWlzZXMubGVuZ3RoLCByZWNvdmVyZWQ6IHN0YWxlU2VuZGluZy5sZW5ndGgsIHN0YXR1czogbmV3U3RhdHVzIH0pO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignUmVjb25jaWxlIGZhaWxlZCcsIGUpO1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7IGVycm9yOiAncmVjb25jaWxlLWZhaWxlZCcgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBBQ1RJT046IENhbmNlbFxyXG4gICAgaWYgKGFjdGlvbiA9PT0gJ2NhbmNlbCcpIHtcclxuICAgICAgaWYgKGNhbXBhaWduLnN0YXR1cyA9PT0gJ2NhbmNlbGxlZCcpIHtcclxuICAgICAgICByZXR1cm4gcmVzXHJcbiAgICAgICAgICAuc3RhdHVzKDIwMClcclxuICAgICAgICAgIC5qc29uKHsgb2s6IHRydWUsIG1lc3NhZ2U6ICdBbHJlYWR5IGNhbmNlbGxlZCcgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIDEpIE1hcmsgY2FtcGFpZ24gY2FuY2VsbGVkIGFuZCBjb21wbGV0ZWRBdFxyXG4gICAgICBjb25zdCBjb21wbGV0ZWRBdCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgIGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWducycpLnVwZGF0ZU9uZShcclxuICAgICAgICB7IF9pZDogY2FtcGFpZ25PYmplY3RJZCB9LFxyXG4gICAgICAgIHsgJHNldDogeyBzdGF0dXM6ICdjYW5jZWxsZWQnLCBjb21wbGV0ZWRBdCB9IH1cclxuICAgICAgKTtcclxuICAgICAgYXdhaXQgc2FmZUhTZXQocmVkaXNLZXksIHsgc3RhdHVzOiAnY2FuY2VsbGVkJyB9KTtcclxuXHJcbiAgICAgIC8vIDIpIEZpbmQgYW5kIGF0b21pY2FsbHkgbWFyayBwZW5kaW5nIGxlZGdlciByb3dzIGFzIGZhaWxlZCAoc2luZ2xlIHVwZGF0ZU1hbnkpXHJcbiAgICAgIGNvbnN0IGZpbHRlciA9IHsgY2FtcGFpZ25JZDogY2FtcGFpZ25PYmplY3RJZCwgc3RhdHVzOiAncGVuZGluZycgfTtcclxuICAgICAgY29uc3QgdXBkYXRlID0ge1xyXG4gICAgICAgICRzZXQ6IHtcclxuICAgICAgICAgIHN0YXR1czogJ2ZhaWxlZCcsXHJcbiAgICAgICAgICBsYXN0RXJyb3I6ICdjYW5jZWxsZWQnLFxyXG4gICAgICAgICAgbGFzdEF0dGVtcHRBdDogY29tcGxldGVkQXQsXHJcbiAgICAgICAgfSxcclxuICAgICAgICAkaW5jOiB7IGF0dGVtcHRzOiAxIH0sXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCB1cGRhdGVSZXN1bHQgPSBhd2FpdCBkYlxyXG4gICAgICAgIC5jb2xsZWN0aW9uKCdjYW1wYWlnbl9jb250YWN0cycpXHJcbiAgICAgICAgLnVwZGF0ZU1hbnkoZmlsdGVyLCB1cGRhdGUpO1xyXG5cclxuICAgICAgY29uc3QgY2FuY2VsbGVkQ291bnQgPSB1cGRhdGVSZXN1bHQubW9kaWZpZWRDb3VudCA/PyAwO1xyXG5cclxuICAgICAgLy8gMykgVXBkYXRlIFJlZGlzIGNvdW50ZXJzIChiZXN0LWVmZm9ydClcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAoY2FuY2VsbGVkQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICBhd2FpdCByZWRpcy5oaW5jcmJ5KHJlZGlzS2V5LCAncHJvY2Vzc2VkJywgY2FuY2VsbGVkQ291bnQpO1xyXG4gICAgICAgICAgYXdhaXQgcmVkaXMuaGluY3JieShyZWRpc0tleSwgJ2ZhaWxlZCcsIGNhbmNlbGxlZENvdW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byB1cGRhdGUgcmVkaXMgY291bnRlcnMgZHVyaW5nIGNhbmNlbCcsIGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyA0KSBQZXJzaXN0IHRvdGFscyBzbmFwc2hvdCB0byBjYW1wYWlnbnMudG90YWxzIChyZWFkIHJlZGlzIGlmIGF2YWlsYWJsZSwgZmFsbGJhY2sgdG8gZGIpXHJcbiAgICAgIGxldCBtZXRhID0ge307XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgbWV0YSA9IChhd2FpdCByZWRpcy5oZ2V0YWxsKHJlZGlzS2V5KSkgfHwge307XHJcbiAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgIG1ldGEgPSB7fTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ29tcHV0ZSB0b3RhbHMgZmluYWwgdmFsdWVzIGNvbWJpbmluZyBwZXJzaXN0ZWQgdG90YWxzIGFuZCBvdXIgY2FuY2VsbGVkQ291bnQgYXMgZmFsbGJhY2tcclxuICAgICAgY29uc3QgcHJvY2Vzc2VkTm93ID0gTnVtYmVyKG1ldGFbJ3Byb2Nlc3NlZCddID8/IChjYW1wYWlnbi50b3RhbHM/LnByb2Nlc3NlZCA/PyAwKSArIGNhbmNlbGxlZENvdW50KTtcclxuICAgICAgY29uc3Qgc2VudE5vdyA9IE51bWJlcihtZXRhWydzZW50J10gPz8gKGNhbXBhaWduLnRvdGFscz8uc2VudCA/PyAwKSk7XHJcbiAgICAgIGNvbnN0IGZhaWxlZE5vdyA9IE51bWJlcihtZXRhWydmYWlsZWQnXSA/PyAoY2FtcGFpZ24udG90YWxzPy5mYWlsZWQgPz8gMCkgKyBjYW5jZWxsZWRDb3VudCk7XHJcblxyXG4gICAgICBhd2FpdCBkYi5jb2xsZWN0aW9uKCdjYW1wYWlnbnMnKS51cGRhdGVPbmUoXHJcbiAgICAgICAgeyBfaWQ6IGNhbXBhaWduT2JqZWN0SWQgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAkc2V0OiB7XHJcbiAgICAgICAgICAgICd0b3RhbHMucHJvY2Vzc2VkJzogcHJvY2Vzc2VkTm93LFxyXG4gICAgICAgICAgICAndG90YWxzLnNlbnQnOiBzZW50Tm93LFxyXG4gICAgICAgICAgICAndG90YWxzLmZhaWxlZCc6IGZhaWxlZE5vdyxcclxuICAgICAgICAgICAgY29tcGxldGVkQXQsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH1cclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIDUpIFJlbW92ZSBxdWV1ZWQgam9icyBmb3IgdGhpcyBjYW1wYWlnbiAoYmVzdC1lZmZvcnQpXHJcbiAgICAgIGNvbnN0IHJlbW92ZWRKb2JzID0gYXdhaXQgcmVtb3ZlUXVldWVkSm9ic0ZvckNhbXBhaWduKGlkKTtcclxuXHJcbiAgICAgIC8vIDYpIFB1Ymxpc2ggZXZlbnRcclxuICAgICAgYXdhaXQgc2FmZVB1Ymxpc2goJ2NhbXBhaWduOm5ldycsIHsgaWQsIHN0YXR1czogJ2NhbmNlbGxlZCcsIGNhbmNlbGxlZENvdW50LCByZW1vdmVkSm9icyB9KTtcclxuXHJcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7XHJcbiAgICAgICAgb2s6IHRydWUsXHJcbiAgICAgICAgYWN0aW9uOiAnY2FuY2VsbGVkJyxcclxuICAgICAgICBjYW5jZWxsZWRDb3VudCxcclxuICAgICAgICByZW1vdmVkSm9icyxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQUNUSU9OOiBEZWxldGVcclxuICAgIGlmIChhY3Rpb24gPT09ICdkZWxldGUnKSB7XHJcbiAgICAgIC8vIFJlcXVpcmUgZXhwbGljaXQgY29uZmlybWF0aW9uIOKAlCBzYWZlZ3VhcmRzIGluIFVJIG11c3Qgc2V0IGNvbmZpcm09dHJ1ZVxyXG4gICAgICBpZiAoY29uZmlybSAhPT0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybiByZXNcclxuICAgICAgICAgIC5zdGF0dXMoNDAwKVxyXG4gICAgICAgICAgLmpzb24oeyBlcnJvcjogJ0RlbGV0aW9uIHJlcXVpcmVzIGNvbmZpcm09dHJ1ZSBpbiByZXF1ZXN0IGJvZHknIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBQcmV2ZW50IGFjY2lkZW50YWwgZGVsZXRpb24gd2hpbGUgcnVubmluZ1xyXG4gICAgICBpZiAoY2FtcGFpZ24uc3RhdHVzID09PSAncnVubmluZycpIHtcclxuICAgICAgICByZXR1cm4gcmVzXHJcbiAgICAgICAgICAuc3RhdHVzKDQwMClcclxuICAgICAgICAgIC5qc29uKHsgZXJyb3I6ICdDYW5jZWwgdGhlIGNhbXBhaWduIGJlZm9yZSBkZWxldGlvbicgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbW92ZSBxdWV1ZWQgam9icyAoYmVzdC1lZmZvcnQpXHJcbiAgICAgIGNvbnN0IHJlbW92ZWRKb2JzID0gYXdhaXQgcmVtb3ZlUXVldWVkSm9ic0ZvckNhbXBhaWduKGlkKTtcclxuXHJcbiAgICAgIC8vIERlbGV0ZSBSZWRpcyBrZXlzIChiZXN0LWVmZm9ydClcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCByZWRpcy5kZWwoYGNhbXBhaWduOiR7aWR9Om1ldGFgKTtcclxuICAgICAgICBhd2FpdCByZWRpcy5kZWwoYGNhbXBhaWduOiR7aWR9OmRlZmluaXRpb25gKTtcclxuICAgICAgICBhd2FpdCByZWRpcy5zcmVtKCdjYW1wYWlnbjphbGwnLCBpZCk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ1JlZGlzIGNsZWFudXAgb24gZGVsZXRlIGZhaWxlZCcsIGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEZWxldGUgTW9uZ28gZG9jc1xyXG4gICAgICBjb25zdCBbY2FtcGFpZ25EZWwsIGxlZGdlckRlbF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgZGIuY29sbGVjdGlvbignY2FtcGFpZ25zJykuZGVsZXRlT25lKHsgX2lkOiBjYW1wYWlnbk9iamVjdElkIH0pLFxyXG4gICAgICAgIGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWduX2NvbnRhY3RzJykuZGVsZXRlTWFueSh7IGNhbXBhaWduSWQ6IGNhbXBhaWduT2JqZWN0SWQgfSksXHJcbiAgICAgIF0pO1xyXG5cclxuICAgICAgYXdhaXQgc2FmZVB1Ymxpc2goJ2NhbXBhaWduOm5ldycsIHsgaWQsIHN0YXR1czogJ2RlbGV0ZWQnIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHtcclxuICAgICAgICBvazogdHJ1ZSxcclxuICAgICAgICBhY3Rpb246ICdkZWxldGVkJyxcclxuICAgICAgICBjYW1wYWlnbkRlbGV0ZWQ6IGNhbXBhaWduRGVsLmRlbGV0ZWRDb3VudCA/PyAwLFxyXG4gICAgICAgIGxlZGdlckRlbGV0ZWQ6IGxlZGdlckRlbC5kZWxldGVkQ291bnQgPz8gMCxcclxuICAgICAgICByZW1vdmVkSm9icyxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQUNUSU9OOiBSZXRyeSBhbGwgZmFpbGVkIGNvbnRhY3RzIHRoYXQgYXJlIGJlbG93IE1BWF9BVFRFTVBUU1xyXG4gICAgaWYgKGFjdGlvbiA9PT0gJ3JldHJ5RmFpbGVkJykge1xyXG4gICAgICAvLyBEaXNhbGxvdyByZXRyeWluZyBpZiBjYW1wYWlnbiBpcyBjYW5jZWxsZWQvZGVsZXRlZC9wYXVzZWRcclxuICAgICAgaWYgKGNhbXBhaWduLnN0YXR1cyA9PT0gJ2NhbmNlbGxlZCcgfHwgY2FtcGFpZ24uc3RhdHVzID09PSAnZGVsZXRlZCcgfHwgY2FtcGFpZ24uc3RhdHVzID09PSAncGF1c2VkJykge1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IGVycm9yOiAnQ2Fubm90IHJldHJ5IGNvbnRhY3RzIGZvciBjYW5jZWxsZWQvZGVsZXRlZC9wYXVzZWQgY2FtcGFpZ24nIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBFbnN1cmUgYSBSZWRpcyBjYW1wYWlnbiBkZWZpbml0aW9uIGV4aXN0cyAod29ya2VyIHJlcXVpcmVzIGl0KVxyXG4gICAgICBjb25zdCBoYXNEZWYgPSBhd2FpdCBlbnN1cmVDYW1wYWlnbkRlZmluaXRpb24oaWQsIGNhbXBhaWduKTtcclxuICAgICAgaWYgKCFoYXNEZWYpIHtcclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg1MDApLmpzb24oeyBlcnJvcjogJ01pc3NpbmcgY2FtcGFpZ24gZGVmaW5pdGlvbiBpbiBSZWRpcyBhbmQgdW5hYmxlIHRvIGNvbnN0cnVjdCBvbmUgZnJvbSBjYW1wYWlnbiBkb2N1bWVudC4gUmV0cnkgY2Fubm90IHByb2NlZWQuJyB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZmluZCBmYWlsZWQgY29udGFjdHMgd2l0aCBhdHRlbXB0cyA8IE1BWF9BVFRFTVBUUyBBTkQgd2hlcmUgYmdBdHRlbXB0cyA+PSBNQVhfQVRURU1QVFMgKG1lYW5pbmcgYmFja2dyb3VuZCBjeWNsZSBmaW5pc2hlZClcclxuICAgICAgLy8gSWYgYmdBdHRlbXB0cyBpcyBtaXNzaW5nICh1bmRlZmluZWQvbnVsbCksIHRyZWF0IGl0IGFzIGZpbmlzaGVkIChjb25zZXJ2YXRpdmUpLiBCdXQgcHJlZmVyIGV4cGxpY2l0ID49LlxyXG4gICAgICBjb25zdCBmaWx0ZXI6IGFueSA9IHtcclxuICAgICAgICBjYW1wYWlnbklkOiBjYW1wYWlnbk9iamVjdElkLFxyXG4gICAgICAgIHN0YXR1czogJ2ZhaWxlZCcsXHJcbiAgICAgICAgYXR0ZW1wdHM6IHsgJGx0OiBNQVhfQVRURU1QVFMgfSxcclxuICAgICAgICAkb3I6IFtcclxuICAgICAgICAgIHsgYmdBdHRlbXB0czogeyAkZXhpc3RzOiBmYWxzZSB9IH0sXHJcbiAgICAgICAgICB7IGJnQXR0ZW1wdHM6IHsgJGd0ZTogTUFYX0FUVEVNUFRTIH0gfSxcclxuICAgICAgICBdLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgY29uc3QgZmFpbGVkRG9jcyA9IGF3YWl0IGRiXHJcbiAgICAgICAgLmNvbGxlY3Rpb24oJ2NhbXBhaWduX2NvbnRhY3RzJylcclxuICAgICAgICAuZmluZChmaWx0ZXIsIHsgcHJvamVjdGlvbjogeyBfaWQ6IDEsIGNvbnRhY3RJZDogMSwgc3RlcDogMSB9IH0pXHJcbiAgICAgICAgLnRvQXJyYXkoKTtcclxuXHJcbiAgICAgIGNvbnN0IHRvUmV0cnlDb3VudCA9IGZhaWxlZERvY3MubGVuZ3RoO1xyXG4gICAgICBpZiAodG9SZXRyeUNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHsgb2s6IHRydWUsIHJldHJpZWQ6IDAsIG1lc3NhZ2U6ICdObyBlbGlnaWJsZSBmYWlsZWQgY29udGFjdHMgdG8gcmV0cnkgKGVpdGhlciBub25lIGZhaWxlZCwgcmVhY2hlZCBtYXggYXR0ZW1wdHMsIG9yIGJhY2tncm91bmQgcmV0cmllcyBzdGlsbCBpbiBwcm9ncmVzcykuJyB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gc2VydmVyLXNpZGUgY2FwIGVuZm9yY2VtZW50XHJcbiAgICAgIGlmICh0b1JldHJ5Q291bnQgPiBCQVRDSF9SRVRSWV9MSU1JVCkge1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7XHJcbiAgICAgICAgICBlcnJvcjogJ0JhdGNoIHJldHJ5IGV4Y2VlZHMgc2VydmVyIGxpbWl0JyxcclxuICAgICAgICAgIG1lc3NhZ2U6IGBUcnlpbmcgdG8gcmV0cnkgJHt0b1JldHJ5Q291bnR9IGNvbnRhY3RzIGV4Y2VlZHMgc2VydmVyIGNhcCBvZiAke0JBVENIX1JFVFJZX0xJTUlUfS4gVXNlIHBhZ2luYXRpb24gdG8gcmV0cnkgaW4gc21hbGxlciBiYXRjaGVzLmAsXHJcbiAgICAgICAgICB0b1JldHJ5Q291bnQsXHJcbiAgICAgICAgICBsaW1pdDogQkFUQ0hfUkVUUllfTElNSVQsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEF0b21pY2FsbHkgbWFyayB0aGVtIHBlbmRpbmcgYW5kIGluY3JlbWVudCBjb3JlIGBhdHRlbXB0c2AgYW5kIHJlc2V0IGJnQXR0ZW1wdHNcclxuICAgICAgY29uc3QgaWRzID0gZmFpbGVkRG9jcy5tYXAoZCA9PiBkLl9pZCk7XHJcbiAgICAgIGNvbnN0IHVwZGF0ZVJlc3VsdCA9IGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWduX2NvbnRhY3RzJykudXBkYXRlTWFueShcclxuICAgICAgICB7IF9pZDogeyAkaW46IGlkcyB9IH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgJHNldDogeyBzdGF0dXM6ICdwZW5kaW5nJywgbGFzdEVycm9yOiBudWxsLCBiZ0F0dGVtcHRzOiAwIH0sXHJcbiAgICAgICAgICAkaW5jOiB7IGF0dGVtcHRzOiAxIH0sXHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc3QgdXBkYXRlZCA9IHVwZGF0ZVJlc3VsdC5tb2RpZmllZENvdW50ID8/IDA7XHJcblxyXG4gICAgICAvLyBFbnF1ZXVlIGpvYnMgKGJhdGNoKSwgZW5zdXJlIGVhY2ggam9iIGhhcyBNUSBhdHRlbXB0cy9iYWNrb2ZmIHNldFxyXG4gICAgICBjb25zdCBqb2JzOiBQcm9taXNlPGFueT5bXSA9IFtdO1xyXG4gICAgICBjb25zdCBDSFVOSyA9IDIwMDsgLy8gcmVhc29uYWJsZSBjaHVua2luZ1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZhaWxlZERvY3MubGVuZ3RoOyBpICs9IENIVU5LKSB7XHJcbiAgICAgICAgY29uc3QgY2h1bmsgPSBmYWlsZWREb2NzLnNsaWNlKGksIGkgKyBDSFVOSyk7XHJcbiAgICAgICAgZm9yIChjb25zdCBkb2Mgb2YgY2h1bmspIHtcclxuICAgICAgICAgIGNvbnN0IGNvbnRhY3RPYmpJZCA9IGRvYy5jb250YWN0SWQgPyBkb2MuY29udGFjdElkIDogZG9jLl9pZDtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChkb2Muc3RlcCkge1xyXG4gICAgICAgICAgICAgIGpvYnMucHVzaChcclxuICAgICAgICAgICAgICAgIHF1ZXVlLmFkZChcclxuICAgICAgICAgICAgICAgICAgJ2ZvbGxvd3VwJyxcclxuICAgICAgICAgICAgICAgICAgeyBjYW1wYWlnbklkOiBpZCwgY29udGFjdElkOiBjb250YWN0T2JqSWQudG9TdHJpbmcgPyBjb250YWN0T2JqSWQudG9TdHJpbmcoKSA6IFN0cmluZyhjb250YWN0T2JqSWQpLCBzdGVwOiBkb2Muc3RlcCB9LFxyXG4gICAgICAgICAgICAgICAgICB7IHJlbW92ZU9uQ29tcGxldGU6IHRydWUsIHJlbW92ZU9uRmFpbDogdHJ1ZSwgYXR0ZW1wdHM6IE1BWF9BVFRFTVBUUywgYmFja29mZjogeyB0eXBlOiAnZXhwb25lbnRpYWwnLCBkZWxheTogNjBfMDAwIH0gfVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgam9icy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgcXVldWUuYWRkKFxyXG4gICAgICAgICAgICAgICAgICAnaW5pdGlhbCcsXHJcbiAgICAgICAgICAgICAgICAgIHsgY2FtcGFpZ25JZDogaWQsIGNvbnRhY3RJZDogY29udGFjdE9iaklkLnRvU3RyaW5nID8gY29udGFjdE9iaklkLnRvU3RyaW5nKCkgOiBTdHJpbmcoY29udGFjdE9iaklkKSB9LFxyXG4gICAgICAgICAgICAgICAgICB7IHJlbW92ZU9uQ29tcGxldGU6IHRydWUsIHJlbW92ZU9uRmFpbDogdHJ1ZSwgYXR0ZW1wdHM6IE1BWF9BVFRFTVBUUywgYmFja29mZjogeyB0eXBlOiAnZXhwb25lbnRpYWwnLCBkZWxheTogNjBfMDAwIH0gfVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcXVldWUgam9iIGZvciByZXRyeUZhaWxlZCBjaHVuayBpdGVtJywgZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBXYWl0IGZvciBlbnF1ZXVlcyAoYmVzdC1lZmZvcnQpXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoam9icyk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ1NvbWUgcXVldWUuYWRkIGNhbGxzIGZhaWxlZCBkdXJpbmcgcmV0cnlGYWlsZWQnLCBlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVXBkYXRlIHJlZGlzIGNvdW50ZXJzOiBkZWNyZWFzZSBmYWlsZWQgYnkgdXBkYXRlZCAoYmVzdC1lZmZvcnQsIGJ1dCBhdm9pZCBuZWdhdGl2ZSlcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBjdXJyZW50RmFpbGVkID0gYXdhaXQgc2FmZUdldE1ldGFJbnQocmVkaXNLZXksICdmYWlsZWQnKTtcclxuICAgICAgICBjb25zdCBkZWMgPSBNYXRoLm1pbih1cGRhdGVkLCBjdXJyZW50RmFpbGVkKTtcclxuICAgICAgICBpZiAoZGVjID4gMCkge1xyXG4gICAgICAgICAgYXdhaXQgcmVkaXMuaGluY3JieShyZWRpc0tleSwgJ2ZhaWxlZCcsIC1kZWMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHVwZGF0ZSByZWRpcyBjb3VudGVycyBkdXJpbmcgcmV0cnlGYWlsZWQnLCBlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWxzbyBjb3JyZWN0IHByb2Nlc3NlZCBjb3VudGVyIGJlY2F1c2Ugd2UgYXJlIG1vdmluZyBmaW5hbCBmYWlsZWQgLT4gcGVuZGluZyAocHJvY2Vzc2VkIHNob3VsZCBkcm9wKVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRQcm9jZXNzZWQgPSBhd2FpdCBzYWZlR2V0TWV0YUludChyZWRpc0tleSwgJ3Byb2Nlc3NlZCcpO1xyXG4gICAgICAgIGNvbnN0IGRlY1Byb2MgPSBNYXRoLm1pbih1cGRhdGVkLCBjdXJyZW50UHJvY2Vzc2VkKTtcclxuICAgICAgICBpZiAoZGVjUHJvYyA+IDApIHtcclxuICAgICAgICAgIGF3YWl0IHJlZGlzLmhpbmNyYnkocmVkaXNLZXksICdwcm9jZXNzZWQnLCAtZGVjUHJvYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gdXBkYXRlIHByb2Nlc3NlZCBjb3VudGVyIGR1cmluZyByZXRyeUZhaWxlZCcsIGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBQdWJsaXNoIGNvbnRhY3QtbGV2ZWwgdXBkYXRlcyBmb3IgZWFjaCByZXRyaWVkIGNvbnRhY3QgKGJlc3QtZWZmb3J0KVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZG9jIG9mIGZhaWxlZERvY3MpIHtcclxuICAgICAgICAgIGNvbnN0IGNpZCA9IGRvYy5jb250YWN0SWQgPyAoZG9jLmNvbnRhY3RJZC50b1N0cmluZyA/IGRvYy5jb250YWN0SWQudG9TdHJpbmcoKSA6IFN0cmluZyhkb2MuY29udGFjdElkKSkgOiAoZG9jLl9pZC50b1N0cmluZyA/IGRvYy5faWQudG9TdHJpbmcoKSA6IFN0cmluZyhkb2MuX2lkKSk7XHJcbiAgICAgICAgICBhd2FpdCBzYWZlUHVibGlzaChgY2FtcGFpZ246JHtpZH06Y29udGFjdF91cGRhdGVgLCB7IGNvbnRhY3RJZDogY2lkLCBzdGF0dXM6ICdwZW5kaW5nJywgYmdBdHRlbXB0czogMCwgYXR0ZW1wdHM6IDEgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChfKSB7XHJcbiAgICAgICAgLy8gaWdub3JlIHB1Ymxpc2ggZXJyb3JzXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGF3YWl0IHNhZmVQdWJsaXNoKCdjYW1wYWlnbjpuZXcnLCB7IGlkLCBhY3Rpb246ICdyZXRyeUZhaWxlZCcsIHJldHJpZWQ6IHVwZGF0ZWQgfSk7XHJcblxyXG4gICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oeyBvazogdHJ1ZSwgcmV0cmllZDogdXBkYXRlZCwgYXR0ZW1wdGVkRW5xdWV1ZTogdG9SZXRyeUNvdW50IH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFDVElPTjogUmV0cnkgYSBzaW5nbGUgZmFpbGVkIGNvbnRhY3QgYnkgY29udGFjdElkXHJcbiAgICBpZiAoYWN0aW9uID09PSAncmV0cnlDb250YWN0Jykge1xyXG4gICAgICBpZiAoIWNvbnRhY3RJZCB8fCB0eXBlb2YgY29udGFjdElkICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IGVycm9yOiAnTWlzc2luZyBjb250YWN0SWQgZm9yIHJldHJ5Q29udGFjdCcgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERpc2FsbG93IHJldHJ5aW5nIGlmIGNhbXBhaWduIGlzIGNhbmNlbGxlZC9kZWxldGVkL3BhdXNlZFxyXG4gICAgICBpZiAoY2FtcGFpZ24uc3RhdHVzID09PSAnY2FuY2VsbGVkJyB8fCBjYW1wYWlnbi5zdGF0dXMgPT09ICdkZWxldGVkJyB8fCBjYW1wYWlnbi5zdGF0dXMgPT09ICdwYXVzZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgZXJyb3I6ICdDYW5ub3QgcmV0cnkgY29udGFjdHMgZm9yIGNhbmNlbGxlZC9kZWxldGVkL3BhdXNlZCBjYW1wYWlnbicgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEVuc3VyZSBhIFJlZGlzIGNhbXBhaWduIGRlZmluaXRpb24gZXhpc3RzICh3b3JrZXIgcmVxdWlyZXMgaXQpXHJcbiAgICAgIGNvbnN0IGhhc0RlZiA9IGF3YWl0IGVuc3VyZUNhbXBhaWduRGVmaW5pdGlvbihpZCwgY2FtcGFpZ24pO1xyXG4gICAgICBpZiAoIWhhc0RlZikge1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7IGVycm9yOiAnTWlzc2luZyBjYW1wYWlnbiBkZWZpbml0aW9uIGluIFJlZGlzIGFuZCB1bmFibGUgdG8gY29uc3RydWN0IG9uZSBmcm9tIGNhbXBhaWduIGRvY3VtZW50LiBSZXRyeSBjYW5ub3QgcHJvY2VlZC4nIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBGaW5kIHRoZSBsZWRnZXIgcm93XHJcbiAgICAgIGxldCBjb250YWN0T2JqSWQ7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gdHJ5IHBhcnNlIGFzIE9iamVjdElkIGZpcnN0XHJcbiAgICAgICAgY29udGFjdE9iaklkID0gbmV3IE9iamVjdElkKGNvbnRhY3RJZCk7XHJcbiAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgIC8vIGZhbGxiYWNrOiB1c2UgcmF3IHN0cmluZ1xyXG4gICAgICAgIGNvbnRhY3RPYmpJZCA9IGNvbnRhY3RJZDtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZG9jID0gYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25fY29udGFjdHMnKS5maW5kT25lKHtcclxuICAgICAgICBjYW1wYWlnbklkOiBjYW1wYWlnbk9iamVjdElkLFxyXG4gICAgICAgIGNvbnRhY3RJZDogY29udGFjdE9iaklkLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmICghZG9jKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA0KS5qc29uKHsgZXJyb3I6ICdDb250YWN0IGxlZGdlciByb3cgbm90IGZvdW5kIGZvciBjYW1wYWlnbicgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChkb2Muc3RhdHVzICE9PSAnZmFpbGVkJykge1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IGVycm9yOiAnQ29udGFjdCBpcyBub3QgaW4gZmFpbGVkIHN0YXRlJyB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKChkb2MuYXR0ZW1wdHMgfHwgMCkgPj0gTUFYX0FUVEVNUFRTKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgZXJyb3I6ICdDb250YWN0IGhhcyByZWFjaGVkIG1heCBtYW51YWwgYXR0ZW1wdHMgYW5kIGNhbm5vdCBiZSByZXRyaWVkJyB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUHJldmVudCBtYW51YWwgcmV0cnkgd2hpbGUgQnVsbE1RIGJhY2tncm91bmQgcmV0cmllcyBhcmUgc3RpbGwgcnVubmluZyBmb3IgdGhpcyBjb250YWN0XHJcbiAgICAgIC8vIFJlcXVpcmUgYmdBdHRlbXB0cyA+PSBNQVhfQVRURU1QVFMgKG9yIG1pc3NpbmcpIGJlZm9yZSBhbGxvd2luZyBtYW51YWwgcmV0cnlcclxuICAgICAgY29uc3QgYmdEb25lID0gKHR5cGVvZiBkb2MuYmdBdHRlbXB0cyA9PT0gJ251bWJlcicgPyBkb2MuYmdBdHRlbXB0cyA+PSBNQVhfQVRURU1QVFMgOiB0cnVlKTtcclxuICAgICAgaWYgKCFiZ0RvbmUpIHtcclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBlcnJvcjogJ0JhY2tncm91bmQgcmV0cmllcyBhcmUgc3RpbGwgaW4gcHJvZ3Jlc3MgZm9yIHRoaXMgY29udGFjdC4gUGxlYXNlIHdhaXQgdW50aWwgdGhlIGJhY2tncm91bmQgcmV0cnkgY3ljbGUgY29tcGxldGVzLicgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBzaW5nbGUgZG9jIHRvIHBlbmRpbmcsIGluY3JlbWVudCBjb3JlIGF0dGVtcHRzLCByZXNldCBiZ0F0dGVtcHRzXHJcbiAgICAgIGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWduX2NvbnRhY3RzJykudXBkYXRlT25lKFxyXG4gICAgICAgIHsgX2lkOiBkb2MuX2lkIH0sXHJcbiAgICAgICAgeyAkc2V0OiB7IHN0YXR1czogJ3BlbmRpbmcnLCBsYXN0RXJyb3I6IG51bGwsIGJnQXR0ZW1wdHM6IDAgfSwgJGluYzogeyBhdHRlbXB0czogMSB9IH1cclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIEVucXVldWUgYXBwcm9wcmlhdGUgam9iICh1c2UgZG9jLnN0ZXAgaWYgcHJlc2VudCkgYW5kIGVuc3VyZSBNUSBhdHRlbXB0cy9iYWNrb2ZmIGFyZSBzZXRcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAoZG9jLnN0ZXApIHtcclxuICAgICAgICAgIGF3YWl0IHF1ZXVlLmFkZChcclxuICAgICAgICAgICAgJ2ZvbGxvd3VwJyxcclxuICAgICAgICAgICAgeyBjYW1wYWlnbklkOiBpZCwgY29udGFjdElkOiBjb250YWN0T2JqSWQudG9TdHJpbmcgPyBjb250YWN0T2JqSWQudG9TdHJpbmcoKSA6IFN0cmluZyhjb250YWN0T2JqSWQpLCBzdGVwOiBkb2Muc3RlcCB9LFxyXG4gICAgICAgICAgICB7IHJlbW92ZU9uQ29tcGxldGU6IHRydWUsIHJlbW92ZU9uRmFpbDogdHJ1ZSwgYXR0ZW1wdHM6IE1BWF9BVFRFTVBUUywgYmFja29mZjogeyB0eXBlOiAnZXhwb25lbnRpYWwnLCBkZWxheTogNjBfMDAwIH0gfVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYXdhaXQgcXVldWUuYWRkKFxyXG4gICAgICAgICAgICAnaW5pdGlhbCcsXHJcbiAgICAgICAgICAgIHsgY2FtcGFpZ25JZDogaWQsIGNvbnRhY3RJZDogY29udGFjdE9iaklkLnRvU3RyaW5nID8gY29udGFjdE9iaklkLnRvU3RyaW5nKCkgOiBTdHJpbmcoY29udGFjdE9iaklkKSB9LFxyXG4gICAgICAgICAgICB7IHJlbW92ZU9uQ29tcGxldGU6IHRydWUsIHJlbW92ZU9uRmFpbDogdHJ1ZSwgYXR0ZW1wdHM6IE1BWF9BVFRFTVBUUywgYmFja29mZjogeyB0eXBlOiAnZXhwb25lbnRpYWwnLCBkZWxheTogNjBfMDAwIH0gfVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBlbnF1ZXVlIHJldHJ5IGpvYiBmb3IgY29udGFjdCcsIGUpO1xyXG4gICAgICAgIC8vIFJvbGxiYWNrOiB0cnkgdG8gcmV2ZXJ0IHRoZSBsZWRnZXIgcm93IGNoYW5nZXMgKGJlc3QtZWZmb3J0KVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBhd2FpdCBkYi5jb2xsZWN0aW9uKCdjYW1wYWlnbl9jb250YWN0cycpLnVwZGF0ZU9uZShcclxuICAgICAgICAgICAgeyBfaWQ6IGRvYy5faWQgfSxcclxuICAgICAgICAgICAgeyAkc2V0OiB7IHN0YXR1czogJ2ZhaWxlZCcsIGxhc3RFcnJvcjogJ2VucXVldWUtZmFpbGVkJyB9LCAkaW5jOiB7IGF0dGVtcHRzOiAtMSB9LCAkc2V0OiB7IGJnQXR0ZW1wdHM6IGRvYy5iZ0F0dGVtcHRzID8/IDAgfSB9IGFzIGFueVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9IGNhdGNoIChfKSB7fVxyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7IGVycm9yOiAnRmFpbGVkIHRvIGVucXVldWUgcmV0cnkgam9iJyB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVXBkYXRlIHJlZGlzIGNvdW50ZXJzOiBkZWNyZWFzZSBmYWlsZWQgYnkgMSBpZiBwb3NzaWJsZSAod2UgbW92ZWQgaXQgZnJvbSBmYWlsZWQgLT4gcGVuZGluZylcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBjdXJyZW50RmFpbGVkID0gYXdhaXQgc2FmZUdldE1ldGFJbnQocmVkaXNLZXksICdmYWlsZWQnKTtcclxuICAgICAgICBpZiAoY3VycmVudEZhaWxlZCA+IDApIHtcclxuICAgICAgICAgIGF3YWl0IHJlZGlzLmhpbmNyYnkocmVkaXNLZXksICdmYWlsZWQnLCAtMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gdXBkYXRlIHJlZGlzIGNvdW50ZXJzIGR1cmluZyByZXRyeUNvbnRhY3QnLCBlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWxzbyBkZWNyZW1lbnQgcHJvY2Vzc2VkIHNvIHRvdGFscyBhbGlnbiAod2UgYXJlIHVuLWZpbmFsaXppbmcgYSBjb250YWN0KVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRQcm9jZXNzZWQgPSBhd2FpdCBzYWZlR2V0TWV0YUludChyZWRpc0tleSwgJ3Byb2Nlc3NlZCcpO1xyXG4gICAgICAgIGlmIChjdXJyZW50UHJvY2Vzc2VkID4gMCkge1xyXG4gICAgICAgICAgYXdhaXQgcmVkaXMuaGluY3JieShyZWRpc0tleSwgJ3Byb2Nlc3NlZCcsIC0xKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byB1cGRhdGUgcHJvY2Vzc2VkIGNvdW50ZXIgZHVyaW5nIHJldHJ5Q29udGFjdCcsIGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBQdWJsaXNoIGNvbnRhY3QgdXBkYXRlXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgY2lkU3RyID0gY29udGFjdE9iaklkLnRvU3RyaW5nID8gY29udGFjdE9iaklkLnRvU3RyaW5nKCkgOiBTdHJpbmcoY29udGFjdE9iaklkKTtcclxuICAgICAgICBhd2FpdCBzYWZlUHVibGlzaChgY2FtcGFpZ246JHtpZH06Y29udGFjdF91cGRhdGVgLCB7IGNvbnRhY3RJZDogY2lkU3RyLCBzdGF0dXM6ICdwZW5kaW5nJywgYXR0ZW1wdHM6IChkb2MuYXR0ZW1wdHMgfHwgMCkgKyAxLCBiZ0F0dGVtcHRzOiAwIH0pO1xyXG4gICAgICB9IGNhdGNoIChfKSB7fVxyXG5cclxuICAgICAgYXdhaXQgc2FmZVB1Ymxpc2goJ2NhbXBhaWduOm5ldycsIHsgaWQsIGFjdGlvbjogJ3JldHJ5Q29udGFjdCcsIGNvbnRhY3RJZCB9KTtcclxuXHJcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7IG9rOiB0cnVlLCByZXRyaWVkOiAxLCBjb250YWN0SWQgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2hvdWxkIG5vdCByZWFjaCBoZXJlXHJcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBlcnJvcjogJ1Vuc3VwcG9ydGVkIGFjdGlvbicgfSk7XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdDYW1wYWlnbiBjb250cm9sIGVycm9yJywgZXJyKTtcclxuICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7IGVycm9yOiAnSW50ZXJuYWwgc2VydmVyIGVycm9yJyB9KTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbImNsaWVudFByb21pc2UiLCJyZWRpcyIsIlF1ZXVlIiwiT2JqZWN0SWQiLCJxdWV1ZSIsImNvbm5lY3Rpb24iLCJNQVhfQVRURU1QVFMiLCJOdW1iZXIiLCJwcm9jZXNzIiwiZW52IiwiQkFUQ0hfUkVUUllfTElNSVQiLCJSRVNVTUVfRU5RVUVVRV9MSU1JVCIsIlNUQUxFX1NFTkRJTkdfTVMiLCJzYWZlSFNldCIsImtleSIsIm9iaiIsImhzZXQiLCJlcnIiLCJjb25zb2xlIiwid2FybiIsInNhZmVQdWJsaXNoIiwiY2hhbm5lbCIsInBheWxvYWQiLCJwdWJsaXNoIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlbW92ZVF1ZXVlZEpvYnNGb3JDYW1wYWlnbiIsImNhbXBhaWduSWQiLCJqb2JzIiwiZ2V0Sm9icyIsIm1hdGNoZWQiLCJmaWx0ZXIiLCJqIiwiZGF0YSIsInJlbW92ZSIsImUiLCJpZCIsImxlbmd0aCIsInNhZmVHZXRNZXRhSW50IiwicmVkaXNLZXkiLCJmaWVsZCIsInYiLCJoZ2V0IiwiZW5zdXJlQ2FtcGFpZ25EZWZpbml0aW9uIiwiY2FtcGFpZ25Eb2MiLCJleGlzdGluZyIsImdldCIsImJ1aWx0IiwiZGVmaW5pdGlvbiIsImluaXRpYWwiLCJmb2xsb3dVcHMiLCJ0ZW1wbGF0ZSIsInN1YmplY3QiLCJuYW1lIiwiYm9keSIsImNvbnRlbnQiLCJ0aXRsZSIsImh0bWwiLCJzdGVwcyIsInNhbXBsZSIsIk9iamVjdCIsImtleXMiLCJzbGljZSIsInNldCIsImxvZyIsImdldFF1ZXVlZENvbnRhY3RJZHNGb3JDYW1wYWlnbiIsIlNldCIsImNvbnRhY3RJZCIsImFkZCIsIlN0cmluZyIsImhhbmRsZXIiLCJyZXEiLCJyZXMiLCJtZXRob2QiLCJzdGF0dXMiLCJqc29uIiwiZXJyb3IiLCJxdWVyeSIsImFjdGlvbiIsImNvbmZpcm0iLCJpbmNsdWRlcyIsImNsaWVudCIsImRiIiwiY2FtcGFpZ25PYmplY3RJZCIsImNhbXBhaWduIiwiY29sbGVjdGlvbiIsImZpbmRPbmUiLCJfaWQiLCJvayIsIm1lc3NhZ2UiLCJ1cGRhdGVPbmUiLCIkc2V0IiwicXVldWVkU2V0IiwicGVuZGluZ0N1cnNvciIsImZpbmQiLCJwcm9qZWN0aW9uIiwic3RlcCIsImxpbWl0IiwicGVuZGluZyIsInRvQXJyYXkiLCJlbnF1ZXVlUHJvbWlzZXMiLCJkIiwiY2lkIiwidG9TdHJpbmciLCJoYXMiLCJwdXNoIiwicmVtb3ZlT25Db21wbGV0ZSIsInJlbW92ZU9uRmFpbCIsImF0dGVtcHRzIiwiYmFja29mZiIsInR5cGUiLCJkZWxheSIsIlByb21pc2UiLCJhbGxTZXR0bGVkIiwicmVxdWV1ZWQiLCJjdXRvZmYiLCJEYXRlIiwibm93Iiwic3RhbGVDdXJzb3IiLCJsYXN0QXR0ZW1wdEF0IiwiJGx0IiwiYmdBdHRlbXB0cyIsInN0YWxlRG9jcyIsImlkcyIsIm1hcCIsInVwZGF0ZU1hbnkiLCIkaW4iLCJsYXN0RXJyb3IiLCJxdWV1ZWRTZXQyIiwicmVxdWV1ZVByb21pc2VzIiwidW5kZWZpbmVkIiwiXyIsInJlY292ZXJlZCIsInN0YWxlU2VuZGluZyIsInByb2plY3QiLCJwZW5kaW5nUm93cyIsImFnZyIsImFnZ3JlZ2F0ZSIsIiRtYXRjaCIsIiRncm91cCIsImNvdW50IiwiJHN1bSIsInNlbnQiLCJmYWlsZWQiLCJyIiwicHJvY2Vzc2VkIiwiaW50ZW5kZWQiLCJ0b3RhbHMiLCJjb3VudERvY3VtZW50cyIsInRvdGFsIiwibmV3U3RhdHVzIiwiY29tcGxldGVkQXQiLCJzdGFydHNXaXRoIiwidXBkYXRlIiwiJGluYyIsInVwZGF0ZVJlc3VsdCIsImNhbmNlbGxlZENvdW50IiwibW9kaWZpZWRDb3VudCIsImhpbmNyYnkiLCJtZXRhIiwiaGdldGFsbCIsInByb2Nlc3NlZE5vdyIsInNlbnROb3ciLCJmYWlsZWROb3ciLCJyZW1vdmVkSm9icyIsImRlbCIsInNyZW0iLCJjYW1wYWlnbkRlbCIsImxlZGdlckRlbCIsImFsbCIsImRlbGV0ZU9uZSIsImRlbGV0ZU1hbnkiLCJjYW1wYWlnbkRlbGV0ZWQiLCJkZWxldGVkQ291bnQiLCJsZWRnZXJEZWxldGVkIiwiaGFzRGVmIiwiJG9yIiwiJGV4aXN0cyIsIiRndGUiLCJmYWlsZWREb2NzIiwidG9SZXRyeUNvdW50IiwicmV0cmllZCIsInVwZGF0ZWQiLCJDSFVOSyIsImkiLCJjaHVuayIsImRvYyIsImNvbnRhY3RPYmpJZCIsImN1cnJlbnRGYWlsZWQiLCJkZWMiLCJNYXRoIiwibWluIiwiY3VycmVudFByb2Nlc3NlZCIsImRlY1Byb2MiLCJhdHRlbXB0ZWRFbnF1ZXVlIiwiYmdEb25lIiwiY2lkU3RyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./pages/api/campaign/[id]/control.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fcampaign%2F%5Bid%5D%2Fcontrol&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Ccampaign%5C%5Bid%5D%5Ccontrol.ts&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();