"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/campaign/[id]/control";
exports.ids = ["pages/api/campaign/[id]/control"];
exports.modules = {

/***/ "bullmq":
/*!*************************!*\
  !*** external "bullmq" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("bullmq");

/***/ }),

/***/ "ioredis":
/*!**************************!*\
  !*** external "ioredis" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("ioredis");

/***/ }),

/***/ "mongodb":
/*!**************************!*\
  !*** external "mongodb" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("mongodb");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fcampaign%2F%5Bid%5D%2Fcontrol&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Ccampaign%5C%5Bid%5D%5Ccontrol.ts&middlewareConfigBase64=e30%3D!":
/*!****************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fcampaign%2F%5Bid%5D%2Fcontrol&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Ccampaign%5C%5Bid%5D%5Ccontrol.ts&middlewareConfigBase64=e30%3D! ***!
  \****************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_campaign_id_control_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages\\api\\campaign\\[id]\\control.ts */ \"(api)/./pages/api/campaign/[id]/control.ts\");\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_campaign_id_control_ts__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_campaign_id_control_ts__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/campaign/[id]/control\",\n        pathname: \"/api/campaign/[id]/control\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _pages_api_campaign_id_control_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRmNhbXBhaWduJTJGJTVCaWQlNUQlMkZjb250cm9sJnByZWZlcnJlZFJlZ2lvbj0mYWJzb2x1dGVQYWdlUGF0aD0uJTJGcGFnZXMlNUNhcGklNUNjYW1wYWlnbiU1QyU1QmlkJTVEJTVDY29udHJvbC50cyZtaWRkbGV3YXJlQ29uZmlnQmFzZTY0PWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdkM7QUFDTDtBQUMxRDtBQUNxRTtBQUNyRTtBQUNBLGlFQUFlLHdFQUFLLENBQUMsOERBQVEsWUFBWSxFQUFDO0FBQzFDO0FBQ08sZUFBZSx3RUFBSyxDQUFDLDhEQUFRO0FBQ3BDO0FBQ08sd0JBQXdCLGdIQUFtQjtBQUNsRDtBQUNBLGNBQWMseUVBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZO0FBQ1osQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldGluZy1tdnAvPzhjNzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFnZXNBUElSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL3BhZ2VzLWFwaS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBob2lzdCB9IGZyb20gXCJuZXh0L2Rpc3QvYnVpbGQvdGVtcGxhdGVzL2hlbHBlcnNcIjtcbi8vIEltcG9ydCB0aGUgdXNlcmxhbmQgY29kZS5cbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIuL3BhZ2VzXFxcXGFwaVxcXFxjYW1wYWlnblxcXFxbaWRdXFxcXGNvbnRyb2wudHNcIjtcbi8vIFJlLWV4cG9ydCB0aGUgaGFuZGxlciAoc2hvdWxkIGJlIHRoZSBkZWZhdWx0IGV4cG9ydCkuXG5leHBvcnQgZGVmYXVsdCBob2lzdCh1c2VybGFuZCwgXCJkZWZhdWx0XCIpO1xuLy8gUmUtZXhwb3J0IGNvbmZpZy5cbmV4cG9ydCBjb25zdCBjb25maWcgPSBob2lzdCh1c2VybGFuZCwgXCJjb25maWdcIik7XG4vLyBDcmVhdGUgYW5kIGV4cG9ydCB0aGUgcm91dGUgbW9kdWxlIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbmV4cG9ydCBjb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBQYWdlc0FQSVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5QQUdFU19BUEksXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9jYW1wYWlnbi9baWRdL2NvbnRyb2xcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9jYW1wYWlnbi9baWRdL2NvbnRyb2xcIixcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBhcmVuJ3QgdXNlZCBpbiBwcm9kdWN0aW9uLlxuICAgICAgICBidW5kbGVQYXRoOiBcIlwiLFxuICAgICAgICBmaWxlbmFtZTogXCJcIlxuICAgIH0sXG4gICAgdXNlcmxhbmRcbn0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdlcy1hcGkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fcampaign%2F%5Bid%5D%2Fcontrol&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Ccampaign%5C%5Bid%5D%5Ccontrol.ts&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./lib/mongo.ts":
/*!**********************!*\
  !*** ./lib/mongo.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mongodb */ \"mongodb\");\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mongodb__WEBPACK_IMPORTED_MODULE_0__);\n// lib/mongo.ts\n\nconst uri = process.env.MONGODB_URI;\nif (!uri) throw new Error(\"MONGODB_URI not set\");\nlet client;\nlet clientPromise;\n// Retry logic in case MongoDB connection fails\nasync function connectWithRetry() {\n    const MAX_RETRIES = 5;\n    let attempts = 0;\n    let lastError = null;\n    while(attempts < MAX_RETRIES){\n        try {\n            const client = new mongodb__WEBPACK_IMPORTED_MODULE_0__.MongoClient(uri, {\n                maxPoolSize: 10,\n                serverSelectionTimeoutMS: 10000,\n                socketTimeoutMS: 45000\n            });\n            await client.connect();\n            return client;\n        } catch (err) {\n            lastError = err;\n            attempts++;\n            console.error(`MongoDB connection failed (attempt ${attempts}/${MAX_RETRIES}):`, err);\n            if (attempts < MAX_RETRIES) {\n                await new Promise((resolve)=>setTimeout(resolve, 5000)); // wait for 5 seconds before retrying\n            }\n        }\n    }\n    // After max retries, throw the last error encountered\n    throw lastError || new Error(\"MongoDB connection failed after maximum retry attempts\");\n}\nif (!global._mongoClientPromise) {\n    global._mongoClientPromise = connectWithRetry();\n    // Optional: log connection events\n    global._mongoClientPromise.then((client)=>{\n        client.on(\"serverOpening\", (event)=>console.log(\"MongoDB server opening\", event));\n        client.on(\"serverClosed\", (event)=>console.warn(\"MongoDB server closed\", event));\n        client.on(\"topologyClosed\", ()=>console.warn(\"MongoDB topology closed\"));\n        client.on(\"topologyOpening\", ()=>console.log(\"MongoDB topology opening\"));\n        client.on(\"error\", (err)=>console.error(\"MongoDB error\", err));\n    }).catch((err)=>{\n        console.error(\"MongoDB client failed to connect after retries\", err);\n    });\n}\nclientPromise = global._mongoClientPromise;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (clientPromise);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9saWIvbW9uZ28udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZUFBZTtBQUN1QjtBQUV0QyxNQUFNQyxNQUFNQyxRQUFRQyxHQUFHLENBQUNDLFdBQVc7QUFDbkMsSUFBSSxDQUFDSCxLQUFLLE1BQU0sSUFBSUksTUFBTTtBQUUxQixJQUFJQztBQUNKLElBQUlDO0FBT0osK0NBQStDO0FBQy9DLGVBQWVDO0lBQ2IsTUFBTUMsY0FBYztJQUNwQixJQUFJQyxXQUFXO0lBQ2YsSUFBSUMsWUFBMEI7SUFFOUIsTUFBT0QsV0FBV0QsWUFBYTtRQUM3QixJQUFJO1lBQ0YsTUFBTUgsU0FBUyxJQUFJTixnREFBV0EsQ0FBQ0MsS0FBSztnQkFDbENXLGFBQWE7Z0JBQ2JDLDBCQUEwQjtnQkFDMUJDLGlCQUFpQjtZQUNuQjtZQUNBLE1BQU1SLE9BQU9TLE9BQU87WUFDcEIsT0FBT1Q7UUFDVCxFQUFFLE9BQU9VLEtBQVU7WUFDakJMLFlBQVlLO1lBQ1pOO1lBQ0FPLFFBQVFDLEtBQUssQ0FBQyxDQUFDLG1DQUFtQyxFQUFFUixTQUFTLENBQUMsRUFBRUQsWUFBWSxFQUFFLENBQUMsRUFBRU87WUFDakYsSUFBSU4sV0FBV0QsYUFBYTtnQkFDMUIsTUFBTSxJQUFJVSxRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTLFFBQVEscUNBQXFDO1lBQ2hHO1FBQ0Y7SUFDRjtJQUVBLHNEQUFzRDtJQUN0RCxNQUFNVCxhQUFhLElBQUlOLE1BQU07QUFDL0I7QUFFQSxJQUFJLENBQUNpQixPQUFPQyxtQkFBbUIsRUFBRTtJQUMvQkQsT0FBT0MsbUJBQW1CLEdBQUdmO0lBRTdCLGtDQUFrQztJQUNsQ2MsT0FBT0MsbUJBQW1CLENBQ3ZCQyxJQUFJLENBQUNsQixDQUFBQTtRQUNKQSxPQUFPbUIsRUFBRSxDQUFDLGlCQUFpQixDQUFDQyxRQUFVVCxRQUFRVSxHQUFHLENBQUMsMEJBQTBCRDtRQUM1RXBCLE9BQU9tQixFQUFFLENBQUMsZ0JBQWdCLENBQUNDLFFBQVVULFFBQVFXLElBQUksQ0FBQyx5QkFBeUJGO1FBQzNFcEIsT0FBT21CLEVBQUUsQ0FBQyxrQkFBa0IsSUFBTVIsUUFBUVcsSUFBSSxDQUFDO1FBQy9DdEIsT0FBT21CLEVBQUUsQ0FBQyxtQkFBbUIsSUFBTVIsUUFBUVUsR0FBRyxDQUFDO1FBQy9DckIsT0FBT21CLEVBQUUsQ0FBQyxTQUFTLENBQUNULE1BQVFDLFFBQVFDLEtBQUssQ0FBQyxpQkFBaUJGO0lBQzdELEdBQ0NhLEtBQUssQ0FBQ2IsQ0FBQUE7UUFDTEMsUUFBUUMsS0FBSyxDQUFDLGtEQUFrREY7SUFDbEU7QUFDSjtBQUVBVCxnQkFBZ0JlLE9BQU9DLG1CQUFtQjtBQUUxQyxpRUFBZWhCLGFBQWFBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRpbmctbXZwLy4vbGliL21vbmdvLnRzPzU3ZmUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbGliL21vbmdvLnRzXHJcbmltcG9ydCB7IE1vbmdvQ2xpZW50IH0gZnJvbSAnbW9uZ29kYic7XHJcblxyXG5jb25zdCB1cmkgPSBwcm9jZXNzLmVudi5NT05HT0RCX1VSSTtcclxuaWYgKCF1cmkpIHRocm93IG5ldyBFcnJvcignTU9OR09EQl9VUkkgbm90IHNldCcpO1xyXG5cclxubGV0IGNsaWVudDogTW9uZ29DbGllbnQ7XHJcbmxldCBjbGllbnRQcm9taXNlOiBQcm9taXNlPE1vbmdvQ2xpZW50PjtcclxuXHJcbmRlY2xhcmUgZ2xvYmFsIHtcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdmFyXHJcbiAgdmFyIF9tb25nb0NsaWVudFByb21pc2U6IFByb21pc2U8TW9uZ29DbGllbnQ+IHwgdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vLyBSZXRyeSBsb2dpYyBpbiBjYXNlIE1vbmdvREIgY29ubmVjdGlvbiBmYWlsc1xyXG5hc3luYyBmdW5jdGlvbiBjb25uZWN0V2l0aFJldHJ5KCk6IFByb21pc2U8TW9uZ29DbGllbnQ+IHtcclxuICBjb25zdCBNQVhfUkVUUklFUyA9IDU7XHJcbiAgbGV0IGF0dGVtcHRzID0gMDtcclxuICBsZXQgbGFzdEVycm9yOiBFcnJvciB8IG51bGwgPSBudWxsO1xyXG5cclxuICB3aGlsZSAoYXR0ZW1wdHMgPCBNQVhfUkVUUklFUykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgY2xpZW50ID0gbmV3IE1vbmdvQ2xpZW50KHVyaSwge1xyXG4gICAgICAgIG1heFBvb2xTaXplOiAxMCxcclxuICAgICAgICBzZXJ2ZXJTZWxlY3Rpb25UaW1lb3V0TVM6IDEwMDAwLFxyXG4gICAgICAgIHNvY2tldFRpbWVvdXRNUzogNDUwMDAsXHJcbiAgICAgIH0pO1xyXG4gICAgICBhd2FpdCBjbGllbnQuY29ubmVjdCgpO1xyXG4gICAgICByZXR1cm4gY2xpZW50O1xyXG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcclxuICAgICAgbGFzdEVycm9yID0gZXJyO1xyXG4gICAgICBhdHRlbXB0cysrO1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBNb25nb0RCIGNvbm5lY3Rpb24gZmFpbGVkIChhdHRlbXB0ICR7YXR0ZW1wdHN9LyR7TUFYX1JFVFJJRVN9KTpgLCBlcnIpO1xyXG4gICAgICBpZiAoYXR0ZW1wdHMgPCBNQVhfUkVUUklFUykge1xyXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDAwKSk7IC8vIHdhaXQgZm9yIDUgc2Vjb25kcyBiZWZvcmUgcmV0cnlpbmdcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQWZ0ZXIgbWF4IHJldHJpZXMsIHRocm93IHRoZSBsYXN0IGVycm9yIGVuY291bnRlcmVkXHJcbiAgdGhyb3cgbGFzdEVycm9yIHx8IG5ldyBFcnJvcignTW9uZ29EQiBjb25uZWN0aW9uIGZhaWxlZCBhZnRlciBtYXhpbXVtIHJldHJ5IGF0dGVtcHRzJyk7XHJcbn1cclxuXHJcbmlmICghZ2xvYmFsLl9tb25nb0NsaWVudFByb21pc2UpIHtcclxuICBnbG9iYWwuX21vbmdvQ2xpZW50UHJvbWlzZSA9IGNvbm5lY3RXaXRoUmV0cnkoKTtcclxuICBcclxuICAvLyBPcHRpb25hbDogbG9nIGNvbm5lY3Rpb24gZXZlbnRzXHJcbiAgZ2xvYmFsLl9tb25nb0NsaWVudFByb21pc2VcclxuICAgIC50aGVuKGNsaWVudCA9PiB7XHJcbiAgICAgIGNsaWVudC5vbignc2VydmVyT3BlbmluZycsIChldmVudCkgPT4gY29uc29sZS5sb2coJ01vbmdvREIgc2VydmVyIG9wZW5pbmcnLCBldmVudCkpO1xyXG4gICAgICBjbGllbnQub24oJ3NlcnZlckNsb3NlZCcsIChldmVudCkgPT4gY29uc29sZS53YXJuKCdNb25nb0RCIHNlcnZlciBjbG9zZWQnLCBldmVudCkpO1xyXG4gICAgICBjbGllbnQub24oJ3RvcG9sb2d5Q2xvc2VkJywgKCkgPT4gY29uc29sZS53YXJuKCdNb25nb0RCIHRvcG9sb2d5IGNsb3NlZCcpKTtcclxuICAgICAgY2xpZW50Lm9uKCd0b3BvbG9neU9wZW5pbmcnLCAoKSA9PiBjb25zb2xlLmxvZygnTW9uZ29EQiB0b3BvbG9neSBvcGVuaW5nJykpO1xyXG4gICAgICBjbGllbnQub24oJ2Vycm9yJywgKGVycikgPT4gY29uc29sZS5lcnJvcignTW9uZ29EQiBlcnJvcicsIGVycikpO1xyXG4gICAgfSlcclxuICAgIC5jYXRjaChlcnIgPT4ge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdNb25nb0RCIGNsaWVudCBmYWlsZWQgdG8gY29ubmVjdCBhZnRlciByZXRyaWVzJywgZXJyKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5jbGllbnRQcm9taXNlID0gZ2xvYmFsLl9tb25nb0NsaWVudFByb21pc2U7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGllbnRQcm9taXNlOyJdLCJuYW1lcyI6WyJNb25nb0NsaWVudCIsInVyaSIsInByb2Nlc3MiLCJlbnYiLCJNT05HT0RCX1VSSSIsIkVycm9yIiwiY2xpZW50IiwiY2xpZW50UHJvbWlzZSIsImNvbm5lY3RXaXRoUmV0cnkiLCJNQVhfUkVUUklFUyIsImF0dGVtcHRzIiwibGFzdEVycm9yIiwibWF4UG9vbFNpemUiLCJzZXJ2ZXJTZWxlY3Rpb25UaW1lb3V0TVMiLCJzb2NrZXRUaW1lb3V0TVMiLCJjb25uZWN0IiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZ2xvYmFsIiwiX21vbmdvQ2xpZW50UHJvbWlzZSIsInRoZW4iLCJvbiIsImV2ZW50IiwibG9nIiwid2FybiIsImNhdGNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./lib/mongo.ts\n");

/***/ }),

/***/ "(api)/./lib/redis.ts":
/*!**********************!*\
  !*** ./lib/redis.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   redis: () => (/* binding */ redis),\n/* harmony export */   subscribe: () => (/* binding */ subscribe),\n/* harmony export */   subscribeToChannels: () => (/* binding */ subscribeToChannels)\n/* harmony export */ });\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ioredis */ \"ioredis\");\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ioredis__WEBPACK_IMPORTED_MODULE_0__);\n// lib/redis.ts\n\nconst redis = new (ioredis__WEBPACK_IMPORTED_MODULE_0___default())(process.env.REDIS_URL || \"redis://127.0.0.1:6379\", {\n    maxRetriesPerRequest: null,\n    lazyConnect: true,\n    reconnectOnError: (err)=>{\n        const targetErrors = [\n            \"READONLY\",\n            \"ECONNRESET\",\n            \"ETIMEDOUT\"\n        ];\n        try {\n            if (err && typeof err.message === \"string\") {\n                return targetErrors.some((e)=>err.message.includes(e));\n            }\n        } catch  {\n        // fall through\n        }\n        return false;\n    }\n});\nredis.on(\"connect\", ()=>console.log(\"Redis connected\"));\nredis.on(\"ready\", ()=>console.log(\"Redis ready\"));\nredis.on(\"error\", (err)=>console.error(\"Redis error\", err));\nredis.on(\"close\", ()=>console.warn(\"Redis connection closed\"));\nredis.on(\"reconnecting\", ()=>console.log(\"Redis reconnecting\"));\n/**\r\n * Subscribe to a single Redis channel (ioredis-style).\r\n * Returns an async unsubscribe function.\r\n */ async function subscribe(channel, handler) {\n    const sub = redis.duplicate();\n    const onMessage = (msgChannel, message)=>{\n        if (msgChannel !== channel) return;\n        try {\n            handler(JSON.parse(message));\n        } catch  {\n            handler(message);\n        }\n    };\n    sub.on(\"error\", (err)=>{\n        console.error(`Redis subscriber error for channel ${channel}`, err);\n    });\n    sub.on(\"message\", onMessage);\n    try {\n        // connect only if not already connecting/ready\n        try {\n            if (typeof sub.connect === \"function\") {\n                const status = sub.status;\n                if (status !== \"ready\" && status !== \"connecting\") {\n                    await sub.connect().catch((err)=>{\n                        console.warn(\"Subscriber connect error (continuing):\", err);\n                    });\n                } else {\n                // already connecting/ready — skip connect\n                }\n            }\n        } catch (e) {\n            console.warn(\"Subscriber connect guard error\", e);\n        }\n        await sub.subscribe(channel).catch((err)=>{\n            console.warn(`subscribe(${channel}) failed`, err);\n        });\n    } catch (err) {\n        console.error(`Failed to subscribe to Redis channel ${channel}`, err);\n    }\n    return async ()=>{\n        try {\n            sub.off(\"message\", onMessage);\n            try {\n                await sub.unsubscribe(channel);\n            } catch (e) {}\n            try {\n                await sub.quit();\n            } catch (e) {}\n        } catch (err) {\n            console.warn(`Failed to cleanly unsubscribe from Redis channel ${channel}`, err);\n        }\n    };\n}\n/**\r\n * Robust multi-channel subscription helper.\r\n */ async function subscribeToChannels(sub, channels, handler) {\n    if (!sub || !channels || channels.length === 0) return;\n    // ensure connection if possible (guard against duplicate connect calls)\n    try {\n        if (typeof sub.connect === \"function\") {\n            const status = sub.status;\n            if (status !== \"ready\" && status !== \"connecting\") {\n                await sub.connect().catch((err)=>{\n                    console.warn(\"subscribeToChannels: subscriber connect warning\", err);\n                });\n            } else {\n            // already connecting/ready, skip connect\n            }\n        }\n    } catch (e) {\n    // ignore connect errors\n    }\n    for (const ch of channels){\n        try {\n            if (typeof sub.subscribe === \"function\") {\n                await sub.subscribe(ch).catch((err)=>{\n                    console.warn(`subscribeToChannels: subscribe(${ch}) failed`, err);\n                });\n            } else {\n                await sub.subscribe(ch);\n            }\n        } catch (e) {\n            console.warn(`subscribe failed for channel ${ch}, will attempt fallback`, e);\n        }\n    }\n    // Attach 'message' listener\n    try {\n        if (typeof sub.on === \"function\") {\n            const onMsg = (a, b)=>{\n                if (typeof a === \"string\" && typeof b === \"string\") {\n                    handler(a, b);\n                } else if (typeof b === \"string\" && channels.includes(b)) {\n                    handler(b, a);\n                } else {\n                    handler(String(a), String(b));\n                }\n            };\n            sub.__subscribe_to_channels_on_message = onMsg;\n            sub.on(\"message\", onMsg);\n        }\n    } catch (e) {\n        console.warn(\"Fallback Redis message hook failed\", e);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFJLE9BQU9BLE1BQU0sWUFBWUwsU0FBU3RCLFFBQVEsQ0FBQzJCLElBQUk7b0JBQ3hEbkIsUUFBUW1CLEdBQUdEO2dCQUNiLE9BQU87b0JBQ0xsQixRQUFRb0IsT0FBT0YsSUFBSUUsT0FBT0Q7Z0JBQzVCO1lBQ0Y7WUFDQ2xCLElBQVlvQixrQ0FBa0MsR0FBR0o7WUFDbERoQixJQUFJUixFQUFFLENBQUMsV0FBV3dCO1FBQ3BCO0lBQ0YsRUFBRSxPQUFPMUIsR0FBRztRQUNWRyxRQUFRRyxJQUFJLENBQUMsc0NBQXNDTjtJQUNyRDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0aW5nLW12cC8uL2xpYi9yZWRpcy50cz81MWU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGxpYi9yZWRpcy50c1xyXG5pbXBvcnQgSU9SZWRpcyBmcm9tICdpb3JlZGlzJztcclxuXHJcbmV4cG9ydCBjb25zdCByZWRpcyA9IG5ldyBJT1JlZGlzKHByb2Nlc3MuZW52LlJFRElTX1VSTCB8fCAncmVkaXM6Ly8xMjcuMC4wLjE6NjM3OScsIHtcclxuICBtYXhSZXRyaWVzUGVyUmVxdWVzdDogbnVsbCxcclxuICBsYXp5Q29ubmVjdDogdHJ1ZSxcclxuICByZWNvbm5lY3RPbkVycm9yOiAoZXJyOiBhbnkpID0+IHtcclxuICAgIGNvbnN0IHRhcmdldEVycm9ycyA9IFsnUkVBRE9OTFknLCAnRUNPTk5SRVNFVCcsICdFVElNRURPVVQnXTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGlmIChlcnIgJiYgdHlwZW9mIGVyci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXRFcnJvcnMuc29tZShlID0+IGVyci5tZXNzYWdlLmluY2x1ZGVzKGUpKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIC8vIGZhbGwgdGhyb3VnaFxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sXHJcbn0pO1xyXG5cclxucmVkaXMub24oJ2Nvbm5lY3QnLCAoKSA9PiBjb25zb2xlLmxvZygnUmVkaXMgY29ubmVjdGVkJykpO1xyXG5yZWRpcy5vbigncmVhZHknLCAoKSA9PiBjb25zb2xlLmxvZygnUmVkaXMgcmVhZHknKSk7XHJcbnJlZGlzLm9uKCdlcnJvcicsIChlcnIpID0+IGNvbnNvbGUuZXJyb3IoJ1JlZGlzIGVycm9yJywgZXJyKSk7XHJcbnJlZGlzLm9uKCdjbG9zZScsICgpID0+IGNvbnNvbGUud2FybignUmVkaXMgY29ubmVjdGlvbiBjbG9zZWQnKSk7XHJcbnJlZGlzLm9uKCdyZWNvbm5lY3RpbmcnLCAoKSA9PiBjb25zb2xlLmxvZygnUmVkaXMgcmVjb25uZWN0aW5nJykpO1xyXG5cclxuLyoqXHJcbiAqIFN1YnNjcmliZSB0byBhIHNpbmdsZSBSZWRpcyBjaGFubmVsIChpb3JlZGlzLXN0eWxlKS5cclxuICogUmV0dXJucyBhbiBhc3luYyB1bnN1YnNjcmliZSBmdW5jdGlvbi5cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdWJzY3JpYmUoY2hhbm5lbDogc3RyaW5nLCBoYW5kbGVyOiAoZGF0YTogYW55KSA9PiB2b2lkKTogUHJvbWlzZTwoKSA9PiBQcm9taXNlPHZvaWQ+PiB7XHJcbiAgY29uc3Qgc3ViID0gcmVkaXMuZHVwbGljYXRlKCk7XHJcblxyXG4gIGNvbnN0IG9uTWVzc2FnZSA9IChtc2dDaGFubmVsOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZykgPT4ge1xyXG4gICAgaWYgKG1zZ0NoYW5uZWwgIT09IGNoYW5uZWwpIHJldHVybjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGhhbmRsZXIoSlNPTi5wYXJzZShtZXNzYWdlKSk7XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgaGFuZGxlcihtZXNzYWdlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBzdWIub24oJ2Vycm9yJywgKGVycjogYW55KSA9PiB7XHJcbiAgICBjb25zb2xlLmVycm9yKGBSZWRpcyBzdWJzY3JpYmVyIGVycm9yIGZvciBjaGFubmVsICR7Y2hhbm5lbH1gLCBlcnIpO1xyXG4gIH0pO1xyXG5cclxuICBzdWIub24oJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpO1xyXG5cclxuICB0cnkge1xyXG4gICAgLy8gY29ubmVjdCBvbmx5IGlmIG5vdCBhbHJlYWR5IGNvbm5lY3RpbmcvcmVhZHlcclxuICAgIHRyeSB7XHJcbiAgICAgIGlmICh0eXBlb2YgKHN1YiBhcyBhbnkpLmNvbm5lY3QgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBjb25zdCBzdGF0dXMgPSAoc3ViIGFzIGFueSkuc3RhdHVzO1xyXG4gICAgICAgIGlmIChzdGF0dXMgIT09ICdyZWFkeScgJiYgc3RhdHVzICE9PSAnY29ubmVjdGluZycpIHtcclxuICAgICAgICAgIGF3YWl0IChzdWIgYXMgYW55KS5jb25uZWN0KCkuY2F0Y2goKGVycjogYW55KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignU3Vic2NyaWJlciBjb25uZWN0IGVycm9yIChjb250aW51aW5nKTonLCBlcnIpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIGFscmVhZHkgY29ubmVjdGluZy9yZWFkeSDigJQgc2tpcCBjb25uZWN0XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignU3Vic2NyaWJlciBjb25uZWN0IGd1YXJkIGVycm9yJywgZSk7XHJcbiAgICB9XHJcblxyXG4gICAgYXdhaXQgKHN1YiBhcyBhbnkpLnN1YnNjcmliZShjaGFubmVsKS5jYXRjaCgoZXJyOiBhbnkpID0+IHtcclxuICAgICAgY29uc29sZS53YXJuKGBzdWJzY3JpYmUoJHtjaGFubmVsfSkgZmFpbGVkYCwgZXJyKTtcclxuICAgIH0pO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHN1YnNjcmliZSB0byBSZWRpcyBjaGFubmVsICR7Y2hhbm5lbH1gLCBlcnIpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHN1Yi5vZmYoJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpO1xyXG4gICAgICB0cnkgeyBhd2FpdCAoc3ViIGFzIGFueSkudW5zdWJzY3JpYmUoY2hhbm5lbCk7IH0gY2F0Y2ggKGUpIHt9XHJcbiAgICAgIHRyeSB7IGF3YWl0IChzdWIgYXMgYW55KS5xdWl0KCk7IH0gY2F0Y2ggKGUpIHt9XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gY2xlYW5seSB1bnN1YnNjcmliZSBmcm9tIFJlZGlzIGNoYW5uZWwgJHtjaGFubmVsfWAsIGVycik7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJvYnVzdCBtdWx0aS1jaGFubmVsIHN1YnNjcmlwdGlvbiBoZWxwZXIuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3Vic2NyaWJlVG9DaGFubmVscyhcclxuICBzdWI6IGFueSxcclxuICBjaGFubmVsczogc3RyaW5nW10sXHJcbiAgaGFuZGxlcjogKGNoYW5uZWw6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkXHJcbik6IFByb21pc2U8dm9pZD4ge1xyXG4gIGlmICghc3ViIHx8ICFjaGFubmVscyB8fCBjaGFubmVscy5sZW5ndGggPT09IDApIHJldHVybjtcclxuXHJcbiAgLy8gZW5zdXJlIGNvbm5lY3Rpb24gaWYgcG9zc2libGUgKGd1YXJkIGFnYWluc3QgZHVwbGljYXRlIGNvbm5lY3QgY2FsbHMpXHJcbiAgdHJ5IHtcclxuICAgIGlmICh0eXBlb2Ygc3ViLmNvbm5lY3QgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgY29uc3Qgc3RhdHVzID0gKHN1YiBhcyBhbnkpLnN0YXR1cztcclxuICAgICAgaWYgKHN0YXR1cyAhPT0gJ3JlYWR5JyAmJiBzdGF0dXMgIT09ICdjb25uZWN0aW5nJykge1xyXG4gICAgICAgIGF3YWl0IHN1Yi5jb25uZWN0KCkuY2F0Y2goKGVycjogYW55KSA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ3N1YnNjcmliZVRvQ2hhbm5lbHM6IHN1YnNjcmliZXIgY29ubmVjdCB3YXJuaW5nJywgZXJyKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBhbHJlYWR5IGNvbm5lY3RpbmcvcmVhZHksIHNraXAgY29ubmVjdFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgLy8gaWdub3JlIGNvbm5lY3QgZXJyb3JzXHJcbiAgfVxyXG5cclxuICBmb3IgKGNvbnN0IGNoIG9mIGNoYW5uZWxzKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAodHlwZW9mIHN1Yi5zdWJzY3JpYmUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBhd2FpdCBzdWIuc3Vic2NyaWJlKGNoKS5jYXRjaCgoZXJyOiBhbnkpID0+IHtcclxuICAgICAgICAgIGNvbnNvbGUud2Fybihgc3Vic2NyaWJlVG9DaGFubmVsczogc3Vic2NyaWJlKCR7Y2h9KSBmYWlsZWRgLCBlcnIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGF3YWl0IChzdWIgYXMgYW55KS5zdWJzY3JpYmUoY2gpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUud2Fybihgc3Vic2NyaWJlIGZhaWxlZCBmb3IgY2hhbm5lbCAke2NofSwgd2lsbCBhdHRlbXB0IGZhbGxiYWNrYCwgZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBBdHRhY2ggJ21lc3NhZ2UnIGxpc3RlbmVyXHJcbiAgdHJ5IHtcclxuICAgIGlmICh0eXBlb2Ygc3ViLm9uID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGNvbnN0IG9uTXNnID0gKGE6IGFueSwgYjogYW55KSA9PiB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIGhhbmRsZXIoYSwgYik7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYiA9PT0gJ3N0cmluZycgJiYgY2hhbm5lbHMuaW5jbHVkZXMoYikpIHtcclxuICAgICAgICAgIGhhbmRsZXIoYiwgYSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGhhbmRsZXIoU3RyaW5nKGEpLCBTdHJpbmcoYikpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgKHN1YiBhcyBhbnkpLl9fc3Vic2NyaWJlX3RvX2NoYW5uZWxzX29uX21lc3NhZ2UgPSBvbk1zZztcclxuICAgICAgc3ViLm9uKCdtZXNzYWdlJywgb25Nc2cpO1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGNvbnNvbGUud2FybignRmFsbGJhY2sgUmVkaXMgbWVzc2FnZSBob29rIGZhaWxlZCcsIGUpO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsiSU9SZWRpcyIsInJlZGlzIiwicHJvY2VzcyIsImVudiIsIlJFRElTX1VSTCIsIm1heFJldHJpZXNQZXJSZXF1ZXN0IiwibGF6eUNvbm5lY3QiLCJyZWNvbm5lY3RPbkVycm9yIiwiZXJyIiwidGFyZ2V0RXJyb3JzIiwibWVzc2FnZSIsInNvbWUiLCJlIiwiaW5jbHVkZXMiLCJvbiIsImNvbnNvbGUiLCJsb2ciLCJlcnJvciIsIndhcm4iLCJzdWJzY3JpYmUiLCJjaGFubmVsIiwiaGFuZGxlciIsInN1YiIsImR1cGxpY2F0ZSIsIm9uTWVzc2FnZSIsIm1zZ0NoYW5uZWwiLCJKU09OIiwicGFyc2UiLCJjb25uZWN0Iiwic3RhdHVzIiwiY2F0Y2giLCJvZmYiLCJ1bnN1YnNjcmliZSIsInF1aXQiLCJzdWJzY3JpYmVUb0NoYW5uZWxzIiwiY2hhbm5lbHMiLCJsZW5ndGgiLCJjaCIsIm9uTXNnIiwiYSIsImIiLCJTdHJpbmciLCJfX3N1YnNjcmliZV90b19jaGFubmVsc19vbl9tZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./lib/redis.ts\n");

/***/ }),

/***/ "(api)/./pages/api/campaign/[id]/control.ts":
/*!********************************************!*\
  !*** ./pages/api/campaign/[id]/control.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var _lib_mongo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../lib/mongo */ \"(api)/./lib/mongo.ts\");\n/* harmony import */ var _lib_redis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../lib/redis */ \"(api)/./lib/redis.ts\");\n/* harmony import */ var bullmq__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bullmq */ \"bullmq\");\n/* harmony import */ var bullmq__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(bullmq__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! mongodb */ \"mongodb\");\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(mongodb__WEBPACK_IMPORTED_MODULE_3__);\n// pages/api/campaign/[id]/control.ts\n\n\n\n\nconst queue = new bullmq__WEBPACK_IMPORTED_MODULE_2__.Queue(\"campaigns\", {\n    connection: _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis\n});\n// keep parity with worker; allow env override\nconst MAX_ATTEMPTS = Number(process.env.MAX_ATTEMPTS || 3);\n// server-side cap for batch retries per request\nconst BATCH_RETRY_LIMIT = Number(process.env.BATCH_RETRY_LIMIT || 5000);\n// when resuming, limit how many pending jobs we'll try to (re)enqueue\nconst RESUME_ENQUEUE_LIMIT = Number(process.env.RESUME_ENQUEUE_LIMIT || 5000);\n// how long before a 'sending' row is considered stale and eligible for recovery (ms)\nconst STALE_SENDING_MS = Number(process.env.STALE_SENDING_MS || 90000);\nasync function safeHSet(key, obj) {\n    try {\n        await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hset(key, obj);\n    } catch (err) {\n        console.warn(\"Redis unavailable while setting meta\", err);\n    }\n}\nasync function safePublish(channel, payload) {\n    try {\n        await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.publish(channel, JSON.stringify(payload));\n    } catch (err) {\n        console.warn(\"Redis publish failed\", err);\n    }\n}\n// Remove waiting/delayed/active jobs for a campaignId (best-effort)\nasync function removeQueuedJobsForCampaign(campaignId) {\n    try {\n        // get waiting/delayed/active jobs\n        const jobs = await queue.getJobs([\n            \"waiting\",\n            \"delayed\",\n            \"active\",\n            \"paused\"\n        ], 0, -1);\n        const matched = jobs.filter((j)=>{\n            try {\n                return j.data?.campaignId === campaignId;\n            } catch  {\n                return false;\n            }\n        });\n        for (const j of matched){\n            try {\n                // if the job is active, remove may fail - still try\n                await j.remove();\n            } catch (e) {\n                // best-effort — ignore\n                console.warn(`Failed to remove job ${j.id}`, e);\n            }\n        }\n        return matched.length;\n    } catch (err) {\n        console.warn(\"Failed to enumerate/remove jobs for campaign\", err);\n        return 0;\n    }\n}\n/**\r\n * Remove any queued jobs that belong to a specific campaign + contact.\r\n * Returns the number of removed jobs (best-effort).\r\n */ async function removeQueuedJobsForContact(campaignId, contactId) {\n    try {\n        const jobs = await queue.getJobs([\n            \"waiting\",\n            \"delayed\",\n            \"active\",\n            \"paused\"\n        ], 0, -1);\n        const matched = jobs.filter((j)=>{\n            try {\n                return String(j.data?.campaignId) === String(campaignId) && String(j.data?.contactId) === String(contactId);\n            } catch  {\n                return false;\n            }\n        });\n        let removed = 0;\n        for (const j of matched){\n            try {\n                await j.remove();\n                removed++;\n            } catch (e) {\n                console.warn(`Failed to remove job ${j.id} for contact ${contactId}`, e);\n            }\n        }\n        return removed;\n    } catch (e) {\n        console.warn(\"Failed to enumerate/remove jobs for contact\", e);\n        return 0;\n    }\n}\n// safe read of redis meta integer field\nasync function safeGetMetaInt(redisKey, field) {\n    try {\n        const v = await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hget(redisKey, field);\n        return Number(v || 0);\n    } catch (e) {\n        return 0;\n    }\n}\n/**\r\n * Ensure there is a usable `campaign:{id}:definition` in Redis.\r\n * If missing, attempt to construct one from the Mongo campaign document.\r\n * Returns true if definition exists or was written successfully.\r\n */ async function ensureCampaignDefinition(id, campaignDoc) {\n    const key = `campaign:${id}:definition`;\n    try {\n        const existing = await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.get(key);\n        if (existing) return true;\n        // Attempt to build a minimal compatible definition\n        // Worker expects { initial: { subject, body }, followUps: [...] }\n        let built = null;\n        // Prefer explicit shapes commonly used\n        if (campaignDoc?.definition && typeof campaignDoc.definition === \"object\") {\n            built = campaignDoc.definition;\n        } else if (campaignDoc?.initial && typeof campaignDoc.initial === \"object\") {\n            built = {\n                initial: campaignDoc.initial,\n                followUps: campaignDoc.followUps || []\n            };\n        } else if (campaignDoc?.template && typeof campaignDoc.template === \"object\") {\n            built = {\n                initial: {\n                    subject: campaignDoc.template.subject || campaignDoc.name,\n                    body: campaignDoc.template.body || campaignDoc.content || \"\"\n                },\n                followUps: campaignDoc.template.followUps || campaignDoc.followUps || []\n            };\n        } else {\n            // fallback: try to glean subject/body from common fields\n            const subject = campaignDoc?.subject || campaignDoc?.title || campaignDoc?.name || `Campaign ${id}`;\n            const body = campaignDoc?.body || campaignDoc?.content || campaignDoc?.html || \"\";\n            const followUps = campaignDoc?.followUps || campaignDoc?.steps || [];\n            built = {\n                initial: {\n                    subject,\n                    body\n                },\n                followUps\n            };\n        }\n        // If built doesn't look right (no initial subject/body), fail safe\n        if (!built || !built.initial || built.initial.subject == null && built.initial.body == null) {\n            console.warn(\"Unable to construct campaign definition from campaign document\", {\n                campaignId: id,\n                sample: campaignDoc ? Object.keys(campaignDoc).slice(0, 8) : null\n            });\n            return false;\n        }\n        // Persist into Redis (no expiry) so worker can read it\n        try {\n            await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.set(key, JSON.stringify(built));\n            console.log(`Wrote fallback campaign definition into redis for ${id}`);\n            return true;\n        } catch (e) {\n            console.warn(\"Failed to write campaign definition to redis\", e);\n            return false;\n        }\n    } catch (e) {\n        console.warn(\"Error checking/writing campaign definition in redis\", e);\n        return false;\n    }\n}\n/**\r\n * Get a set of contactId strings for jobs currently enqueued for this campaign.\r\n * Used to avoid enqueuing duplicates when resuming.\r\n */ async function getQueuedContactIdsForCampaign(campaignId) {\n    const set = new Set();\n    try {\n        const jobs = await queue.getJobs([\n            \"waiting\",\n            \"delayed\",\n            \"active\",\n            \"paused\"\n        ], 0, -1);\n        for (const j of jobs){\n            try {\n                if (j.data?.campaignId === campaignId && j.data?.contactId) {\n                    set.add(String(j.data.contactId));\n                }\n            } catch  {\n            // ignore malformed jobs\n            }\n        }\n    } catch (e) {\n        console.warn(\"Failed to list queued jobs for campaign when checking duplicates\", e);\n    }\n    return set;\n}\nasync function handler(req, res) {\n    if (req.method !== \"POST\") {\n        return res.status(405).json({\n            error: \"Method not allowed\"\n        });\n    }\n    const { id } = req.query;\n    if (!id || typeof id !== \"string\") {\n        return res.status(400).json({\n            error: \"Invalid campaign id\"\n        });\n    }\n    const { action, confirm, contactId } = req.body;\n    if (!action || ![\n        \"pause\",\n        \"resume\",\n        \"cancel\",\n        \"delete\",\n        \"retryFailed\",\n        \"retryContact\",\n        \"reconcile\",\n        \"manualHold\",\n        \"manualUndo\"\n    ].includes(action)) {\n        return res.status(400).json({\n            error: \"Invalid action\"\n        });\n    }\n    const client = await _lib_mongo__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    const db = client.db(\"PlatformData\");\n    const campaignObjectId = new mongodb__WEBPACK_IMPORTED_MODULE_3__.ObjectId(id);\n    try {\n        // Reload campaign from Mongo (authoritative)\n        const campaign = await db.collection(\"campaigns\").findOne({\n            _id: campaignObjectId\n        });\n        if (!campaign) {\n            return res.status(404).json({\n                error: \"Campaign not found\"\n            });\n        }\n        // Lightweight helpers\n        const redisKey = `campaign:${id}:meta`;\n        // ACTION: Pause\n        if (action === \"pause\") {\n            if (campaign.status === \"paused\") {\n                return res.status(200).json({\n                    ok: true,\n                    message: \"Already paused\"\n                });\n            }\n            await db.collection(\"campaigns\").updateOne({\n                _id: campaignObjectId\n            }, {\n                $set: {\n                    status: \"paused\"\n                }\n            });\n            await safeHSet(redisKey, {\n                status: \"paused\"\n            });\n            // publish campaign-level event so UI disables retry buttons and updates state\n            await safePublish(\"campaign:new\", {\n                id,\n                status: \"paused\"\n            });\n            return res.status(200).json({\n                ok: true,\n                action: \"paused\"\n            });\n        }\n        // ACTION: Resume\n        if (action === \"resume\") {\n            if (campaign.status === \"running\") {\n                return res.status(200).json({\n                    ok: true,\n                    message: \"Already running\"\n                });\n            }\n            // set running in DB + redis\n            await db.collection(\"campaigns\").updateOne({\n                _id: campaignObjectId\n            }, {\n                $set: {\n                    status: \"running\"\n                }\n            });\n            await safeHSet(redisKey, {\n                status: \"running\"\n            });\n            await safePublish(\"campaign:new\", {\n                id,\n                status: \"running\"\n            });\n            // Re-enqueue pending contacts that currently have no queued job for this campaign.\n            // This addresses cases where jobs were removed or not enqueued while the campaign was paused,\n            // ensuring pending rows actually get processed again after resume.\n            try {\n                const queuedSet = await getQueuedContactIdsForCampaign(id);\n                // fetch pending docs (limit to a sane cap)\n                const pendingCursor = db.collection(\"campaign_contacts\").find({\n                    campaignId: campaignObjectId,\n                    status: \"pending\"\n                }, {\n                    projection: {\n                        _id: 1,\n                        contactId: 1,\n                        step: 1\n                    }\n                }).limit(RESUME_ENQUEUE_LIMIT);\n                const pending = await pendingCursor.toArray();\n                const enqueuePromises = [];\n                for (const d of pending){\n                    const cid = d.contactId ? d.contactId.toString ? d.contactId.toString() : String(d.contactId) : d._id.toString ? d._id.toString() : String(d._id);\n                    if (queuedSet.has(cid)) continue; // already queued\n                    try {\n                        enqueuePromises.push(queue.add(d.step ? \"followup\" : \"initial\", {\n                            campaignId: id,\n                            contactId: cid,\n                            step: d.step\n                        }, {\n                            removeOnComplete: true,\n                            removeOnFail: true,\n                            attempts: MAX_ATTEMPTS,\n                            backoff: {\n                                type: \"exponential\",\n                                delay: 60000\n                            }\n                        }));\n                    } catch (e) {\n                        console.warn(\"Failed to enqueue pending contact on resume\", e);\n                    }\n                }\n                // attempt to enqueue in parallel (best-effort)\n                if (enqueuePromises.length > 0) {\n                    await Promise.allSettled(enqueuePromises);\n                    // notify UI that contacts have been re-queued (counts unchanged, but UI may want to refresh)\n                    await safePublish(\"campaign:new\", {\n                        id,\n                        action: \"resume_requeued\",\n                        requeued: enqueuePromises.length\n                    });\n                }\n            } catch (e) {\n                console.warn(\"Failed to re-enqueue pending contacts on resume\", e);\n            }\n            // Recover stale 'sending' ledger rows that may have been left in 'sending' by a crashed worker or killed process.\n            // Criteria: status === 'sending' AND lastAttemptAt older than STALE_SENDING_MS AND bgAttempts < MAX_ATTEMPTS\n            // We'll set them back to 'pending', reset bgAttempts to 0 (so background cycle restarts), and enqueue jobs.\n            try {\n                const cutoff = new Date(Date.now() - STALE_SENDING_MS);\n                const staleCursor = db.collection(\"campaign_contacts\").find({\n                    campaignId: campaignObjectId,\n                    status: \"sending\",\n                    lastAttemptAt: {\n                        $lt: cutoff\n                    }\n                }, {\n                    projection: {\n                        _id: 1,\n                        contactId: 1,\n                        step: 1,\n                        bgAttempts: 1\n                    }\n                }).limit(RESUME_ENQUEUE_LIMIT);\n                const staleDocs = await staleCursor.toArray();\n                if (staleDocs.length > 0) {\n                    const ids = staleDocs.map((d)=>d._id);\n                    // Reset to pending and clear lastError, reset bgAttempts so background retries start fresh\n                    await db.collection(\"campaign_contacts\").updateMany({\n                        _id: {\n                            $in: ids\n                        }\n                    }, {\n                        $set: {\n                            status: \"pending\",\n                            lastError: null,\n                            bgAttempts: 0\n                        }\n                    });\n                    // Enqueue each stale doc if not already queued\n                    const queuedSet2 = await getQueuedContactIdsForCampaign(id);\n                    const requeuePromises = [];\n                    for (const d of staleDocs){\n                        const cid = d.contactId ? d.contactId.toString ? d.contactId.toString() : String(d.contactId) : d._id.toString ? d._id.toString() : String(d._id);\n                        if (queuedSet2.has(cid)) continue;\n                        try {\n                            requeuePromises.push(queue.add(d.step ? \"followup\" : \"initial\", {\n                                campaignId: id,\n                                contactId: cid,\n                                step: d.step\n                            }, {\n                                removeOnComplete: true,\n                                removeOnFail: true,\n                                attempts: MAX_ATTEMPTS,\n                                backoff: {\n                                    type: \"exponential\",\n                                    delay: 60000\n                                }\n                            }));\n                        } catch (e) {\n                            console.warn(\"Failed to enqueue stale sending contact on resume\", e);\n                        }\n                        // publish contact-level update hint so UI reflects it's now pending\n                        try {\n                            safePublish(`campaign:${id}:contact_update`, {\n                                contactId: cid,\n                                status: \"pending\",\n                                bgAttempts: 0,\n                                attempts: undefined\n                            });\n                        } catch (_) {}\n                    }\n                    if (requeuePromises.length > 0) await Promise.allSettled(requeuePromises);\n                    await safePublish(\"campaign:new\", {\n                        id,\n                        action: \"resume_recovered_sending\",\n                        recovered: staleDocs.length\n                    });\n                }\n            } catch (e) {\n                console.warn(\"Failed to recover stale sending rows on resume\", e);\n            }\n            return res.status(200).json({\n                ok: true,\n                action: \"resumed\"\n            });\n        }\n        // ACTION: Reconcile (lightweight, single-request reconciliation)\n        if (action === \"reconcile\") {\n            try {\n                // 1) Recover stale 'sending' rows -> pending\n                const cutoff = new Date(Date.now() - STALE_SENDING_MS);\n                const staleSending = await db.collection(\"campaign_contacts\").find({\n                    campaignId: campaignObjectId,\n                    status: \"sending\",\n                    lastAttemptAt: {\n                        $lt: cutoff\n                    }\n                }).project({\n                    _id: 1,\n                    contactId: 1,\n                    step: 1\n                }).limit(RESUME_ENQUEUE_LIMIT).toArray();\n                if (staleSending.length > 0) {\n                    const ids = staleSending.map((d)=>d._id);\n                    await db.collection(\"campaign_contacts\").updateMany({\n                        _id: {\n                            $in: ids\n                        }\n                    }, {\n                        $set: {\n                            status: \"pending\",\n                            lastError: null,\n                            bgAttempts: 0\n                        }\n                    });\n                }\n                // 2) Enqueue pending docs that do not currently have a job\n                const queuedSet = await getQueuedContactIdsForCampaign(id);\n                const pendingCursor = db.collection(\"campaign_contacts\").find({\n                    campaignId: campaignObjectId,\n                    status: \"pending\"\n                }, {\n                    projection: {\n                        _id: 1,\n                        contactId: 1,\n                        step: 1\n                    }\n                }).limit(RESUME_ENQUEUE_LIMIT);\n                const pendingRows = await pendingCursor.toArray();\n                const enqueuePromises = [];\n                for (const d of pendingRows){\n                    const cid = d.contactId ? d.contactId.toString ? d.contactId.toString() : String(d.contactId) : d._id.toString ? d._id.toString() : String(d._id);\n                    if (queuedSet.has(cid)) continue;\n                    try {\n                        enqueuePromises.push(queue.add(d.step ? \"followup\" : \"initial\", {\n                            campaignId: id,\n                            contactId: cid,\n                            step: d.step\n                        }, {\n                            removeOnComplete: true,\n                            removeOnFail: true,\n                            attempts: MAX_ATTEMPTS,\n                            backoff: {\n                                type: \"exponential\",\n                                delay: 60000\n                            }\n                        }));\n                    } catch (e) {\n                        console.warn(\"Reconcile: failed to enqueue\", e);\n                    }\n                }\n                if (enqueuePromises.length) await Promise.allSettled(enqueuePromises);\n                // 3) Recalculate totals from DB (authoritative)\n                const agg = await db.collection(\"campaign_contacts\").aggregate([\n                    {\n                        $match: {\n                            campaignId: campaignObjectId\n                        }\n                    },\n                    {\n                        $group: {\n                            _id: \"$status\",\n                            count: {\n                                $sum: 1\n                            }\n                        }\n                    }\n                ]).toArray();\n                let pending = 0, sent = 0, failed = 0;\n                for (const r of agg){\n                    if (r._id === \"pending\") pending = r.count;\n                    else if (r._id === \"sent\") sent = r.count;\n                    else if (r._id === \"failed\") failed = r.count;\n                }\n                const processed = sent + failed;\n                const intended = campaign.totals?.intended ?? await db.collection(\"campaign_contacts\").countDocuments({\n                    campaignId: campaignObjectId\n                });\n                // Write back authoritative totals to DB\n                await db.collection(\"campaigns\").updateOne({\n                    _id: campaignObjectId\n                }, {\n                    $set: {\n                        \"totals.processed\": processed,\n                        \"totals.sent\": sent,\n                        \"totals.failed\": failed\n                    }\n                });\n                // Best-effort write to Redis meta\n                try {\n                    await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hset(redisKey, {\n                        processed: String(processed),\n                        sent: String(sent),\n                        failed: String(failed),\n                        total: String(intended)\n                    });\n                } catch (_) {}\n                // 4) Decide canonical campaign status\n                let newStatus = campaign.status;\n                if (processed >= intended) {\n                    if (failed > 0) newStatus = \"completed_with_failures\";\n                    else newStatus = \"completed\";\n                } else {\n                    newStatus = \"running\";\n                }\n                // persist status if changed\n                if (newStatus !== campaign.status) {\n                    await db.collection(\"campaigns\").updateOne({\n                        _id: campaignObjectId\n                    }, {\n                        $set: {\n                            status: newStatus,\n                            completedAt: newStatus.startsWith(\"completed\") ? new Date() : null\n                        }\n                    });\n                    await safeHSet(redisKey, {\n                        status: newStatus\n                    });\n                }\n                await safePublish(\"campaign:new\", {\n                    id,\n                    action: \"reconcile\",\n                    requeued: enqueuePromises.length,\n                    recovered: staleSending.length,\n                    status: newStatus\n                });\n                return res.status(200).json({\n                    ok: true,\n                    requeued: enqueuePromises.length,\n                    recovered: staleSending.length,\n                    status: newStatus\n                });\n            } catch (e) {\n                console.error(\"Reconcile failed\", e);\n                return res.status(500).json({\n                    error: \"reconcile-failed\"\n                });\n            }\n        }\n        // ACTION: Cancel\n        if (action === \"cancel\") {\n            if (campaign.status === \"cancelled\") {\n                return res.status(200).json({\n                    ok: true,\n                    message: \"Already cancelled\"\n                });\n            }\n            // 1) Mark campaign cancelled and completedAt\n            const completedAt = new Date();\n            await db.collection(\"campaigns\").updateOne({\n                _id: campaignObjectId\n            }, {\n                $set: {\n                    status: \"cancelled\",\n                    completedAt\n                }\n            });\n            await safeHSet(redisKey, {\n                status: \"cancelled\"\n            });\n            // 2) Find and atomically mark pending ledger rows as failed (single updateMany)\n            const filter = {\n                campaignId: campaignObjectId,\n                status: \"pending\"\n            };\n            const update = {\n                $set: {\n                    status: \"failed\",\n                    lastError: \"cancelled\",\n                    lastAttemptAt: completedAt\n                },\n                $inc: {\n                    attempts: 1\n                }\n            };\n            const updateResult = await db.collection(\"campaign_contacts\").updateMany(filter, update);\n            const cancelledCount = updateResult.modifiedCount ?? 0;\n            // 3) Update Redis counters (best-effort)\n            try {\n                if (cancelledCount > 0) {\n                    await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hincrby(redisKey, \"processed\", cancelledCount);\n                    await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hincrby(redisKey, \"failed\", cancelledCount);\n                }\n            } catch (e) {\n                console.warn(\"Failed to update redis counters during cancel\", e);\n            }\n            // 4) Persist totals snapshot to campaigns.totals (read redis if available, fallback to db)\n            let meta = {};\n            try {\n                meta = await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hgetall(redisKey) || {};\n            } catch  {\n                meta = {};\n            }\n            // Compute totals final values combining persisted totals and our cancelledCount as fallback\n            const processedNow = Number(meta[\"processed\"] ?? (campaign.totals?.processed ?? 0) + cancelledCount);\n            const sentNow = Number(meta[\"sent\"] ?? campaign.totals?.sent ?? 0);\n            const failedNow = Number(meta[\"failed\"] ?? (campaign.totals?.failed ?? 0) + cancelledCount);\n            await db.collection(\"campaigns\").updateOne({\n                _id: campaignObjectId\n            }, {\n                $set: {\n                    \"totals.processed\": processedNow,\n                    \"totals.sent\": sentNow,\n                    \"totals.failed\": failedNow,\n                    completedAt\n                }\n            });\n            // 5) Remove queued jobs for this campaign (best-effort)\n            const removedJobs = await removeQueuedJobsForCampaign(id);\n            // 6) Publish event\n            await safePublish(\"campaign:new\", {\n                id,\n                status: \"cancelled\",\n                cancelledCount,\n                removedJobs\n            });\n            return res.status(200).json({\n                ok: true,\n                action: \"cancelled\",\n                cancelledCount,\n                removedJobs\n            });\n        }\n        // ACTION: Delete\n        if (action === \"delete\") {\n            // Require explicit confirmation — safeguards in UI must set confirm=true\n            if (confirm !== true) {\n                return res.status(400).json({\n                    error: \"Deletion requires confirm=true in request body\"\n                });\n            }\n            // Prevent accidental deletion while running\n            if (campaign.status === \"running\") {\n                return res.status(400).json({\n                    error: \"Cancel the campaign before deletion\"\n                });\n            }\n            // Remove queued jobs (best-effort)\n            const removedJobs = await removeQueuedJobsForCampaign(id);\n            // Delete Redis keys (best-effort)\n            try {\n                await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.del(`campaign:${id}:meta`);\n                await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.del(`campaign:${id}:definition`);\n                await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.srem(\"campaign:all\", id);\n            } catch (e) {\n                console.warn(\"Redis cleanup on delete failed\", e);\n            }\n            // Delete Mongo docs\n            const [campaignDel, ledgerDel] = await Promise.all([\n                db.collection(\"campaigns\").deleteOne({\n                    _id: campaignObjectId\n                }),\n                db.collection(\"campaign_contacts\").deleteMany({\n                    campaignId: campaignObjectId\n                })\n            ]);\n            await safePublish(\"campaign:new\", {\n                id,\n                status: \"deleted\"\n            });\n            return res.status(200).json({\n                ok: true,\n                action: \"deleted\",\n                campaignDeleted: campaignDel.deletedCount ?? 0,\n                ledgerDeleted: ledgerDel.deletedCount ?? 0,\n                removedJobs\n            });\n        }\n        // ACTION: Retry all failed contacts that are below MAX_ATTEMPTS\n        if (action === \"retryFailed\") {\n            // Disallow retrying if campaign is cancelled/deleted/paused\n            if (campaign.status === \"cancelled\" || campaign.status === \"deleted\" || campaign.status === \"paused\") {\n                return res.status(400).json({\n                    error: \"Cannot retry contacts for cancelled/deleted/paused campaign\"\n                });\n            }\n            // Ensure a Redis campaign definition exists (worker requires it)\n            const hasDef = await ensureCampaignDefinition(id, campaign);\n            if (!hasDef) {\n                return res.status(500).json({\n                    error: \"Missing campaign definition in Redis and unable to construct one from campaign document. Retry cannot proceed.\"\n                });\n            }\n            // find failed contacts with attempts < MAX_ATTEMPTS AND where bgAttempts >= MAX_ATTEMPTS (meaning background cycle finished)\n            // If bgAttempts is missing (undefined/null), treat it as finished (conservative). But prefer explicit >=.\n            const filter = {\n                campaignId: campaignObjectId,\n                status: \"failed\",\n                attempts: {\n                    $lt: MAX_ATTEMPTS\n                },\n                $or: [\n                    {\n                        bgAttempts: {\n                            $exists: false\n                        }\n                    },\n                    {\n                        bgAttempts: {\n                            $gte: MAX_ATTEMPTS\n                        }\n                    }\n                ]\n            };\n            const failedDocs = await db.collection(\"campaign_contacts\").find(filter, {\n                projection: {\n                    _id: 1,\n                    contactId: 1,\n                    step: 1\n                }\n            }).toArray();\n            const toRetryCount = failedDocs.length;\n            if (toRetryCount === 0) {\n                return res.status(200).json({\n                    ok: true,\n                    retried: 0,\n                    message: \"No eligible failed contacts to retry (either none failed, reached max attempts, or background retries still in progress).\"\n                });\n            }\n            // server-side cap enforcement\n            if (toRetryCount > BATCH_RETRY_LIMIT) {\n                return res.status(400).json({\n                    error: \"Batch retry exceeds server limit\",\n                    message: `Trying to retry ${toRetryCount} contacts exceeds server cap of ${BATCH_RETRY_LIMIT}. Use pagination to retry in smaller batches.`,\n                    toRetryCount,\n                    limit: BATCH_RETRY_LIMIT\n                });\n            }\n            // Atomically mark them pending and increment core `attempts` and reset bgAttempts\n            const ids = failedDocs.map((d)=>d._id);\n            const updateResult = await db.collection(\"campaign_contacts\").updateMany({\n                _id: {\n                    $in: ids\n                }\n            }, {\n                $set: {\n                    status: \"pending\",\n                    lastError: null,\n                    bgAttempts: 0\n                },\n                $inc: {\n                    attempts: 1\n                }\n            });\n            const updated = updateResult.modifiedCount ?? 0;\n            // Enqueue jobs (batch), ensure each job has MQ attempts/backoff set\n            const jobs = [];\n            const CHUNK = 200; // reasonable chunking\n            for(let i = 0; i < failedDocs.length; i += CHUNK){\n                const chunk = failedDocs.slice(i, i + CHUNK);\n                for (const doc of chunk){\n                    const contactObjId = doc.contactId ? doc.contactId : doc._id;\n                    try {\n                        if (doc.step) {\n                            jobs.push(queue.add(\"followup\", {\n                                campaignId: id,\n                                contactId: contactObjId.toString ? contactObjId.toString() : String(contactObjId),\n                                step: doc.step\n                            }, {\n                                removeOnComplete: true,\n                                removeOnFail: true,\n                                attempts: MAX_ATTEMPTS,\n                                backoff: {\n                                    type: \"exponential\",\n                                    delay: 60000\n                                }\n                            }));\n                        } else {\n                            jobs.push(queue.add(\"initial\", {\n                                campaignId: id,\n                                contactId: contactObjId.toString ? contactObjId.toString() : String(contactObjId)\n                            }, {\n                                removeOnComplete: true,\n                                removeOnFail: true,\n                                attempts: MAX_ATTEMPTS,\n                                backoff: {\n                                    type: \"exponential\",\n                                    delay: 60000\n                                }\n                            }));\n                        }\n                    } catch (e) {\n                        console.warn(\"Failed to queue job for retryFailed chunk item\", e);\n                    }\n                }\n            }\n            // Wait for enqueues (best-effort)\n            try {\n                await Promise.all(jobs);\n            } catch (e) {\n                console.warn(\"Some queue.add calls failed during retryFailed\", e);\n            }\n            // Update redis counters: decrease failed by updated (best-effort, but avoid negative)\n            try {\n                const currentFailed = await safeGetMetaInt(redisKey, \"failed\");\n                const dec = Math.min(updated, currentFailed);\n                if (dec > 0) {\n                    await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hincrby(redisKey, \"failed\", -dec);\n                }\n            } catch (e) {\n                console.warn(\"Failed to update redis counters during retryFailed\", e);\n            }\n            // Also correct processed counter because we are moving final failed -> pending (processed should drop)\n            try {\n                const currentProcessed = await safeGetMetaInt(redisKey, \"processed\");\n                const decProc = Math.min(updated, currentProcessed);\n                if (decProc > 0) {\n                    await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hincrby(redisKey, \"processed\", -decProc);\n                }\n            } catch (e) {\n                console.warn(\"Failed to update processed counter during retryFailed\", e);\n            }\n            // Publish contact-level updates for each retried contact (best-effort)\n            try {\n                for (const doc of failedDocs){\n                    const cid = doc.contactId ? doc.contactId.toString ? doc.contactId.toString() : String(doc.contactId) : doc._id.toString ? doc._id.toString() : String(doc._id);\n                    await safePublish(`campaign:${id}:contact_update`, {\n                        contactId: cid,\n                        status: \"pending\",\n                        bgAttempts: 0,\n                        attempts: 1\n                    });\n                }\n            } catch (_) {\n            // ignore publish errors\n            }\n            await safePublish(\"campaign:new\", {\n                id,\n                action: \"retryFailed\",\n                retried: updated\n            });\n            return res.status(200).json({\n                ok: true,\n                retried: updated,\n                attemptedEnqueue: toRetryCount\n            });\n        }\n        // ACTION: Retry a single failed contact by contactId\n        if (action === \"retryContact\") {\n            if (!contactId || typeof contactId !== \"string\") {\n                return res.status(400).json({\n                    error: \"Missing contactId for retryContact\"\n                });\n            }\n            // Disallow retrying if campaign is cancelled/deleted/paused\n            if (campaign.status === \"cancelled\" || campaign.status === \"deleted\" || campaign.status === \"paused\") {\n                return res.status(400).json({\n                    error: \"Cannot retry contacts for cancelled/deleted/paused campaign\"\n                });\n            }\n            // Ensure a Redis campaign definition exists (worker requires it)\n            const hasDef = await ensureCampaignDefinition(id, campaign);\n            if (!hasDef) {\n                return res.status(500).json({\n                    error: \"Missing campaign definition in Redis and unable to construct one from campaign document. Retry cannot proceed.\"\n                });\n            }\n            // Find the ledger row\n            let contactObjId;\n            try {\n                // try parse as ObjectId first\n                contactObjId = new mongodb__WEBPACK_IMPORTED_MODULE_3__.ObjectId(contactId);\n            } catch  {\n                // fallback: use raw string\n                contactObjId = contactId;\n            }\n            const doc = await db.collection(\"campaign_contacts\").findOne({\n                campaignId: campaignObjectId,\n                contactId: contactObjId\n            });\n            if (!doc) {\n                return res.status(404).json({\n                    error: \"Contact ledger row not found for campaign\"\n                });\n            }\n            if (doc.status !== \"failed\") {\n                return res.status(400).json({\n                    error: \"Contact is not in failed state\"\n                });\n            }\n            if ((doc.attempts || 0) >= MAX_ATTEMPTS) {\n                return res.status(400).json({\n                    error: \"Contact has reached max manual attempts and cannot be retried\"\n                });\n            }\n            // Prevent manual retry while BullMQ background retries are still running for this contact\n            // Require bgAttempts >= MAX_ATTEMPTS (or missing) before allowing manual retry\n            const bgDone = typeof doc.bgAttempts === \"number\" ? doc.bgAttempts >= MAX_ATTEMPTS : true;\n            if (!bgDone) {\n                return res.status(400).json({\n                    error: \"Background retries are still in progress for this contact. Please wait until the background retry cycle completes.\"\n                });\n            }\n            // Update single doc to pending, increment core attempts, reset bgAttempts\n            await db.collection(\"campaign_contacts\").updateOne({\n                _id: doc._id\n            }, {\n                $set: {\n                    status: \"pending\",\n                    lastError: null,\n                    bgAttempts: 0\n                },\n                $inc: {\n                    attempts: 1\n                }\n            });\n            // Enqueue appropriate job (use doc.step if present) and ensure MQ attempts/backoff are set\n            try {\n                if (doc.step) {\n                    await queue.add(\"followup\", {\n                        campaignId: id,\n                        contactId: contactObjId.toString ? contactObjId.toString() : String(contactObjId),\n                        step: doc.step\n                    }, {\n                        removeOnComplete: true,\n                        removeOnFail: true,\n                        attempts: MAX_ATTEMPTS,\n                        backoff: {\n                            type: \"exponential\",\n                            delay: 60000\n                        }\n                    });\n                } else {\n                    await queue.add(\"initial\", {\n                        campaignId: id,\n                        contactId: contactObjId.toString ? contactObjId.toString() : String(contactObjId)\n                    }, {\n                        removeOnComplete: true,\n                        removeOnFail: true,\n                        attempts: MAX_ATTEMPTS,\n                        backoff: {\n                            type: \"exponential\",\n                            delay: 60000\n                        }\n                    });\n                }\n            } catch (e) {\n                console.warn(\"Failed to enqueue retry job for contact\", e);\n                // Rollback: try to revert the ledger row changes (best-effort)\n                try {\n                    await db.collection(\"campaign_contacts\").updateOne({\n                        _id: doc._id\n                    }, {\n                        $set: {\n                            status: \"failed\",\n                            lastError: \"enqueue-failed\"\n                        },\n                        $inc: {\n                            attempts: -1\n                        },\n                        $set: {\n                            bgAttempts: doc.bgAttempts ?? 0\n                        }\n                    });\n                } catch (_) {}\n                return res.status(500).json({\n                    error: \"Failed to enqueue retry job\"\n                });\n            }\n            // Update redis counters: decrease failed by 1 if possible (we moved it from failed -> pending)\n            try {\n                const currentFailed = await safeGetMetaInt(redisKey, \"failed\");\n                if (currentFailed > 0) {\n                    await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hincrby(redisKey, \"failed\", -1);\n                }\n            } catch (e) {\n                console.warn(\"Failed to update redis counters during retryContact\", e);\n            }\n            // Also decrement processed so totals align (we are un-finalizing a contact)\n            try {\n                const currentProcessed = await safeGetMetaInt(redisKey, \"processed\");\n                if (currentProcessed > 0) {\n                    await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hincrby(redisKey, \"processed\", -1);\n                }\n            } catch (e) {\n                console.warn(\"Failed to update processed counter during retryContact\", e);\n            }\n            // Publish contact update\n            try {\n                const cidStr = contactObjId.toString ? contactObjId.toString() : String(contactObjId);\n                await safePublish(`campaign:${id}:contact_update`, {\n                    contactId: cidStr,\n                    status: \"pending\",\n                    attempts: (doc.attempts || 0) + 1,\n                    bgAttempts: 0\n                });\n            } catch (_) {}\n            await safePublish(\"campaign:new\", {\n                id,\n                action: \"retryContact\",\n                contactId\n            });\n            return res.status(200).json({\n                ok: true,\n                retried: 1,\n                contactId\n            });\n        }\n        // ACTION: Manual Hold (Manual Override) - place contact into a human-controlled hold state\n        if (action === \"manualHold\") {\n            if (!contactId || typeof contactId !== \"string\") {\n                return res.status(400).json({\n                    error: \"Missing contactId for manualHold\"\n                });\n            }\n            // Find ledger row\n            let contactObjId;\n            try {\n                contactObjId = new mongodb__WEBPACK_IMPORTED_MODULE_3__.ObjectId(contactId);\n            } catch  {\n                contactObjId = contactId;\n            }\n            const doc = await db.collection(\"campaign_contacts\").findOne({\n                campaignId: campaignObjectId,\n                contactId: contactObjId\n            });\n            if (!doc) {\n                return res.status(404).json({\n                    error: \"Contact ledger row not found for campaign\"\n                });\n            }\n            // If already in manual_hold, no-op\n            if (doc.status === \"manual_hold\") {\n                return res.status(200).json({\n                    ok: true,\n                    message: \"Contact already under manual hold\"\n                });\n            }\n            const prevStatus = doc.status ?? null;\n            const now = new Date();\n            // Remove any queued jobs for this contact (best-effort)\n            const cidStr = contactObjId.toString ? contactObjId.toString() : String(contactObjId);\n            const removedJobs = await removeQueuedJobsForContact(id, cidStr);\n            // Atomically update ledger: set status manual_hold and push history entry\n            try {\n                await db.collection(\"campaign_contacts\").updateOne({\n                    _id: doc._id\n                }, {\n                    $set: {\n                        status: \"manual_hold\",\n                        lastError: null\n                    },\n                    $push: {\n                        manualHistory: {\n                            at: now,\n                            by: \"user\",\n                            action: \"hold\",\n                            prevStatus,\n                            removedJobs: removedJobs\n                        }\n                    }\n                });\n            } catch (e) {\n                console.warn(\"Failed to set manual_hold on ledger row\", e);\n                return res.status(500).json({\n                    error: \"failed-to-apply-manual-hold\"\n                });\n            }\n            // Publish contact-level update for UI\n            try {\n                await safePublish(`campaign:${id}:contact_update`, {\n                    contactId: cidStr,\n                    status: \"manual_hold\",\n                    prevStatus,\n                    manualActionAt: now.toISOString(),\n                    removedJobs\n                });\n            } catch (_) {}\n            await safePublish(\"campaign:new\", {\n                id,\n                action: \"manualHold\",\n                contactId: cidStr\n            });\n            return res.status(200).json({\n                ok: true,\n                action: \"manual_hold\",\n                contactId: cidStr,\n                removedJobs\n            });\n        }\n        // ACTION: Manual Undo (release previously held contact)\n        if (action === \"manualUndo\") {\n            if (!contactId || typeof contactId !== \"string\") {\n                return res.status(400).json({\n                    error: \"Missing contactId for manualUndo\"\n                });\n            }\n            // Find ledger row\n            let contactObjId2;\n            try {\n                contactObjId2 = new mongodb__WEBPACK_IMPORTED_MODULE_3__.ObjectId(contactId);\n            } catch  {\n                contactObjId2 = contactId;\n            }\n            const doc2 = await db.collection(\"campaign_contacts\").findOne({\n                campaignId: campaignObjectId,\n                contactId: contactObjId2\n            });\n            if (!doc2) {\n                return res.status(404).json({\n                    error: \"Contact ledger row not found for campaign\"\n                });\n            }\n            if (doc2.status !== \"manual_hold\") {\n                return res.status(400).json({\n                    error: \"Contact is not under manual hold\"\n                });\n            }\n            const history = Array.isArray(doc2.manualHistory) ? doc2.manualHistory : [];\n            // Find the last hold entry to determine previous status to restore\n            let lastHoldEntry = null;\n            for(let i = history.length - 1; i >= 0; i--){\n                const h = history[i];\n                if (h && h.action === \"hold\") {\n                    lastHoldEntry = h;\n                    break;\n                }\n            }\n            if (!lastHoldEntry) {\n                // fallback: if no history, restore to 'pending' conservatively\n                lastHoldEntry = {\n                    prevStatus: \"pending\",\n                    at: null\n                };\n            }\n            const restoreTo = lastHoldEntry.prevStatus ?? \"pending\";\n            const now2 = new Date();\n            // Update ledger: set status back to restoreTo and push a release history entry.\n            try {\n                await db.collection(\"campaign_contacts\").updateOne({\n                    _id: doc2._id\n                }, {\n                    $set: {\n                        status: restoreTo,\n                        lastError: null\n                    },\n                    $push: {\n                        manualHistory: {\n                            at: now2,\n                            by: \"user\",\n                            action: \"release\",\n                            restoredTo: restoreTo,\n                            refHoldAt: lastHoldEntry.at ?? null\n                        }\n                    }\n                });\n            } catch (e) {\n                console.warn(\"Failed to release manual_hold on ledger row\", e);\n                return res.status(500).json({\n                    error: \"failed-to-release-manual-hold\"\n                });\n            }\n            const cidStr2 = contactObjId2.toString ? contactObjId2.toString() : String(contactObjId2);\n            // If we restored to pending, attempt to re-enqueue the job (best-effort)\n            let enqueued = false;\n            try {\n                if (restoreTo === \"pending\") {\n                    // decide job type based on doc2.step presence\n                    const contactObjForJob = doc2.contactId ? doc2.contactId.toString ? doc2.contactId.toString() : String(doc2.contactId) : doc2._id.toString ? doc2._id.toString() : String(doc2._id);\n                    if (doc2.step) {\n                        await queue.add(\"followup\", {\n                            campaignId: id,\n                            contactId: contactObjForJob,\n                            step: doc2.step\n                        }, {\n                            removeOnComplete: true,\n                            removeOnFail: true,\n                            attempts: MAX_ATTEMPTS,\n                            backoff: {\n                                type: \"exponential\",\n                                delay: 60000\n                            }\n                        });\n                    } else {\n                        await queue.add(\"initial\", {\n                            campaignId: id,\n                            contactId: contactObjForJob\n                        }, {\n                            removeOnComplete: true,\n                            removeOnFail: true,\n                            attempts: MAX_ATTEMPTS,\n                            backoff: {\n                                type: \"exponential\",\n                                delay: 60000\n                            }\n                        });\n                    }\n                    enqueued = true;\n                }\n            } catch (e) {\n                console.warn(\"Failed to enqueue job when releasing manual hold\", e);\n            // Do not revert status change; surface best-effort result below\n            }\n            // Publish contact-level update\n            try {\n                await safePublish(`campaign:${id}:contact_update`, {\n                    contactId: cidStr2,\n                    status: restoreTo,\n                    manualActionAt: now2.toISOString(),\n                    requeued: enqueued\n                });\n            } catch (_) {}\n            await safePublish(\"campaign:new\", {\n                id,\n                action: \"manualUndo\",\n                contactId: cidStr2,\n                restoredTo: restoreTo,\n                requeued: enqueued\n            });\n            return res.status(200).json({\n                ok: true,\n                action: \"manualUndo\",\n                contactId: cidStr2,\n                restoredTo: restoreTo,\n                requeued: enqueued\n            });\n        }\n        // Should not reach here\n        return res.status(400).json({\n            error: \"Unsupported action\"\n        });\n    } catch (err) {\n        console.error(\"Campaign control error\", err);\n        return res.status(500).json({\n            error: \"Internal server error\"\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9wYWdlcy9hcGkvY2FtcGFpZ24vW2lkXS9jb250cm9sLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxxQ0FBcUM7QUFFYTtBQUNKO0FBQ2Y7QUFDSTtBQUVuQyxNQUFNSSxRQUFRLElBQUlGLHlDQUFLQSxDQUFDLGFBQWE7SUFBRUcsWUFBWUosNkNBQUtBO0FBQUM7QUFFekQsOENBQThDO0FBQzlDLE1BQU1LLGVBQWVDLE9BQU9DLFFBQVFDLEdBQUcsQ0FBQ0gsWUFBWSxJQUFJO0FBQ3hELGdEQUFnRDtBQUNoRCxNQUFNSSxvQkFBb0JILE9BQU9DLFFBQVFDLEdBQUcsQ0FBQ0MsaUJBQWlCLElBQUk7QUFDbEUsc0VBQXNFO0FBQ3RFLE1BQU1DLHVCQUF1QkosT0FBT0MsUUFBUUMsR0FBRyxDQUFDRSxvQkFBb0IsSUFBSTtBQUN4RSxxRkFBcUY7QUFDckYsTUFBTUMsbUJBQW1CTCxPQUFPQyxRQUFRQyxHQUFHLENBQUNHLGdCQUFnQixJQUFJO0FBSWhFLGVBQWVDLFNBQVNDLEdBQVcsRUFBRUMsR0FBMkI7SUFDOUQsSUFBSTtRQUNGLE1BQU1kLDZDQUFLQSxDQUFDZSxJQUFJLENBQUNGLEtBQUtDO0lBQ3hCLEVBQUUsT0FBT0UsS0FBSztRQUNaQyxRQUFRQyxJQUFJLENBQUMsd0NBQXdDRjtJQUN2RDtBQUNGO0FBRUEsZUFBZUcsWUFBWUMsT0FBZSxFQUFFQyxPQUFZO0lBQ3RELElBQUk7UUFDRixNQUFNckIsNkNBQUtBLENBQUNzQixPQUFPLENBQUNGLFNBQVNHLEtBQUtDLFNBQVMsQ0FBQ0g7SUFDOUMsRUFBRSxPQUFPTCxLQUFLO1FBQ1pDLFFBQVFDLElBQUksQ0FBQyx3QkFBd0JGO0lBQ3ZDO0FBQ0Y7QUFFQSxvRUFBb0U7QUFDcEUsZUFBZVMsNEJBQTRCQyxVQUFrQjtJQUMzRCxJQUFJO1FBQ0Ysa0NBQWtDO1FBQ2xDLE1BQU1DLE9BQU8sTUFBTXhCLE1BQU15QixPQUFPLENBQzlCO1lBQUM7WUFBVztZQUFXO1lBQVU7U0FBUyxFQUMx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LEtBQUssQ0FBQywwQkFBMEI3RDtRQUN4QyxPQUFPeUQsSUFBSUUsTUFBTSxDQUFDLEtBQUtDLElBQUksQ0FBQztZQUFFQyxPQUFPO1FBQXdCO0lBQy9EO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRpbmctbXZwLy4vcGFnZXMvYXBpL2NhbXBhaWduL1tpZF0vY29udHJvbC50cz82NzE2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHBhZ2VzL2FwaS9jYW1wYWlnbi9baWRdL2NvbnRyb2wudHNcclxuaW1wb3J0IHR5cGUgeyBOZXh0QXBpUmVxdWVzdCwgTmV4dEFwaVJlc3BvbnNlIH0gZnJvbSAnbmV4dCc7XHJcbmltcG9ydCBjbGllbnRQcm9taXNlIGZyb20gJy4uLy4uLy4uLy4uL2xpYi9tb25nbyc7XHJcbmltcG9ydCB7IHJlZGlzIH0gZnJvbSAnLi4vLi4vLi4vLi4vbGliL3JlZGlzJztcclxuaW1wb3J0IHsgUXVldWUgfSBmcm9tICdidWxsbXEnO1xyXG5pbXBvcnQgeyBPYmplY3RJZCB9IGZyb20gJ21vbmdvZGInO1xyXG5cclxuY29uc3QgcXVldWUgPSBuZXcgUXVldWUoJ2NhbXBhaWducycsIHsgY29ubmVjdGlvbjogcmVkaXMgfSk7XHJcblxyXG4vLyBrZWVwIHBhcml0eSB3aXRoIHdvcmtlcjsgYWxsb3cgZW52IG92ZXJyaWRlXHJcbmNvbnN0IE1BWF9BVFRFTVBUUyA9IE51bWJlcihwcm9jZXNzLmVudi5NQVhfQVRURU1QVFMgfHwgMyk7XHJcbi8vIHNlcnZlci1zaWRlIGNhcCBmb3IgYmF0Y2ggcmV0cmllcyBwZXIgcmVxdWVzdFxyXG5jb25zdCBCQVRDSF9SRVRSWV9MSU1JVCA9IE51bWJlcihwcm9jZXNzLmVudi5CQVRDSF9SRVRSWV9MSU1JVCB8fCA1MDAwKTtcclxuLy8gd2hlbiByZXN1bWluZywgbGltaXQgaG93IG1hbnkgcGVuZGluZyBqb2JzIHdlJ2xsIHRyeSB0byAocmUpZW5xdWV1ZVxyXG5jb25zdCBSRVNVTUVfRU5RVUVVRV9MSU1JVCA9IE51bWJlcihwcm9jZXNzLmVudi5SRVNVTUVfRU5RVUVVRV9MSU1JVCB8fCA1MDAwKTtcclxuLy8gaG93IGxvbmcgYmVmb3JlIGEgJ3NlbmRpbmcnIHJvdyBpcyBjb25zaWRlcmVkIHN0YWxlIGFuZCBlbGlnaWJsZSBmb3IgcmVjb3ZlcnkgKG1zKVxyXG5jb25zdCBTVEFMRV9TRU5ESU5HX01TID0gTnVtYmVyKHByb2Nlc3MuZW52LlNUQUxFX1NFTkRJTkdfTVMgfHwgOTBfMDAwKTtcclxuXHJcbnR5cGUgQWN0aW9uID0gJ3BhdXNlJyB8ICdyZXN1bWUnIHwgJ2NhbmNlbCcgfCAnZGVsZXRlJyB8ICdyZXRyeUZhaWxlZCcgfCAncmV0cnlDb250YWN0JyB8ICdyZWNvbmNpbGUnIHwgJ21hbnVhbEhvbGQnIHwgJ21hbnVhbFVuZG8nO1xyXG5cclxuYXN5bmMgZnVuY3Rpb24gc2FmZUhTZXQoa2V5OiBzdHJpbmcsIG9iajogUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xyXG4gIHRyeSB7XHJcbiAgICBhd2FpdCByZWRpcy5oc2V0KGtleSwgb2JqKTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGNvbnNvbGUud2FybignUmVkaXMgdW5hdmFpbGFibGUgd2hpbGUgc2V0dGluZyBtZXRhJywgZXJyKTtcclxuICB9XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHNhZmVQdWJsaXNoKGNoYW5uZWw6IHN0cmluZywgcGF5bG9hZDogYW55KSB7XHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IHJlZGlzLnB1Ymxpc2goY2hhbm5lbCwgSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgY29uc29sZS53YXJuKCdSZWRpcyBwdWJsaXNoIGZhaWxlZCcsIGVycik7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBSZW1vdmUgd2FpdGluZy9kZWxheWVkL2FjdGl2ZSBqb2JzIGZvciBhIGNhbXBhaWduSWQgKGJlc3QtZWZmb3J0KVxyXG5hc3luYyBmdW5jdGlvbiByZW1vdmVRdWV1ZWRKb2JzRm9yQ2FtcGFpZ24oY2FtcGFpZ25JZDogc3RyaW5nKSB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIGdldCB3YWl0aW5nL2RlbGF5ZWQvYWN0aXZlIGpvYnNcclxuICAgIGNvbnN0IGpvYnMgPSBhd2FpdCBxdWV1ZS5nZXRKb2JzKFxyXG4gICAgICBbJ3dhaXRpbmcnLCAnZGVsYXllZCcsICdhY3RpdmUnLCAncGF1c2VkJ10sXHJcbiAgICAgIDAsXHJcbiAgICAgIC0xXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IG1hdGNoZWQgPSBqb2JzLmZpbHRlcigoaikgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBqLmRhdGE/LmNhbXBhaWduSWQgPT09IGNhbXBhaWduSWQ7XHJcbiAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgZm9yIChjb25zdCBqIG9mIG1hdGNoZWQpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBpZiB0aGUgam9iIGlzIGFjdGl2ZSwgcmVtb3ZlIG1heSBmYWlsIC0gc3RpbGwgdHJ5XHJcbiAgICAgICAgYXdhaXQgai5yZW1vdmUoKTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8vIGJlc3QtZWZmb3J0IOKAlCBpZ25vcmVcclxuICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byByZW1vdmUgam9iICR7ai5pZH1gLCBlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1hdGNoZWQubGVuZ3RoO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gZW51bWVyYXRlL3JlbW92ZSBqb2JzIGZvciBjYW1wYWlnbicsIGVycik7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgYW55IHF1ZXVlZCBqb2JzIHRoYXQgYmVsb25nIHRvIGEgc3BlY2lmaWMgY2FtcGFpZ24gKyBjb250YWN0LlxyXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgcmVtb3ZlZCBqb2JzIChiZXN0LWVmZm9ydCkuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiByZW1vdmVRdWV1ZWRKb2JzRm9yQ29udGFjdChjYW1wYWlnbklkOiBzdHJpbmcsIGNvbnRhY3RJZDogc3RyaW5nKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGpvYnMgPSBhd2FpdCBxdWV1ZS5nZXRKb2JzKFsnd2FpdGluZycsICdkZWxheWVkJywgJ2FjdGl2ZScsICdwYXVzZWQnXSwgMCwgLTEpO1xyXG4gICAgY29uc3QgbWF0Y2hlZCA9IGpvYnMuZmlsdGVyKChqKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZyhqLmRhdGE/LmNhbXBhaWduSWQpID09PSBTdHJpbmcoY2FtcGFpZ25JZCkgJiYgU3RyaW5nKGouZGF0YT8uY29udGFjdElkKSA9PT0gU3RyaW5nKGNvbnRhY3RJZCk7XHJcbiAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IHJlbW92ZWQgPSAwO1xyXG4gICAgZm9yIChjb25zdCBqIG9mIG1hdGNoZWQpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCBqLnJlbW92ZSgpO1xyXG4gICAgICAgIHJlbW92ZWQrKztcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIHJlbW92ZSBqb2IgJHtqLmlkfSBmb3IgY29udGFjdCAke2NvbnRhY3RJZH1gLCBlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlbW92ZWQ7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gZW51bWVyYXRlL3JlbW92ZSBqb2JzIGZvciBjb250YWN0JywgZSk7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbn1cclxuXHJcbi8vIHNhZmUgcmVhZCBvZiByZWRpcyBtZXRhIGludGVnZXIgZmllbGRcclxuYXN5bmMgZnVuY3Rpb24gc2FmZUdldE1ldGFJbnQocmVkaXNLZXk6IHN0cmluZywgZmllbGQ6IHN0cmluZykge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB2ID0gYXdhaXQgcmVkaXMuaGdldChyZWRpc0tleSwgZmllbGQpO1xyXG4gICAgcmV0dXJuIE51bWJlcih2IHx8IDApO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEVuc3VyZSB0aGVyZSBpcyBhIHVzYWJsZSBgY2FtcGFpZ246e2lkfTpkZWZpbml0aW9uYCBpbiBSZWRpcy5cclxuICogSWYgbWlzc2luZywgYXR0ZW1wdCB0byBjb25zdHJ1Y3Qgb25lIGZyb20gdGhlIE1vbmdvIGNhbXBhaWduIGRvY3VtZW50LlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgZGVmaW5pdGlvbiBleGlzdHMgb3Igd2FzIHdyaXR0ZW4gc3VjY2Vzc2Z1bGx5LlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZW5zdXJlQ2FtcGFpZ25EZWZpbml0aW9uKGlkOiBzdHJpbmcsIGNhbXBhaWduRG9jOiBhbnkpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICBjb25zdCBrZXkgPSBgY2FtcGFpZ246JHtpZH06ZGVmaW5pdGlvbmA7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGV4aXN0aW5nID0gYXdhaXQgcmVkaXMuZ2V0KGtleSk7XHJcbiAgICBpZiAoZXhpc3RpbmcpIHJldHVybiB0cnVlO1xyXG5cclxuICAgIC8vIEF0dGVtcHQgdG8gYnVpbGQgYSBtaW5pbWFsIGNvbXBhdGlibGUgZGVmaW5pdGlvblxyXG4gICAgLy8gV29ya2VyIGV4cGVjdHMgeyBpbml0aWFsOiB7IHN1YmplY3QsIGJvZHkgfSwgZm9sbG93VXBzOiBbLi4uXSB9XHJcbiAgICBsZXQgYnVpbHQ6IGFueSA9IG51bGw7XHJcblxyXG4gICAgLy8gUHJlZmVyIGV4cGxpY2l0IHNoYXBlcyBjb21tb25seSB1c2VkXHJcbiAgICBpZiAoY2FtcGFpZ25Eb2M/LmRlZmluaXRpb24gJiYgdHlwZW9mIGNhbXBhaWduRG9jLmRlZmluaXRpb24gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIGJ1aWx0ID0gY2FtcGFpZ25Eb2MuZGVmaW5pdGlvbjtcclxuICAgIH0gZWxzZSBpZiAoY2FtcGFpZ25Eb2M/LmluaXRpYWwgJiYgdHlwZW9mIGNhbXBhaWduRG9jLmluaXRpYWwgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIGJ1aWx0ID0geyBpbml0aWFsOiBjYW1wYWlnbkRvYy5pbml0aWFsLCBmb2xsb3dVcHM6IGNhbXBhaWduRG9jLmZvbGxvd1VwcyB8fCBbXSB9O1xyXG4gICAgfSBlbHNlIGlmIChjYW1wYWlnbkRvYz8udGVtcGxhdGUgJiYgdHlwZW9mIGNhbXBhaWduRG9jLnRlbXBsYXRlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICBidWlsdCA9IHsgaW5pdGlhbDogeyBzdWJqZWN0OiBjYW1wYWlnbkRvYy50ZW1wbGF0ZS5zdWJqZWN0IHx8IGNhbXBhaWduRG9jLm5hbWUsIGJvZHk6IGNhbXBhaWduRG9jLnRlbXBsYXRlLmJvZHkgfHwgY2FtcGFpZ25Eb2MuY29udGVudCB8fCAnJyB9LCBmb2xsb3dVcHM6IGNhbXBhaWduRG9jLnRlbXBsYXRlLmZvbGxvd1VwcyB8fCBjYW1wYWlnbkRvYy5mb2xsb3dVcHMgfHwgW10gfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGZhbGxiYWNrOiB0cnkgdG8gZ2xlYW4gc3ViamVjdC9ib2R5IGZyb20gY29tbW9uIGZpZWxkc1xyXG4gICAgICBjb25zdCBzdWJqZWN0ID0gY2FtcGFpZ25Eb2M/LnN1YmplY3QgfHwgY2FtcGFpZ25Eb2M/LnRpdGxlIHx8IGNhbXBhaWduRG9jPy5uYW1lIHx8IGBDYW1wYWlnbiAke2lkfWA7XHJcbiAgICAgIGNvbnN0IGJvZHkgPSBjYW1wYWlnbkRvYz8uYm9keSB8fCBjYW1wYWlnbkRvYz8uY29udGVudCB8fCBjYW1wYWlnbkRvYz8uaHRtbCB8fCAnJztcclxuICAgICAgY29uc3QgZm9sbG93VXBzID0gY2FtcGFpZ25Eb2M/LmZvbGxvd1VwcyB8fCBjYW1wYWlnbkRvYz8uc3RlcHMgfHwgW107XHJcbiAgICAgIGJ1aWx0ID0geyBpbml0aWFsOiB7IHN1YmplY3QsIGJvZHkgfSwgZm9sbG93VXBzIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgYnVpbHQgZG9lc24ndCBsb29rIHJpZ2h0IChubyBpbml0aWFsIHN1YmplY3QvYm9keSksIGZhaWwgc2FmZVxyXG4gICAgaWYgKCFidWlsdCB8fCAhYnVpbHQuaW5pdGlhbCB8fCAoYnVpbHQuaW5pdGlhbC5zdWJqZWN0ID09IG51bGwgJiYgYnVpbHQuaW5pdGlhbC5ib2R5ID09IG51bGwpKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIGNvbnN0cnVjdCBjYW1wYWlnbiBkZWZpbml0aW9uIGZyb20gY2FtcGFpZ24gZG9jdW1lbnQnLCB7IGNhbXBhaWduSWQ6IGlkLCBzYW1wbGU6IGNhbXBhaWduRG9jID8gT2JqZWN0LmtleXMoY2FtcGFpZ25Eb2MpLnNsaWNlKDAsIDgpIDogbnVsbCB9KTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBlcnNpc3QgaW50byBSZWRpcyAobm8gZXhwaXJ5KSBzbyB3b3JrZXIgY2FuIHJlYWQgaXRcclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IHJlZGlzLnNldChrZXksIEpTT04uc3RyaW5naWZ5KGJ1aWx0KSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBXcm90ZSBmYWxsYmFjayBjYW1wYWlnbiBkZWZpbml0aW9uIGludG8gcmVkaXMgZm9yICR7aWR9YCk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byB3cml0ZSBjYW1wYWlnbiBkZWZpbml0aW9uIHRvIHJlZGlzJywgZSk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ0Vycm9yIGNoZWNraW5nL3dyaXRpbmcgY2FtcGFpZ24gZGVmaW5pdGlvbiBpbiByZWRpcycsIGUpO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBhIHNldCBvZiBjb250YWN0SWQgc3RyaW5ncyBmb3Igam9icyBjdXJyZW50bHkgZW5xdWV1ZWQgZm9yIHRoaXMgY2FtcGFpZ24uXHJcbiAqIFVzZWQgdG8gYXZvaWQgZW5xdWV1aW5nIGR1cGxpY2F0ZXMgd2hlbiByZXN1bWluZy5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGdldFF1ZXVlZENvbnRhY3RJZHNGb3JDYW1wYWlnbihjYW1wYWlnbklkOiBzdHJpbmcpOiBQcm9taXNlPFNldDxzdHJpbmc+PiB7XHJcbiAgY29uc3Qgc2V0ID0gbmV3IFNldDxzdHJpbmc+KCk7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGpvYnMgPSBhd2FpdCBxdWV1ZS5nZXRKb2JzKFsnd2FpdGluZycsICdkZWxheWVkJywgJ2FjdGl2ZScsICdwYXVzZWQnXSwgMCwgLTEpO1xyXG4gICAgZm9yIChjb25zdCBqIG9mIGpvYnMpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAoai5kYXRhPy5jYW1wYWlnbklkID09PSBjYW1wYWlnbklkICYmIGouZGF0YT8uY29udGFjdElkKSB7XHJcbiAgICAgICAgICBzZXQuYWRkKFN0cmluZyhqLmRhdGEuY29udGFjdElkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIHtcclxuICAgICAgICAvLyBpZ25vcmUgbWFsZm9ybWVkIGpvYnNcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGxpc3QgcXVldWVkIGpvYnMgZm9yIGNhbXBhaWduIHdoZW4gY2hlY2tpbmcgZHVwbGljYXRlcycsIGUpO1xyXG4gIH1cclxuICByZXR1cm4gc2V0O1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKFxyXG4gIHJlcTogTmV4dEFwaVJlcXVlc3QsXHJcbiAgcmVzOiBOZXh0QXBpUmVzcG9uc2VcclxuKSB7XHJcbiAgaWYgKHJlcS5tZXRob2QgIT09ICdQT1NUJykge1xyXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA1KS5qc29uKHsgZXJyb3I6ICdNZXRob2Qgbm90IGFsbG93ZWQnIH0pO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgeyBpZCB9ID0gcmVxLnF1ZXJ5O1xyXG4gIGlmICghaWQgfHwgdHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgZXJyb3I6ICdJbnZhbGlkIGNhbXBhaWduIGlkJyB9KTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHsgYWN0aW9uLCBjb25maXJtLCBjb250YWN0SWQgfSA9IHJlcS5ib2R5IGFzIHtcclxuICAgIGFjdGlvbj86IEFjdGlvbjtcclxuICAgIGNvbmZpcm0/OiBib29sZWFuO1xyXG4gICAgY29udGFjdElkPzogc3RyaW5nO1xyXG4gIH07XHJcblxyXG4gIGlmICghYWN0aW9uIHx8ICFbJ3BhdXNlJywgJ3Jlc3VtZScsICdjYW5jZWwnLCAnZGVsZXRlJywgJ3JldHJ5RmFpbGVkJywgJ3JldHJ5Q29udGFjdCcsICdyZWNvbmNpbGUnLCAnbWFudWFsSG9sZCcsICdtYW51YWxVbmRvJ10uaW5jbHVkZXMoYWN0aW9uKSkge1xyXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgZXJyb3I6ICdJbnZhbGlkIGFjdGlvbicgfSk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBjbGllbnQgPSBhd2FpdCBjbGllbnRQcm9taXNlO1xyXG4gIGNvbnN0IGRiID0gY2xpZW50LmRiKCdQbGF0Zm9ybURhdGEnKTtcclxuICBjb25zdCBjYW1wYWlnbk9iamVjdElkID0gbmV3IE9iamVjdElkKGlkKTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIFJlbG9hZCBjYW1wYWlnbiBmcm9tIE1vbmdvIChhdXRob3JpdGF0aXZlKVxyXG4gICAgY29uc3QgY2FtcGFpZ24gPSBhd2FpdCBkYlxyXG4gICAgICAuY29sbGVjdGlvbignY2FtcGFpZ25zJylcclxuICAgICAgLmZpbmRPbmUoeyBfaWQ6IGNhbXBhaWduT2JqZWN0SWQgfSk7XHJcblxyXG4gICAgaWYgKCFjYW1wYWlnbikge1xyXG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDQpLmpzb24oeyBlcnJvcjogJ0NhbXBhaWduIG5vdCBmb3VuZCcgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTGlnaHR3ZWlnaHQgaGVscGVyc1xyXG4gICAgY29uc3QgcmVkaXNLZXkgPSBgY2FtcGFpZ246JHtpZH06bWV0YWA7XHJcblxyXG4gICAgLy8gQUNUSU9OOiBQYXVzZVxyXG4gICAgaWYgKGFjdGlvbiA9PT0gJ3BhdXNlJykge1xyXG4gICAgICBpZiAoY2FtcGFpZ24uc3RhdHVzID09PSAncGF1c2VkJykge1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7IG9rOiB0cnVlLCBtZXNzYWdlOiAnQWxyZWFkeSBwYXVzZWQnIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWducycpLnVwZGF0ZU9uZShcclxuICAgICAgICB7IF9pZDogY2FtcGFpZ25PYmplY3RJZCB9LFxyXG4gICAgICAgIHsgJHNldDogeyBzdGF0dXM6ICdwYXVzZWQnIH0gfVxyXG4gICAgICApO1xyXG4gICAgICBhd2FpdCBzYWZlSFNldChyZWRpc0tleSwgeyBzdGF0dXM6ICdwYXVzZWQnIH0pO1xyXG4gICAgICAvLyBwdWJsaXNoIGNhbXBhaWduLWxldmVsIGV2ZW50IHNvIFVJIGRpc2FibGVzIHJldHJ5IGJ1dHRvbnMgYW5kIHVwZGF0ZXMgc3RhdGVcclxuICAgICAgYXdhaXQgc2FmZVB1Ymxpc2goJ2NhbXBhaWduOm5ldycsIHsgaWQsIHN0YXR1czogJ3BhdXNlZCcgfSk7XHJcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7IG9rOiB0cnVlLCBhY3Rpb246ICdwYXVzZWQnIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFDVElPTjogUmVzdW1lXHJcbiAgICBpZiAoYWN0aW9uID09PSAncmVzdW1lJykge1xyXG4gICAgICBpZiAoY2FtcGFpZ24uc3RhdHVzID09PSAncnVubmluZycpIHtcclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oeyBvazogdHJ1ZSwgbWVzc2FnZTogJ0FscmVhZHkgcnVubmluZycgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHNldCBydW5uaW5nIGluIERCICsgcmVkaXNcclxuICAgICAgYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25zJykudXBkYXRlT25lKFxyXG4gICAgICAgIHsgX2lkOiBjYW1wYWlnbk9iamVjdElkIH0sXHJcbiAgICAgICAgeyAkc2V0OiB7IHN0YXR1czogJ3J1bm5pbmcnIH0gfVxyXG4gICAgICApO1xyXG4gICAgICBhd2FpdCBzYWZlSFNldChyZWRpc0tleSwgeyBzdGF0dXM6ICdydW5uaW5nJyB9KTtcclxuICAgICAgYXdhaXQgc2FmZVB1Ymxpc2goJ2NhbXBhaWduOm5ldycsIHsgaWQsIHN0YXR1czogJ3J1bm5pbmcnIH0pO1xyXG5cclxuICAgICAgLy8gUmUtZW5xdWV1ZSBwZW5kaW5nIGNvbnRhY3RzIHRoYXQgY3VycmVudGx5IGhhdmUgbm8gcXVldWVkIGpvYiBmb3IgdGhpcyBjYW1wYWlnbi5cclxuICAgICAgLy8gVGhpcyBhZGRyZXNzZXMgY2FzZXMgd2hlcmUgam9icyB3ZXJlIHJlbW92ZWQgb3Igbm90IGVucXVldWVkIHdoaWxlIHRoZSBjYW1wYWlnbiB3YXMgcGF1c2VkLFxyXG4gICAgICAvLyBlbnN1cmluZyBwZW5kaW5nIHJvd3MgYWN0dWFsbHkgZ2V0IHByb2Nlc3NlZCBhZ2FpbiBhZnRlciByZXN1bWUuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcXVldWVkU2V0ID0gYXdhaXQgZ2V0UXVldWVkQ29udGFjdElkc0ZvckNhbXBhaWduKGlkKTtcclxuXHJcbiAgICAgICAgLy8gZmV0Y2ggcGVuZGluZyBkb2NzIChsaW1pdCB0byBhIHNhbmUgY2FwKVxyXG4gICAgICAgIGNvbnN0IHBlbmRpbmdDdXJzb3IgPSBkYi5jb2xsZWN0aW9uKCdjYW1wYWlnbl9jb250YWN0cycpLmZpbmQoXHJcbiAgICAgICAgICB7IGNhbXBhaWduSWQ6IGNhbXBhaWduT2JqZWN0SWQsIHN0YXR1czogJ3BlbmRpbmcnIH0sXHJcbiAgICAgICAgICB7IHByb2plY3Rpb246IHsgX2lkOiAxLCBjb250YWN0SWQ6IDEsIHN0ZXA6IDEgfSB9XHJcbiAgICAgICAgKS5saW1pdChSRVNVTUVfRU5RVUVVRV9MSU1JVCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHBlbmRpbmc6IGFueVtdID0gYXdhaXQgcGVuZGluZ0N1cnNvci50b0FycmF5KCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGVucXVldWVQcm9taXNlczogUHJvbWlzZTxhbnk+W10gPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGQgb2YgcGVuZGluZykge1xyXG4gICAgICAgICAgY29uc3QgY2lkID0gZC5jb250YWN0SWQgPyAoZC5jb250YWN0SWQudG9TdHJpbmcgPyBkLmNvbnRhY3RJZC50b1N0cmluZygpIDogU3RyaW5nKGQuY29udGFjdElkKSkgOiAoZC5faWQudG9TdHJpbmcgPyBkLl9pZC50b1N0cmluZygpIDogU3RyaW5nKGQuX2lkKSk7XHJcbiAgICAgICAgICBpZiAocXVldWVkU2V0LmhhcyhjaWQpKSBjb250aW51ZTsgLy8gYWxyZWFkeSBxdWV1ZWRcclxuXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBlbnF1ZXVlUHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICBxdWV1ZS5hZGQoXHJcbiAgICAgICAgICAgICAgICBkLnN0ZXAgPyAnZm9sbG93dXAnIDogJ2luaXRpYWwnLFxyXG4gICAgICAgICAgICAgICAgeyBjYW1wYWlnbklkOiBpZCwgY29udGFjdElkOiBjaWQsIHN0ZXA6IGQuc3RlcCB9LFxyXG4gICAgICAgICAgICAgICAgeyByZW1vdmVPbkNvbXBsZXRlOiB0cnVlLCByZW1vdmVPbkZhaWw6IHRydWUsIGF0dGVtcHRzOiBNQVhfQVRURU1QVFMsIGJhY2tvZmY6IHsgdHlwZTogJ2V4cG9uZW50aWFsJywgZGVsYXk6IDYwXzAwMCB9IH1cclxuICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGVucXVldWUgcGVuZGluZyBjb250YWN0IG9uIHJlc3VtZScsIGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYXR0ZW1wdCB0byBlbnF1ZXVlIGluIHBhcmFsbGVsIChiZXN0LWVmZm9ydClcclxuICAgICAgICBpZiAoZW5xdWV1ZVByb21pc2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChlbnF1ZXVlUHJvbWlzZXMpO1xyXG4gICAgICAgICAgLy8gbm90aWZ5IFVJIHRoYXQgY29udGFjdHMgaGF2ZSBiZWVuIHJlLXF1ZXVlZCAoY291bnRzIHVuY2hhbmdlZCwgYnV0IFVJIG1heSB3YW50IHRvIHJlZnJlc2gpXHJcbiAgICAgICAgICBhd2FpdCBzYWZlUHVibGlzaCgnY2FtcGFpZ246bmV3JywgeyBpZCwgYWN0aW9uOiAncmVzdW1lX3JlcXVldWVkJywgcmVxdWV1ZWQ6IGVucXVldWVQcm9taXNlcy5sZW5ndGggfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcmUtZW5xdWV1ZSBwZW5kaW5nIGNvbnRhY3RzIG9uIHJlc3VtZScsIGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZWNvdmVyIHN0YWxlICdzZW5kaW5nJyBsZWRnZXIgcm93cyB0aGF0IG1heSBoYXZlIGJlZW4gbGVmdCBpbiAnc2VuZGluZycgYnkgYSBjcmFzaGVkIHdvcmtlciBvciBraWxsZWQgcHJvY2Vzcy5cclxuICAgICAgLy8gQ3JpdGVyaWE6IHN0YXR1cyA9PT0gJ3NlbmRpbmcnIEFORCBsYXN0QXR0ZW1wdEF0IG9sZGVyIHRoYW4gU1RBTEVfU0VORElOR19NUyBBTkQgYmdBdHRlbXB0cyA8IE1BWF9BVFRFTVBUU1xyXG4gICAgICAvLyBXZSdsbCBzZXQgdGhlbSBiYWNrIHRvICdwZW5kaW5nJywgcmVzZXQgYmdBdHRlbXB0cyB0byAwIChzbyBiYWNrZ3JvdW5kIGN5Y2xlIHJlc3RhcnRzKSwgYW5kIGVucXVldWUgam9icy5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBjdXRvZmYgPSBuZXcgRGF0ZShEYXRlLm5vdygpIC0gU1RBTEVfU0VORElOR19NUyk7XHJcbiAgICAgICAgY29uc3Qgc3RhbGVDdXJzb3IgPSBkYi5jb2xsZWN0aW9uKCdjYW1wYWlnbl9jb250YWN0cycpLmZpbmQoXHJcbiAgICAgICAgICB7IGNhbXBhaWduSWQ6IGNhbXBhaWduT2JqZWN0SWQsIHN0YXR1czogJ3NlbmRpbmcnLCBsYXN0QXR0ZW1wdEF0OiB7ICRsdDogY3V0b2ZmIH0gfSxcclxuICAgICAgICAgIHsgcHJvamVjdGlvbjogeyBfaWQ6IDEsIGNvbnRhY3RJZDogMSwgc3RlcDogMSwgYmdBdHRlbXB0czogMSB9IH1cclxuICAgICAgICApLmxpbWl0KFJFU1VNRV9FTlFVRVVFX0xJTUlUKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc3RhbGVEb2NzID0gYXdhaXQgc3RhbGVDdXJzb3IudG9BcnJheSgpO1xyXG4gICAgICAgIGlmIChzdGFsZURvY3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgY29uc3QgaWRzID0gc3RhbGVEb2NzLm1hcChkID0+IGQuX2lkKTtcclxuICAgICAgICAgIC8vIFJlc2V0IHRvIHBlbmRpbmcgYW5kIGNsZWFyIGxhc3RFcnJvciwgcmVzZXQgYmdBdHRlbXB0cyBzbyBiYWNrZ3JvdW5kIHJldHJpZXMgc3RhcnQgZnJlc2hcclxuICAgICAgICAgIGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWduX2NvbnRhY3RzJykudXBkYXRlTWFueShcclxuICAgICAgICAgICAgeyBfaWQ6IHsgJGluOiBpZHMgfSB9LFxyXG4gICAgICAgICAgICB7ICRzZXQ6IHsgc3RhdHVzOiAncGVuZGluZycsIGxhc3RFcnJvcjogbnVsbCwgYmdBdHRlbXB0czogMCB9IH1cclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgLy8gRW5xdWV1ZSBlYWNoIHN0YWxlIGRvYyBpZiBub3QgYWxyZWFkeSBxdWV1ZWRcclxuICAgICAgICAgIGNvbnN0IHF1ZXVlZFNldDIgPSBhd2FpdCBnZXRRdWV1ZWRDb250YWN0SWRzRm9yQ2FtcGFpZ24oaWQpO1xyXG4gICAgICAgICAgY29uc3QgcmVxdWV1ZVByb21pc2VzOiBQcm9taXNlPGFueT5bXSA9IFtdO1xyXG4gICAgICAgICAgZm9yIChjb25zdCBkIG9mIHN0YWxlRG9jcykge1xyXG4gICAgICAgICAgICBjb25zdCBjaWQgPSBkLmNvbnRhY3RJZCA/IChkLmNvbnRhY3RJZC50b1N0cmluZyA/IGQuY29udGFjdElkLnRvU3RyaW5nKCkgOiBTdHJpbmcoZC5jb250YWN0SWQpKSA6IChkLl9pZC50b1N0cmluZyA/IGQuX2lkLnRvU3RyaW5nKCkgOiBTdHJpbmcoZC5faWQpKTtcclxuICAgICAgICAgICAgaWYgKHF1ZXVlZFNldDIuaGFzKGNpZCkpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIHJlcXVldWVQcm9taXNlcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgcXVldWUuYWRkKFxyXG4gICAgICAgICAgICAgICAgICBkLnN0ZXAgPyAnZm9sbG93dXAnIDogJ2luaXRpYWwnLFxyXG4gICAgICAgICAgICAgICAgICB7IGNhbXBhaWduSWQ6IGlkLCBjb250YWN0SWQ6IGNpZCwgc3RlcDogZC5zdGVwIH0sXHJcbiAgICAgICAgICAgICAgICAgIHsgcmVtb3ZlT25Db21wbGV0ZTogdHJ1ZSwgcmVtb3ZlT25GYWlsOiB0cnVlLCBhdHRlbXB0czogTUFYX0FUVEVNUFRTLCBiYWNrb2ZmOiB7IHR5cGU6ICdleHBvbmVudGlhbCcsIGRlbGF5OiA2MF8wMDAgfSB9XHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGVucXVldWUgc3RhbGUgc2VuZGluZyBjb250YWN0IG9uIHJlc3VtZScsIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHB1Ymxpc2ggY29udGFjdC1sZXZlbCB1cGRhdGUgaGludCBzbyBVSSByZWZsZWN0cyBpdCdzIG5vdyBwZW5kaW5nXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgc2FmZVB1Ymxpc2goYGNhbXBhaWduOiR7aWR9OmNvbnRhY3RfdXBkYXRlYCwgeyBjb250YWN0SWQ6IGNpZCwgc3RhdHVzOiAncGVuZGluZycsIGJnQXR0ZW1wdHM6IDAsIGF0dGVtcHRzOiB1bmRlZmluZWQgfSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHt9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHJlcXVldWVQcm9taXNlcy5sZW5ndGggPiAwKSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQocmVxdWV1ZVByb21pc2VzKTtcclxuICAgICAgICAgIGF3YWl0IHNhZmVQdWJsaXNoKCdjYW1wYWlnbjpuZXcnLCB7IGlkLCBhY3Rpb246ICdyZXN1bWVfcmVjb3ZlcmVkX3NlbmRpbmcnLCByZWNvdmVyZWQ6IHN0YWxlRG9jcy5sZW5ndGggfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcmVjb3ZlciBzdGFsZSBzZW5kaW5nIHJvd3Mgb24gcmVzdW1lJywgZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7IG9rOiB0cnVlLCBhY3Rpb246ICdyZXN1bWVkJyB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBQ1RJT046IFJlY29uY2lsZSAobGlnaHR3ZWlnaHQsIHNpbmdsZS1yZXF1ZXN0IHJlY29uY2lsaWF0aW9uKVxyXG4gICAgaWYgKGFjdGlvbiA9PT0gJ3JlY29uY2lsZScpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyAxKSBSZWNvdmVyIHN0YWxlICdzZW5kaW5nJyByb3dzIC0+IHBlbmRpbmdcclxuICAgICAgICBjb25zdCBjdXRvZmYgPSBuZXcgRGF0ZShEYXRlLm5vdygpIC0gU1RBTEVfU0VORElOR19NUyk7XHJcbiAgICAgICAgY29uc3Qgc3RhbGVTZW5kaW5nID0gYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25fY29udGFjdHMnKS5maW5kKHtcclxuICAgICAgICAgIGNhbXBhaWduSWQ6IGNhbXBhaWduT2JqZWN0SWQsXHJcbiAgICAgICAgICBzdGF0dXM6ICdzZW5kaW5nJyxcclxuICAgICAgICAgIGxhc3RBdHRlbXB0QXQ6IHsgJGx0OiBjdXRvZmYgfSxcclxuICAgICAgICB9KS5wcm9qZWN0KHsgX2lkOiAxLCBjb250YWN0SWQ6IDEsIHN0ZXA6IDEgfSkubGltaXQoUkVTVU1FX0VOUVVFVUVfTElNSVQpLnRvQXJyYXkoKTtcclxuXHJcbiAgICAgICAgaWYgKHN0YWxlU2VuZGluZy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBjb25zdCBpZHMgPSBzdGFsZVNlbmRpbmcubWFwKGQgPT4gZC5faWQpO1xyXG4gICAgICAgICAgYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25fY29udGFjdHMnKS51cGRhdGVNYW55KFxyXG4gICAgICAgICAgICB7IF9pZDogeyAkaW46IGlkcyB9IH0sXHJcbiAgICAgICAgICAgIHsgJHNldDogeyBzdGF0dXM6ICdwZW5kaW5nJywgbGFzdEVycm9yOiBudWxsLCBiZ0F0dGVtcHRzOiAwIH0gfVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDIpIEVucXVldWUgcGVuZGluZyBkb2NzIHRoYXQgZG8gbm90IGN1cnJlbnRseSBoYXZlIGEgam9iXHJcbiAgICAgICAgY29uc3QgcXVldWVkU2V0ID0gYXdhaXQgZ2V0UXVldWVkQ29udGFjdElkc0ZvckNhbXBhaWduKGlkKTtcclxuICAgICAgICBjb25zdCBwZW5kaW5nQ3Vyc29yID0gZGIuY29sbGVjdGlvbignY2FtcGFpZ25fY29udGFjdHMnKS5maW5kKFxyXG4gICAgICAgICAgeyBjYW1wYWlnbklkOiBjYW1wYWlnbk9iamVjdElkLCBzdGF0dXM6ICdwZW5kaW5nJyB9LFxyXG4gICAgICAgICAgeyBwcm9qZWN0aW9uOiB7IF9pZDogMSwgY29udGFjdElkOiAxLCBzdGVwOiAxIH0gfVxyXG4gICAgICAgICkubGltaXQoUkVTVU1FX0VOUVVFVUVfTElNSVQpO1xyXG4gICAgICAgIGNvbnN0IHBlbmRpbmdSb3dzID0gYXdhaXQgcGVuZGluZ0N1cnNvci50b0FycmF5KCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGVucXVldWVQcm9taXNlczogUHJvbWlzZTxhbnk+W10gPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGQgb2YgcGVuZGluZ1Jvd3MpIHtcclxuICAgICAgICAgIGNvbnN0IGNpZCA9IGQuY29udGFjdElkID8gKGQuY29udGFjdElkLnRvU3RyaW5nID8gZC5jb250YWN0SWQudG9TdHJpbmcoKSA6IFN0cmluZyhkLmNvbnRhY3RJZCkpIDogKGQuX2lkLnRvU3RyaW5nID8gZC5faWQudG9TdHJpbmcoKSA6IFN0cmluZyhkLl9pZCkpO1xyXG4gICAgICAgICAgaWYgKHF1ZXVlZFNldC5oYXMoY2lkKSkgY29udGludWU7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBlbnF1ZXVlUHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICBxdWV1ZS5hZGQoXHJcbiAgICAgICAgICAgICAgICBkLnN0ZXAgPyAnZm9sbG93dXAnIDogJ2luaXRpYWwnLFxyXG4gICAgICAgICAgICAgICAgeyBjYW1wYWlnbklkOiBpZCwgY29udGFjdElkOiBjaWQsIHN0ZXA6IGQuc3RlcCB9LFxyXG4gICAgICAgICAgICAgICAgeyByZW1vdmVPbkNvbXBsZXRlOiB0cnVlLCByZW1vdmVPbkZhaWw6IHRydWUsIGF0dGVtcHRzOiBNQVhfQVRURU1QVFMsIGJhY2tvZmY6IHsgdHlwZTogJ2V4cG9uZW50aWFsJywgZGVsYXk6IDYwXzAwMCB9IH1cclxuICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignUmVjb25jaWxlOiBmYWlsZWQgdG8gZW5xdWV1ZScsIGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5xdWV1ZVByb21pc2VzLmxlbmd0aCkgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKGVucXVldWVQcm9taXNlcyk7XHJcblxyXG4gICAgICAgIC8vIDMpIFJlY2FsY3VsYXRlIHRvdGFscyBmcm9tIERCIChhdXRob3JpdGF0aXZlKVxyXG4gICAgICAgIGNvbnN0IGFnZyA9IGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWduX2NvbnRhY3RzJykuYWdncmVnYXRlKFtcclxuICAgICAgICAgIHsgJG1hdGNoOiB7IGNhbXBhaWduSWQ6IGNhbXBhaWduT2JqZWN0SWQgfSB9LFxyXG4gICAgICAgICAgeyAkZ3JvdXA6IHsgX2lkOiAnJHN0YXR1cycsIGNvdW50OiB7ICRzdW06IDEgfSB9IH1cclxuICAgICAgICBdKS50b0FycmF5KCk7XHJcblxyXG4gICAgICAgIGxldCBwZW5kaW5nID0gMCwgc2VudCA9IDAsIGZhaWxlZCA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCByIG9mIGFnZykge1xyXG4gICAgICAgICAgaWYgKHIuX2lkID09PSAncGVuZGluZycpIHBlbmRpbmcgPSByLmNvdW50O1xyXG4gICAgICAgICAgZWxzZSBpZiAoci5faWQgPT09ICdzZW50Jykgc2VudCA9IHIuY291bnQ7XHJcbiAgICAgICAgICBlbHNlIGlmIChyLl9pZCA9PT0gJ2ZhaWxlZCcpIGZhaWxlZCA9IHIuY291bnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IHNlbnQgKyBmYWlsZWQ7XHJcbiAgICAgICAgY29uc3QgaW50ZW5kZWQgPSBjYW1wYWlnbi50b3RhbHM/LmludGVuZGVkID8/IChhd2FpdCBkYi5jb2xsZWN0aW9uKCdjYW1wYWlnbl9jb250YWN0cycpLmNvdW50RG9jdW1lbnRzKHsgY2FtcGFpZ25JZDogY2FtcGFpZ25PYmplY3RJZCB9KSk7XHJcblxyXG4gICAgICAgIC8vIFdyaXRlIGJhY2sgYXV0aG9yaXRhdGl2ZSB0b3RhbHMgdG8gREJcclxuICAgICAgICBhd2FpdCBkYi5jb2xsZWN0aW9uKCdjYW1wYWlnbnMnKS51cGRhdGVPbmUoXHJcbiAgICAgICAgICB7IF9pZDogY2FtcGFpZ25PYmplY3RJZCB9LFxyXG4gICAgICAgICAgeyAkc2V0OiB7ICd0b3RhbHMucHJvY2Vzc2VkJzogcHJvY2Vzc2VkLCAndG90YWxzLnNlbnQnOiBzZW50LCAndG90YWxzLmZhaWxlZCc6IGZhaWxlZCB9IH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBCZXN0LWVmZm9ydCB3cml0ZSB0byBSZWRpcyBtZXRhXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGF3YWl0IHJlZGlzLmhzZXQocmVkaXNLZXksIHsgcHJvY2Vzc2VkOiBTdHJpbmcocHJvY2Vzc2VkKSwgc2VudDogU3RyaW5nKHNlbnQpLCBmYWlsZWQ6IFN0cmluZyhmYWlsZWQpLCB0b3RhbDogU3RyaW5nKGludGVuZGVkKSB9KTtcclxuICAgICAgICB9IGNhdGNoIChfKSB7fVxyXG5cclxuICAgICAgICAvLyA0KSBEZWNpZGUgY2Fub25pY2FsIGNhbXBhaWduIHN0YXR1c1xyXG4gICAgICAgIGxldCBuZXdTdGF0dXMgPSBjYW1wYWlnbi5zdGF0dXM7XHJcbiAgICAgICAgaWYgKHByb2Nlc3NlZCA+PSBpbnRlbmRlZCkge1xyXG4gICAgICAgICAgaWYgKGZhaWxlZCA+IDApIG5ld1N0YXR1cyA9ICdjb21wbGV0ZWRfd2l0aF9mYWlsdXJlcyc7XHJcbiAgICAgICAgICBlbHNlIG5ld1N0YXR1cyA9ICdjb21wbGV0ZWQnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuZXdTdGF0dXMgPSAncnVubmluZyc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBwZXJzaXN0IHN0YXR1cyBpZiBjaGFuZ2VkXHJcbiAgICAgICAgaWYgKG5ld1N0YXR1cyAhPT0gY2FtcGFpZ24uc3RhdHVzKSB7XHJcbiAgICAgICAgICBhd2FpdCBkYi5jb2xsZWN0aW9uKCdjYW1wYWlnbnMnKS51cGRhdGVPbmUoeyBfaWQ6IGNhbXBhaWduT2JqZWN0SWQgfSwgeyAkc2V0OiB7IHN0YXR1czogbmV3U3RhdHVzLCBjb21wbGV0ZWRBdDogKG5ld1N0YXR1cy5zdGFydHNXaXRoKCdjb21wbGV0ZWQnKSA/IG5ldyBEYXRlKCkgOiBudWxsKSB9IH0gYXMgYW55KTtcclxuICAgICAgICAgIGF3YWl0IHNhZmVIU2V0KHJlZGlzS2V5LCB7IHN0YXR1czogbmV3U3RhdHVzIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXdhaXQgc2FmZVB1Ymxpc2goJ2NhbXBhaWduOm5ldycsIHsgaWQsIGFjdGlvbjogJ3JlY29uY2lsZScsIHJlcXVldWVkOiBlbnF1ZXVlUHJvbWlzZXMubGVuZ3RoLCByZWNvdmVyZWQ6IHN0YWxlU2VuZGluZy5sZW5ndGgsIHN0YXR1czogbmV3U3RhdHVzIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oeyBvazogdHJ1ZSwgcmVxdWV1ZWQ6IGVucXVldWVQcm9taXNlcy5sZW5ndGgsIHJlY292ZXJlZDogc3RhbGVTZW5kaW5nLmxlbmd0aCwgc3RhdHVzOiBuZXdTdGF0dXMgfSk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdSZWNvbmNpbGUgZmFpbGVkJywgZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgZXJyb3I6ICdyZWNvbmNpbGUtZmFpbGVkJyB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEFDVElPTjogQ2FuY2VsXHJcbiAgICBpZiAoYWN0aW9uID09PSAnY2FuY2VsJykge1xyXG4gICAgICBpZiAoY2FtcGFpZ24uc3RhdHVzID09PSAnY2FuY2VsbGVkJykge1xyXG4gICAgICAgIHJldHVybiByZXNcclxuICAgICAgICAgIC5zdGF0dXMoMjAwKVxyXG4gICAgICAgICAgLmpzb24oeyBvazogdHJ1ZSwgbWVzc2FnZTogJ0FscmVhZHkgY2FuY2VsbGVkJyB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gMSkgTWFyayBjYW1wYWlnbiBjYW5jZWxsZWQgYW5kIGNvbXBsZXRlZEF0XHJcbiAgICAgIGNvbnN0IGNvbXBsZXRlZEF0ID0gbmV3IERhdGUoKTtcclxuICAgICAgYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25zJykudXBkYXRlT25lKFxyXG4gICAgICAgIHsgX2lkOiBjYW1wYWlnbk9iamVjdElkIH0sXHJcbiAgICAgICAgeyAkc2V0OiB7IHN0YXR1czogJ2NhbmNlbGxlZCcsIGNvbXBsZXRlZEF0IH0gfVxyXG4gICAgICApO1xyXG4gICAgICBhd2FpdCBzYWZlSFNldChyZWRpc0tleSwgeyBzdGF0dXM6ICdjYW5jZWxsZWQnIH0pO1xyXG5cclxuICAgICAgLy8gMikgRmluZCBhbmQgYXRvbWljYWxseSBtYXJrIHBlbmRpbmcgbGVkZ2VyIHJvd3MgYXMgZmFpbGVkIChzaW5nbGUgdXBkYXRlTWFueSlcclxuICAgICAgY29uc3QgZmlsdGVyID0geyBjYW1wYWlnbklkOiBjYW1wYWlnbk9iamVjdElkLCBzdGF0dXM6ICdwZW5kaW5nJyB9O1xyXG4gICAgICBjb25zdCB1cGRhdGUgPSB7XHJcbiAgICAgICAgJHNldDoge1xyXG4gICAgICAgICAgc3RhdHVzOiAnZmFpbGVkJyxcclxuICAgICAgICAgIGxhc3RFcnJvcjogJ2NhbmNlbGxlZCcsXHJcbiAgICAgICAgICBsYXN0QXR0ZW1wdEF0OiBjb21wbGV0ZWRBdCxcclxuICAgICAgICB9LFxyXG4gICAgICAgICRpbmM6IHsgYXR0ZW1wdHM6IDEgfSxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGNvbnN0IHVwZGF0ZVJlc3VsdCA9IGF3YWl0IGRiXHJcbiAgICAgICAgLmNvbGxlY3Rpb24oJ2NhbXBhaWduX2NvbnRhY3RzJylcclxuICAgICAgICAudXBkYXRlTWFueShmaWx0ZXIsIHVwZGF0ZSk7XHJcblxyXG4gICAgICBjb25zdCBjYW5jZWxsZWRDb3VudCA9IHVwZGF0ZVJlc3VsdC5tb2RpZmllZENvdW50ID8/IDA7XHJcblxyXG4gICAgICAvLyAzKSBVcGRhdGUgUmVkaXMgY291bnRlcnMgKGJlc3QtZWZmb3J0KVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmIChjYW5jZWxsZWRDb3VudCA+IDApIHtcclxuICAgICAgICAgIGF3YWl0IHJlZGlzLmhpbmNyYnkocmVkaXNLZXksICdwcm9jZXNzZWQnLCBjYW5jZWxsZWRDb3VudCk7XHJcbiAgICAgICAgICBhd2FpdCByZWRpcy5oaW5jcmJ5KHJlZGlzS2V5LCAnZmFpbGVkJywgY2FuY2VsbGVkQ291bnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHVwZGF0ZSByZWRpcyBjb3VudGVycyBkdXJpbmcgY2FuY2VsJywgZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIDQpIFBlcnNpc3QgdG90YWxzIHNuYXBzaG90IHRvIGNhbXBhaWducy50b3RhbHMgKHJlYWQgcmVkaXMgaWYgYXZhaWxhYmxlLCBmYWxsYmFjayB0byBkYilcclxuICAgICAgbGV0IG1ldGEgPSB7fTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBtZXRhID0gKGF3YWl0IHJlZGlzLmhnZXRhbGwocmVkaXNLZXkpKSB8fCB7fTtcclxuICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgbWV0YSA9IHt9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb21wdXRlIHRvdGFscyBmaW5hbCB2YWx1ZXMgY29tYmluaW5nIHBlcnNpc3RlZCB0b3RhbHMgYW5kIG91ciBjYW5jZWxsZWRDb3VudCBhcyBmYWxsYmFja1xyXG4gICAgICBjb25zdCBwcm9jZXNzZWROb3cgPSBOdW1iZXIobWV0YVsncHJvY2Vzc2VkJ10gPz8gKGNhbXBhaWduLnRvdGFscz8ucHJvY2Vzc2VkID8/IDApICsgY2FuY2VsbGVkQ291bnQpO1xyXG4gICAgICBjb25zdCBzZW50Tm93ID0gTnVtYmVyKG1ldGFbJ3NlbnQnXSA/PyAoY2FtcGFpZ24udG90YWxzPy5zZW50ID8/IDApKTtcclxuICAgICAgY29uc3QgZmFpbGVkTm93ID0gTnVtYmVyKG1ldGFbJ2ZhaWxlZCddID8/IChjYW1wYWlnbi50b3RhbHM/LmZhaWxlZCA/PyAwKSArIGNhbmNlbGxlZENvdW50KTtcclxuXHJcbiAgICAgIGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWducycpLnVwZGF0ZU9uZShcclxuICAgICAgICB7IF9pZDogY2FtcGFpZ25PYmplY3RJZCB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICRzZXQ6IHtcclxuICAgICAgICAgICAgJ3RvdGFscy5wcm9jZXNzZWQnOiBwcm9jZXNzZWROb3csXHJcbiAgICAgICAgICAgICd0b3RhbHMuc2VudCc6IHNlbnROb3csXHJcbiAgICAgICAgICAgICd0b3RhbHMuZmFpbGVkJzogZmFpbGVkTm93LFxyXG4gICAgICAgICAgICBjb21wbGV0ZWRBdCxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gNSkgUmVtb3ZlIHF1ZXVlZCBqb2JzIGZvciB0aGlzIGNhbXBhaWduIChiZXN0LWVmZm9ydClcclxuICAgICAgY29uc3QgcmVtb3ZlZEpvYnMgPSBhd2FpdCByZW1vdmVRdWV1ZWRKb2JzRm9yQ2FtcGFpZ24oaWQpO1xyXG5cclxuICAgICAgLy8gNikgUHVibGlzaCBldmVudFxyXG4gICAgICBhd2FpdCBzYWZlUHVibGlzaCgnY2FtcGFpZ246bmV3JywgeyBpZCwgc3RhdHVzOiAnY2FuY2VsbGVkJywgY2FuY2VsbGVkQ291bnQsIHJlbW92ZWRKb2JzIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHtcclxuICAgICAgICBvazogdHJ1ZSxcclxuICAgICAgICBhY3Rpb246ICdjYW5jZWxsZWQnLFxyXG4gICAgICAgIGNhbmNlbGxlZENvdW50LFxyXG4gICAgICAgIHJlbW92ZWRKb2JzLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBQ1RJT046IERlbGV0ZVxyXG4gICAgaWYgKGFjdGlvbiA9PT0gJ2RlbGV0ZScpIHtcclxuICAgICAgLy8gUmVxdWlyZSBleHBsaWNpdCBjb25maXJtYXRpb24g4oCUIHNhZmVndWFyZHMgaW4gVUkgbXVzdCBzZXQgY29uZmlybT10cnVlXHJcbiAgICAgIGlmIChjb25maXJtICE9PSB0cnVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc1xyXG4gICAgICAgICAgLnN0YXR1cyg0MDApXHJcbiAgICAgICAgICAuanNvbih7IGVycm9yOiAnRGVsZXRpb24gcmVxdWlyZXMgY29uZmlybT10cnVlIGluIHJlcXVlc3QgYm9keScgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFByZXZlbnQgYWNjaWRlbnRhbCBkZWxldGlvbiB3aGlsZSBydW5uaW5nXHJcbiAgICAgIGlmIChjYW1wYWlnbi5zdGF0dXMgPT09ICdydW5uaW5nJykge1xyXG4gICAgICAgIHJldHVybiByZXNcclxuICAgICAgICAgIC5zdGF0dXMoNDAwKVxyXG4gICAgICAgICAgLmpzb24oeyBlcnJvcjogJ0NhbmNlbCB0aGUgY2FtcGFpZ24gYmVmb3JlIGRlbGV0aW9uJyB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIHF1ZXVlZCBqb2JzIChiZXN0LWVmZm9ydClcclxuICAgICAgY29uc3QgcmVtb3ZlZEpvYnMgPSBhd2FpdCByZW1vdmVRdWV1ZWRKb2JzRm9yQ2FtcGFpZ24oaWQpO1xyXG5cclxuICAgICAgLy8gRGVsZXRlIFJlZGlzIGtleXMgKGJlc3QtZWZmb3J0KVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IHJlZGlzLmRlbChgY2FtcGFpZ246JHtpZH06bWV0YWApO1xyXG4gICAgICAgIGF3YWl0IHJlZGlzLmRlbChgY2FtcGFpZ246JHtpZH06ZGVmaW5pdGlvbmApO1xyXG4gICAgICAgIGF3YWl0IHJlZGlzLnNyZW0oJ2NhbXBhaWduOmFsbCcsIGlkKTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignUmVkaXMgY2xlYW51cCBvbiBkZWxldGUgZmFpbGVkJywgZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERlbGV0ZSBNb25nbyBkb2NzXHJcbiAgICAgIGNvbnN0IFtjYW1wYWlnbkRlbCwgbGVkZ2VyRGVsXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICBkYi5jb2xsZWN0aW9uKCdjYW1wYWlnbnMnKS5kZWxldGVPbmUoeyBfaWQ6IGNhbXBhaWduT2JqZWN0SWQgfSksXHJcbiAgICAgICAgZGIuY29sbGVjdGlvbignY2FtcGFpZ25fY29udGFjdHMnKS5kZWxldGVNYW55KHsgY2FtcGFpZ25JZDogY2FtcGFpZ25PYmplY3RJZCB9KSxcclxuICAgICAgXSk7XHJcblxyXG4gICAgICBhd2FpdCBzYWZlUHVibGlzaCgnY2FtcGFpZ246bmV3JywgeyBpZCwgc3RhdHVzOiAnZGVsZXRlZCcgfSk7XHJcblxyXG4gICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oe1xyXG4gICAgICAgIG9rOiB0cnVlLFxyXG4gICAgICAgIGFjdGlvbjogJ2RlbGV0ZWQnLFxyXG4gICAgICAgIGNhbXBhaWduRGVsZXRlZDogY2FtcGFpZ25EZWwuZGVsZXRlZENvdW50ID8/IDAsXHJcbiAgICAgICAgbGVkZ2VyRGVsZXRlZDogbGVkZ2VyRGVsLmRlbGV0ZWRDb3VudCA/PyAwLFxyXG4gICAgICAgIHJlbW92ZWRKb2JzLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBQ1RJT046IFJldHJ5IGFsbCBmYWlsZWQgY29udGFjdHMgdGhhdCBhcmUgYmVsb3cgTUFYX0FUVEVNUFRTXHJcbiAgICBpZiAoYWN0aW9uID09PSAncmV0cnlGYWlsZWQnKSB7XHJcbiAgICAgIC8vIERpc2FsbG93IHJldHJ5aW5nIGlmIGNhbXBhaWduIGlzIGNhbmNlbGxlZC9kZWxldGVkL3BhdXNlZFxyXG4gICAgICBpZiAoY2FtcGFpZ24uc3RhdHVzID09PSAnY2FuY2VsbGVkJyB8fCBjYW1wYWlnbi5zdGF0dXMgPT09ICdkZWxldGVkJyB8fCBjYW1wYWlnbi5zdGF0dXMgPT09ICdwYXVzZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgZXJyb3I6ICdDYW5ub3QgcmV0cnkgY29udGFjdHMgZm9yIGNhbmNlbGxlZC9kZWxldGVkL3BhdXNlZCBjYW1wYWlnbicgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEVuc3VyZSBhIFJlZGlzIGNhbXBhaWduIGRlZmluaXRpb24gZXhpc3RzICh3b3JrZXIgcmVxdWlyZXMgaXQpXHJcbiAgICAgIGNvbnN0IGhhc0RlZiA9IGF3YWl0IGVuc3VyZUNhbXBhaWduRGVmaW5pdGlvbihpZCwgY2FtcGFpZ24pO1xyXG4gICAgICBpZiAoIWhhc0RlZikge1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7IGVycm9yOiAnTWlzc2luZyBjYW1wYWlnbiBkZWZpbml0aW9uIGluIFJlZGlzIGFuZCB1bmFibGUgdG8gY29uc3RydWN0IG9uZSBmcm9tIGNhbXBhaWduIGRvY3VtZW50LiBSZXRyeSBjYW5ub3QgcHJvY2VlZC4nIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBmaW5kIGZhaWxlZCBjb250YWN0cyB3aXRoIGF0dGVtcHRzIDwgTUFYX0FUVEVNUFRTIEFORCB3aGVyZSBiZ0F0dGVtcHRzID49IE1BWF9BVFRFTVBUUyAobWVhbmluZyBiYWNrZ3JvdW5kIGN5Y2xlIGZpbmlzaGVkKVxyXG4gICAgICAvLyBJZiBiZ0F0dGVtcHRzIGlzIG1pc3NpbmcgKHVuZGVmaW5lZC9udWxsKSwgdHJlYXQgaXQgYXMgZmluaXNoZWQgKGNvbnNlcnZhdGl2ZSkuIEJ1dCBwcmVmZXIgZXhwbGljaXQgPj0uXHJcbiAgICAgIGNvbnN0IGZpbHRlcjogYW55ID0ge1xyXG4gICAgICAgIGNhbXBhaWduSWQ6IGNhbXBhaWduT2JqZWN0SWQsXHJcbiAgICAgICAgc3RhdHVzOiAnZmFpbGVkJyxcclxuICAgICAgICBhdHRlbXB0czogeyAkbHQ6IE1BWF9BVFRFTVBUUyB9LFxyXG4gICAgICAgICRvcjogW1xyXG4gICAgICAgICAgeyBiZ0F0dGVtcHRzOiB7ICRleGlzdHM6IGZhbHNlIH0gfSxcclxuICAgICAgICAgIHsgYmdBdHRlbXB0czogeyAkZ3RlOiBNQVhfQVRURU1QVFMgfSB9LFxyXG4gICAgICAgIF0sXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCBmYWlsZWREb2NzID0gYXdhaXQgZGJcclxuICAgICAgICAuY29sbGVjdGlvbignY2FtcGFpZ25fY29udGFjdHMnKVxyXG4gICAgICAgIC5maW5kKGZpbHRlciwgeyBwcm9qZWN0aW9uOiB7IF9pZDogMSwgY29udGFjdElkOiAxLCBzdGVwOiAxIH0gfSlcclxuICAgICAgICAudG9BcnJheSgpO1xyXG5cclxuICAgICAgY29uc3QgdG9SZXRyeUNvdW50ID0gZmFpbGVkRG9jcy5sZW5ndGg7XHJcbiAgICAgIGlmICh0b1JldHJ5Q291bnQgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oeyBvazogdHJ1ZSwgcmV0cmllZDogMCwgbWVzc2FnZTogJ05vIGVsaWdpYmxlIGZhaWxlZCBjb250YWN0cyB0byByZXRyeSAoZWl0aGVyIG5vbmUgZmFpbGVkLCByZWFjaGVkIG1heCBhdHRlbXB0cywgb3IgYmFja2dyb3VuZCByZXRyaWVzIHN0aWxsIGluIHByb2dyZXNzKS4nIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBzZXJ2ZXItc2lkZSBjYXAgZW5mb3JjZW1lbnRcclxuICAgICAgaWYgKHRvUmV0cnlDb3VudCA+IEJBVENIX1JFVFJZX0xJTUlUKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHtcclxuICAgICAgICAgIGVycm9yOiAnQmF0Y2ggcmV0cnkgZXhjZWVkcyBzZXJ2ZXIgbGltaXQnLFxyXG4gICAgICAgICAgbWVzc2FnZTogYFRyeWluZyB0byByZXRyeSAke3RvUmV0cnlDb3VudH0gY29udGFjdHMgZXhjZWVkcyBzZXJ2ZXIgY2FwIG9mICR7QkFUQ0hfUkVUUllfTElNSVR9LiBVc2UgcGFnaW5hdGlvbiB0byByZXRyeSBpbiBzbWFsbGVyIGJhdGNoZXMuYCxcclxuICAgICAgICAgIHRvUmV0cnlDb3VudCxcclxuICAgICAgICAgIGxpbWl0OiBCQVRDSF9SRVRSWV9MSU1JVCxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQXRvbWljYWxseSBtYXJrIHRoZW0gcGVuZGluZyBhbmQgaW5jcmVtZW50IGNvcmUgYGF0dGVtcHRzYCBhbmQgcmVzZXQgYmdBdHRlbXB0c1xyXG4gICAgICBjb25zdCBpZHMgPSBmYWlsZWREb2NzLm1hcChkID0+IGQuX2lkKTtcclxuICAgICAgY29uc3QgdXBkYXRlUmVzdWx0ID0gYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25fY29udGFjdHMnKS51cGRhdGVNYW55KFxyXG4gICAgICAgIHsgX2lkOiB7ICRpbjogaWRzIH0gfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAkc2V0OiB7IHN0YXR1czogJ3BlbmRpbmcnLCBsYXN0RXJyb3I6IG51bGwsIGJnQXR0ZW1wdHM6IDAgfSxcclxuICAgICAgICAgICRpbmM6IHsgYXR0ZW1wdHM6IDEgfSxcclxuICAgICAgICB9XHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjb25zdCB1cGRhdGVkID0gdXBkYXRlUmVzdWx0Lm1vZGlmaWVkQ291bnQgPz8gMDtcclxuXHJcbiAgICAgIC8vIEVucXVldWUgam9icyAoYmF0Y2gpLCBlbnN1cmUgZWFjaCBqb2IgaGFzIE1RIGF0dGVtcHRzL2JhY2tvZmYgc2V0XHJcbiAgICAgIGNvbnN0IGpvYnM6IFByb21pc2U8YW55PltdID0gW107XHJcbiAgICAgIGNvbnN0IENIVU5LID0gMjAwOyAvLyByZWFzb25hYmxlIGNodW5raW5nXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmFpbGVkRG9jcy5sZW5ndGg7IGkgKz0gQ0hVTkspIHtcclxuICAgICAgICBjb25zdCBjaHVuayA9IGZhaWxlZERvY3Muc2xpY2UoaSwgaSArIENIVU5LKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGRvYyBvZiBjaHVuaykge1xyXG4gICAgICAgICAgY29uc3QgY29udGFjdE9iaklkID0gZG9jLmNvbnRhY3RJZCA/IGRvYy5jb250YWN0SWQgOiBkb2MuX2lkO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGRvYy5zdGVwKSB7XHJcbiAgICAgICAgICAgICAgam9icy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgcXVldWUuYWRkKFxyXG4gICAgICAgICAgICAgICAgICAnZm9sbG93dXAnLFxyXG4gICAgICAgICAgICAgICAgICB7IGNhbXBhaWduSWQ6IGlkLCBjb250YWN0SWQ6IGNvbnRhY3RPYmpJZC50b1N0cmluZyA/IGNvbnRhY3RPYmpJZC50b1N0cmluZygpIDogU3RyaW5nKGNvbnRhY3RPYmpJZCksIHN0ZXA6IGRvYy5zdGVwIH0sXHJcbiAgICAgICAgICAgICAgICAgIHsgcmVtb3ZlT25Db21wbGV0ZTogdHJ1ZSwgcmVtb3ZlT25GYWlsOiB0cnVlLCBhdHRlbXB0czogTUFYX0FUVEVNUFRTLCBiYWNrb2ZmOiB7IHR5cGU6ICdleHBvbmVudGlhbCcsIGRlbGF5OiA2MF8wMDAgfSB9XHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBqb2JzLnB1c2goXHJcbiAgICAgICAgICAgICAgICBxdWV1ZS5hZGQoXHJcbiAgICAgICAgICAgICAgICAgICdpbml0aWFsJyxcclxuICAgICAgICAgICAgICAgICAgeyBjYW1wYWlnbklkOiBpZCwgY29udGFjdElkOiBjb250YWN0T2JqSWQudG9TdHJpbmcgPyBjb250YWN0T2JqSWQudG9TdHJpbmcoKSA6IFN0cmluZyhjb250YWN0T2JqSWQpIH0sXHJcbiAgICAgICAgICAgICAgICAgIHsgcmVtb3ZlT25Db21wbGV0ZTogdHJ1ZSwgcmVtb3ZlT25GYWlsOiB0cnVlLCBhdHRlbXB0czogTUFYX0FUVEVNUFRTLCBiYWNrb2ZmOiB7IHR5cGU6ICdleHBvbmVudGlhbCcsIGRlbGF5OiA2MF8wMDAgfSB9XHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBxdWV1ZSBqb2IgZm9yIHJldHJ5RmFpbGVkIGNodW5rIGl0ZW0nLCBlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFdhaXQgZm9yIGVucXVldWVzIChiZXN0LWVmZm9ydClcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChqb2JzKTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignU29tZSBxdWV1ZS5hZGQgY2FsbHMgZmFpbGVkIGR1cmluZyByZXRyeUZhaWxlZCcsIGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBVcGRhdGUgcmVkaXMgY291bnRlcnM6IGRlY3JlYXNlIGZhaWxlZCBieSB1cGRhdGVkIChiZXN0LWVmZm9ydCwgYnV0IGF2b2lkIG5lZ2F0aXZlKVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRGYWlsZWQgPSBhd2FpdCBzYWZlR2V0TWV0YUludChyZWRpc0tleSwgJ2ZhaWxlZCcpO1xyXG4gICAgICAgIGNvbnN0IGRlYyA9IE1hdGgubWluKHVwZGF0ZWQsIGN1cnJlbnRGYWlsZWQpO1xyXG4gICAgICAgIGlmIChkZWMgPiAwKSB7XHJcbiAgICAgICAgICBhd2FpdCByZWRpcy5oaW5jcmJ5KHJlZGlzS2V5LCAnZmFpbGVkJywgLWRlYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gdXBkYXRlIHJlZGlzIGNvdW50ZXJzIGR1cmluZyByZXRyeUZhaWxlZCcsIGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBbHNvIGNvcnJlY3QgcHJvY2Vzc2VkIGNvdW50ZXIgYmVjYXVzZSB3ZSBhcmUgbW92aW5nIGZpbmFsIGZhaWxlZCAtPiBwZW5kaW5nIChwcm9jZXNzZWQgc2hvdWxkIGRyb3ApXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFByb2Nlc3NlZCA9IGF3YWl0IHNhZmVHZXRNZXRhSW50KHJlZGlzS2V5LCAncHJvY2Vzc2VkJyk7XHJcbiAgICAgICAgY29uc3QgZGVjUHJvYyA9IE1hdGgubWluKHVwZGF0ZWQsIGN1cnJlbnRQcm9jZXNzZWQpO1xyXG4gICAgICAgIGlmIChkZWNQcm9jID4gMCkge1xyXG4gICAgICAgICAgYXdhaXQgcmVkaXMuaGluY3JieShyZWRpc0tleSwgJ3Byb2Nlc3NlZCcsIC1kZWNQcm9jKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byB1cGRhdGUgcHJvY2Vzc2VkIGNvdW50ZXIgZHVyaW5nIHJldHJ5RmFpbGVkJywgZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFB1Ymxpc2ggY29udGFjdC1sZXZlbCB1cGRhdGVzIGZvciBlYWNoIHJldHJpZWQgY29udGFjdCAoYmVzdC1lZmZvcnQpXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBkb2Mgb2YgZmFpbGVkRG9jcykge1xyXG4gICAgICAgICAgY29uc3QgY2lkID0gZG9jLmNvbnRhY3RJZCA/IChkb2MuY29udGFjdElkLnRvU3RyaW5nID8gZG9jLmNvbnRhY3RJZC50b1N0cmluZygpIDogU3RyaW5nKGRvYy5jb250YWN0SWQpKSA6IChkb2MuX2lkLnRvU3RyaW5nID8gZG9jLl9pZC50b1N0cmluZygpIDogU3RyaW5nKGRvYy5faWQpKTtcclxuICAgICAgICAgIGF3YWl0IHNhZmVQdWJsaXNoKGBjYW1wYWlnbjoke2lkfTpjb250YWN0X3VwZGF0ZWAsIHsgY29udGFjdElkOiBjaWQsIHN0YXR1czogJ3BlbmRpbmcnLCBiZ0F0dGVtcHRzOiAwLCBhdHRlbXB0czogMSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKF8pIHtcclxuICAgICAgICAvLyBpZ25vcmUgcHVibGlzaCBlcnJvcnNcclxuICAgICAgfVxyXG5cclxuICAgICAgYXdhaXQgc2FmZVB1Ymxpc2goJ2NhbXBhaWduOm5ldycsIHsgaWQsIGFjdGlvbjogJ3JldHJ5RmFpbGVkJywgcmV0cmllZDogdXBkYXRlZCB9KTtcclxuXHJcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7IG9rOiB0cnVlLCByZXRyaWVkOiB1cGRhdGVkLCBhdHRlbXB0ZWRFbnF1ZXVlOiB0b1JldHJ5Q291bnQgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQUNUSU9OOiBSZXRyeSBhIHNpbmdsZSBmYWlsZWQgY29udGFjdCBieSBjb250YWN0SWRcclxuICAgIGlmIChhY3Rpb24gPT09ICdyZXRyeUNvbnRhY3QnKSB7XHJcbiAgICAgIGlmICghY29udGFjdElkIHx8IHR5cGVvZiBjb250YWN0SWQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgZXJyb3I6ICdNaXNzaW5nIGNvbnRhY3RJZCBmb3IgcmV0cnlDb250YWN0JyB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGlzYWxsb3cgcmV0cnlpbmcgaWYgY2FtcGFpZ24gaXMgY2FuY2VsbGVkL2RlbGV0ZWQvcGF1c2VkXHJcbiAgICAgIGlmIChjYW1wYWlnbi5zdGF0dXMgPT09ICdjYW5jZWxsZWQnIHx8IGNhbXBhaWduLnN0YXR1cyA9PT0gJ2RlbGV0ZWQnIHx8IGNhbXBhaWduLnN0YXR1cyA9PT0gJ3BhdXNlZCcpIHtcclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBlcnJvcjogJ0Nhbm5vdCByZXRyeSBjb250YWN0cyBmb3IgY2FuY2VsbGVkL2RlbGV0ZWQvcGF1c2VkIGNhbXBhaWduJyB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRW5zdXJlIGEgUmVkaXMgY2FtcGFpZ24gZGVmaW5pdGlvbiBleGlzdHMgKHdvcmtlciByZXF1aXJlcyBpdClcclxuICAgICAgY29uc3QgaGFzRGVmID0gYXdhaXQgZW5zdXJlQ2FtcGFpZ25EZWZpbml0aW9uKGlkLCBjYW1wYWlnbik7XHJcbiAgICAgIGlmICghaGFzRGVmKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgZXJyb3I6ICdNaXNzaW5nIGNhbXBhaWduIGRlZmluaXRpb24gaW4gUmVkaXMgYW5kIHVuYWJsZSB0byBjb25zdHJ1Y3Qgb25lIGZyb20gY2FtcGFpZ24gZG9jdW1lbnQuIFJldHJ5IGNhbm5vdCBwcm9jZWVkLicgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEZpbmQgdGhlIGxlZGdlciByb3dcclxuICAgICAgbGV0IGNvbnRhY3RPYmpJZDtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyB0cnkgcGFyc2UgYXMgT2JqZWN0SWQgZmlyc3RcclxuICAgICAgICBjb250YWN0T2JqSWQgPSBuZXcgT2JqZWN0SWQoY29udGFjdElkKTtcclxuICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgLy8gZmFsbGJhY2s6IHVzZSByYXcgc3RyaW5nXHJcbiAgICAgICAgY29udGFjdE9iaklkID0gY29udGFjdElkO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkb2MgPSBhd2FpdCBkYi5jb2xsZWN0aW9uKCdjYW1wYWlnbl9jb250YWN0cycpLmZpbmRPbmUoe1xyXG4gICAgICAgIGNhbXBhaWduSWQ6IGNhbXBhaWduT2JqZWN0SWQsXHJcbiAgICAgICAgY29udGFjdElkOiBjb250YWN0T2JqSWQsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCFkb2MpIHtcclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDQpLmpzb24oeyBlcnJvcjogJ0NvbnRhY3QgbGVkZ2VyIHJvdyBub3QgZm91bmQgZm9yIGNhbXBhaWduJyB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGRvYy5zdGF0dXMgIT09ICdmYWlsZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgZXJyb3I6ICdDb250YWN0IGlzIG5vdCBpbiBmYWlsZWQgc3RhdGUnIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoKGRvYy5hdHRlbXB0cyB8fCAwKSA+PSBNQVhfQVRURU1QVFMpIHtcclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBlcnJvcjogJ0NvbnRhY3QgaGFzIHJlYWNoZWQgbWF4IG1hbnVhbCBhdHRlbXB0cyBhbmQgY2Fubm90IGJlIHJldHJpZWQnIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBQcmV2ZW50IG1hbnVhbCByZXRyeSB3aGlsZSBCdWxsTVEgYmFja2dyb3VuZCByZXRyaWVzIGFyZSBzdGlsbCBydW5uaW5nIGZvciB0aGlzIGNvbnRhY3RcclxuICAgICAgLy8gUmVxdWlyZSBiZ0F0dGVtcHRzID49IE1BWF9BVFRFTVBUUyAob3IgbWlzc2luZykgYmVmb3JlIGFsbG93aW5nIG1hbnVhbCByZXRyeVxyXG4gICAgICBjb25zdCBiZ0RvbmUgPSAodHlwZW9mIGRvYy5iZ0F0dGVtcHRzID09PSAnbnVtYmVyJyA/IGRvYy5iZ0F0dGVtcHRzID49IE1BWF9BVFRFTVBUUyA6IHRydWUpO1xyXG4gICAgICBpZiAoIWJnRG9uZSkge1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IGVycm9yOiAnQmFja2dyb3VuZCByZXRyaWVzIGFyZSBzdGlsbCBpbiBwcm9ncmVzcyBmb3IgdGhpcyBjb250YWN0LiBQbGVhc2Ugd2FpdCB1bnRpbCB0aGUgYmFja2dyb3VuZCByZXRyeSBjeWNsZSBjb21wbGV0ZXMuJyB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVXBkYXRlIHNpbmdsZSBkb2MgdG8gcGVuZGluZywgaW5jcmVtZW50IGNvcmUgYXR0ZW1wdHMsIHJlc2V0IGJnQXR0ZW1wdHNcclxuICAgICAgYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25fY29udGFjdHMnKS51cGRhdGVPbmUoXHJcbiAgICAgICAgeyBfaWQ6IGRvYy5faWQgfSxcclxuICAgICAgICB7ICRzZXQ6IHsgc3RhdHVzOiAncGVuZGluZycsIGxhc3RFcnJvcjogbnVsbCwgYmdBdHRlbXB0czogMCB9LCAkaW5jOiB7IGF0dGVtcHRzOiAxIH0gfVxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gRW5xdWV1ZSBhcHByb3ByaWF0ZSBqb2IgKHVzZSBkb2Muc3RlcCBpZiBwcmVzZW50KSBhbmQgZW5zdXJlIE1RIGF0dGVtcHRzL2JhY2tvZmYgYXJlIHNldFxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmIChkb2Muc3RlcCkge1xyXG4gICAgICAgICAgYXdhaXQgcXVldWUuYWRkKFxyXG4gICAgICAgICAgICAnZm9sbG93dXAnLFxyXG4gICAgICAgICAgICB7IGNhbXBhaWduSWQ6IGlkLCBjb250YWN0SWQ6IGNvbnRhY3RPYmpJZC50b1N0cmluZyA/IGNvbnRhY3RPYmpJZC50b1N0cmluZygpIDogU3RyaW5nKGNvbnRhY3RPYmpJZCksIHN0ZXA6IGRvYy5zdGVwIH0sXHJcbiAgICAgICAgICAgIHsgcmVtb3ZlT25Db21wbGV0ZTogdHJ1ZSwgcmVtb3ZlT25GYWlsOiB0cnVlLCBhdHRlbXB0czogTUFYX0FUVEVNUFRTLCBiYWNrb2ZmOiB7IHR5cGU6ICdleHBvbmVudGlhbCcsIGRlbGF5OiA2MF8wMDAgfSB9XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhd2FpdCBxdWV1ZS5hZGQoXHJcbiAgICAgICAgICAgICdpbml0aWFsJyxcclxuICAgICAgICAgICAgeyBjYW1wYWlnbklkOiBpZCwgY29udGFjdElkOiBjb250YWN0T2JqSWQudG9TdHJpbmcgPyBjb250YWN0T2JqSWQudG9TdHJpbmcoKSA6IFN0cmluZyhjb250YWN0T2JqSWQpIH0sXHJcbiAgICAgICAgICAgIHsgcmVtb3ZlT25Db21wbGV0ZTogdHJ1ZSwgcmVtb3ZlT25GYWlsOiB0cnVlLCBhdHRlbXB0czogTUFYX0FUVEVNUFRTLCBiYWNrb2ZmOiB7IHR5cGU6ICdleHBvbmVudGlhbCcsIGRlbGF5OiA2MF8wMDAgfSB9XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGVucXVldWUgcmV0cnkgam9iIGZvciBjb250YWN0JywgZSk7XHJcbiAgICAgICAgLy8gUm9sbGJhY2s6IHRyeSB0byByZXZlcnQgdGhlIGxlZGdlciByb3cgY2hhbmdlcyAoYmVzdC1lZmZvcnQpXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWduX2NvbnRhY3RzJykudXBkYXRlT25lKFxyXG4gICAgICAgICAgICB7IF9pZDogZG9jLl9pZCB9LFxyXG4gICAgICAgICAgICB7ICRzZXQ6IHsgc3RhdHVzOiAnZmFpbGVkJywgbGFzdEVycm9yOiAnZW5xdWV1ZS1mYWlsZWQnIH0sICRpbmM6IHsgYXR0ZW1wdHM6IC0xIH0sICRzZXQ6IHsgYmdBdHRlbXB0czogZG9jLmJnQXR0ZW1wdHMgPz8gMCB9IH0gYXMgYW55XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gY2F0Y2ggKF8pIHt9XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgZXJyb3I6ICdGYWlsZWQgdG8gZW5xdWV1ZSByZXRyeSBqb2InIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBVcGRhdGUgcmVkaXMgY291bnRlcnM6IGRlY3JlYXNlIGZhaWxlZCBieSAxIGlmIHBvc3NpYmxlICh3ZSBtb3ZlZCBpdCBmcm9tIGZhaWxlZCAtPiBwZW5kaW5nKVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRGYWlsZWQgPSBhd2FpdCBzYWZlR2V0TWV0YUludChyZWRpc0tleSwgJ2ZhaWxlZCcpO1xyXG4gICAgICAgIGlmIChjdXJyZW50RmFpbGVkID4gMCkge1xyXG4gICAgICAgICAgYXdhaXQgcmVkaXMuaGluY3JieShyZWRpc0tleSwgJ2ZhaWxlZCcsIC0xKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byB1cGRhdGUgcmVkaXMgY291bnRlcnMgZHVyaW5nIHJldHJ5Q29udGFjdCcsIGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBbHNvIGRlY3JlbWVudCBwcm9jZXNzZWQgc28gdG90YWxzIGFsaWduICh3ZSBhcmUgdW4tZmluYWxpemluZyBhIGNvbnRhY3QpXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFByb2Nlc3NlZCA9IGF3YWl0IHNhZmVHZXRNZXRhSW50KHJlZGlzS2V5LCAncHJvY2Vzc2VkJyk7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRQcm9jZXNzZWQgPiAwKSB7XHJcbiAgICAgICAgICBhd2FpdCByZWRpcy5oaW5jcmJ5KHJlZGlzS2V5LCAncHJvY2Vzc2VkJywgLTEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHVwZGF0ZSBwcm9jZXNzZWQgY291bnRlciBkdXJpbmcgcmV0cnlDb250YWN0JywgZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFB1Ymxpc2ggY29udGFjdCB1cGRhdGVcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBjaWRTdHIgPSBjb250YWN0T2JqSWQudG9TdHJpbmcgPyBjb250YWN0T2JqSWQudG9TdHJpbmcoKSA6IFN0cmluZyhjb250YWN0T2JqSWQpO1xyXG4gICAgICAgIGF3YWl0IHNhZmVQdWJsaXNoKGBjYW1wYWlnbjoke2lkfTpjb250YWN0X3VwZGF0ZWAsIHsgY29udGFjdElkOiBjaWRTdHIsIHN0YXR1czogJ3BlbmRpbmcnLCBhdHRlbXB0czogKGRvYy5hdHRlbXB0cyB8fCAwKSArIDEsIGJnQXR0ZW1wdHM6IDAgfSk7XHJcbiAgICAgIH0gY2F0Y2ggKF8pIHt9XHJcblxyXG4gICAgICBhd2FpdCBzYWZlUHVibGlzaCgnY2FtcGFpZ246bmV3JywgeyBpZCwgYWN0aW9uOiAncmV0cnlDb250YWN0JywgY29udGFjdElkIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHsgb2s6IHRydWUsIHJldHJpZWQ6IDEsIGNvbnRhY3RJZCB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBQ1RJT046IE1hbnVhbCBIb2xkIChNYW51YWwgT3ZlcnJpZGUpIC0gcGxhY2UgY29udGFjdCBpbnRvIGEgaHVtYW4tY29udHJvbGxlZCBob2xkIHN0YXRlXHJcbiAgICBpZiAoYWN0aW9uID09PSAnbWFudWFsSG9sZCcpIHtcclxuICAgICAgaWYgKCFjb250YWN0SWQgfHwgdHlwZW9mIGNvbnRhY3RJZCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBlcnJvcjogJ01pc3NpbmcgY29udGFjdElkIGZvciBtYW51YWxIb2xkJyB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRmluZCBsZWRnZXIgcm93XHJcbiAgICAgIGxldCBjb250YWN0T2JqSWQ7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29udGFjdE9iaklkID0gbmV3IE9iamVjdElkKGNvbnRhY3RJZCk7XHJcbiAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgIGNvbnRhY3RPYmpJZCA9IGNvbnRhY3RJZDtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZG9jID0gYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25fY29udGFjdHMnKS5maW5kT25lKHtcclxuICAgICAgICBjYW1wYWlnbklkOiBjYW1wYWlnbk9iamVjdElkLFxyXG4gICAgICAgIGNvbnRhY3RJZDogY29udGFjdE9iaklkLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmICghZG9jKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA0KS5qc29uKHsgZXJyb3I6ICdDb250YWN0IGxlZGdlciByb3cgbm90IGZvdW5kIGZvciBjYW1wYWlnbicgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIElmIGFscmVhZHkgaW4gbWFudWFsX2hvbGQsIG5vLW9wXHJcbiAgICAgIGlmIChkb2Muc3RhdHVzID09PSAnbWFudWFsX2hvbGQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHsgb2s6IHRydWUsIG1lc3NhZ2U6ICdDb250YWN0IGFscmVhZHkgdW5kZXIgbWFudWFsIGhvbGQnIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBwcmV2U3RhdHVzID0gZG9jLnN0YXR1cyA/PyBudWxsO1xyXG4gICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xyXG5cclxuICAgICAgLy8gUmVtb3ZlIGFueSBxdWV1ZWQgam9icyBmb3IgdGhpcyBjb250YWN0IChiZXN0LWVmZm9ydClcclxuICAgICAgY29uc3QgY2lkU3RyID0gY29udGFjdE9iaklkLnRvU3RyaW5nID8gY29udGFjdE9iaklkLnRvU3RyaW5nKCkgOiBTdHJpbmcoY29udGFjdE9iaklkKTtcclxuICAgICAgY29uc3QgcmVtb3ZlZEpvYnMgPSBhd2FpdCByZW1vdmVRdWV1ZWRKb2JzRm9yQ29udGFjdChpZCwgY2lkU3RyKTtcclxuXHJcbiAgICAgIC8vIEF0b21pY2FsbHkgdXBkYXRlIGxlZGdlcjogc2V0IHN0YXR1cyBtYW51YWxfaG9sZCBhbmQgcHVzaCBoaXN0b3J5IGVudHJ5XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25fY29udGFjdHMnKS51cGRhdGVPbmUoXHJcbiAgICAgICAgICB7IF9pZDogZG9jLl9pZCB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICAkc2V0OiB7IHN0YXR1czogJ21hbnVhbF9ob2xkJywgbGFzdEVycm9yOiBudWxsIH0sXHJcbiAgICAgICAgICAgICRwdXNoOiB7XHJcbiAgICAgICAgICAgICAgbWFudWFsSGlzdG9yeToge1xyXG4gICAgICAgICAgICAgICAgYXQ6IG5vdyxcclxuICAgICAgICAgICAgICAgIGJ5OiAndXNlcicsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdob2xkJyxcclxuICAgICAgICAgICAgICAgIHByZXZTdGF0dXMsXHJcbiAgICAgICAgICAgICAgICByZW1vdmVkSm9iczogcmVtb3ZlZEpvYnMsXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHNldCBtYW51YWxfaG9sZCBvbiBsZWRnZXIgcm93JywgZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgZXJyb3I6ICdmYWlsZWQtdG8tYXBwbHktbWFudWFsLWhvbGQnIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBQdWJsaXNoIGNvbnRhY3QtbGV2ZWwgdXBkYXRlIGZvciBVSVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IHNhZmVQdWJsaXNoKGBjYW1wYWlnbjoke2lkfTpjb250YWN0X3VwZGF0ZWAsIHtcclxuICAgICAgICAgIGNvbnRhY3RJZDogY2lkU3RyLFxyXG4gICAgICAgICAgc3RhdHVzOiAnbWFudWFsX2hvbGQnLFxyXG4gICAgICAgICAgcHJldlN0YXR1cyxcclxuICAgICAgICAgIG1hbnVhbEFjdGlvbkF0OiBub3cudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgIHJlbW92ZWRKb2JzLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGNhdGNoIChfKSB7IH1cclxuXHJcbiAgICAgIGF3YWl0IHNhZmVQdWJsaXNoKCdjYW1wYWlnbjpuZXcnLCB7IGlkLCBhY3Rpb246ICdtYW51YWxIb2xkJywgY29udGFjdElkOiBjaWRTdHIgfSk7XHJcblxyXG4gICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oeyBvazogdHJ1ZSwgYWN0aW9uOiAnbWFudWFsX2hvbGQnLCBjb250YWN0SWQ6IGNpZFN0ciwgcmVtb3ZlZEpvYnMgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQUNUSU9OOiBNYW51YWwgVW5kbyAocmVsZWFzZSBwcmV2aW91c2x5IGhlbGQgY29udGFjdClcclxuICAgIGlmIChhY3Rpb24gPT09ICdtYW51YWxVbmRvJykge1xyXG4gICAgICBpZiAoIWNvbnRhY3RJZCB8fCB0eXBlb2YgY29udGFjdElkICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IGVycm9yOiAnTWlzc2luZyBjb250YWN0SWQgZm9yIG1hbnVhbFVuZG8nIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBGaW5kIGxlZGdlciByb3dcclxuICAgICAgbGV0IGNvbnRhY3RPYmpJZDI7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29udGFjdE9iaklkMiA9IG5ldyBPYmplY3RJZChjb250YWN0SWQpO1xyXG4gICAgICB9IGNhdGNoIHtcclxuICAgICAgICBjb250YWN0T2JqSWQyID0gY29udGFjdElkO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkb2MyID0gYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25fY29udGFjdHMnKS5maW5kT25lKHtcclxuICAgICAgICBjYW1wYWlnbklkOiBjYW1wYWlnbk9iamVjdElkLFxyXG4gICAgICAgIGNvbnRhY3RJZDogY29udGFjdE9iaklkMixcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoIWRvYzIpIHtcclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDQpLmpzb24oeyBlcnJvcjogJ0NvbnRhY3QgbGVkZ2VyIHJvdyBub3QgZm91bmQgZm9yIGNhbXBhaWduJyB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGRvYzIuc3RhdHVzICE9PSAnbWFudWFsX2hvbGQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgZXJyb3I6ICdDb250YWN0IGlzIG5vdCB1bmRlciBtYW51YWwgaG9sZCcgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGhpc3RvcnkgPSBBcnJheS5pc0FycmF5KGRvYzIubWFudWFsSGlzdG9yeSkgPyBkb2MyLm1hbnVhbEhpc3RvcnkgOiBbXTtcclxuICAgICAgLy8gRmluZCB0aGUgbGFzdCBob2xkIGVudHJ5IHRvIGRldGVybWluZSBwcmV2aW91cyBzdGF0dXMgdG8gcmVzdG9yZVxyXG4gICAgICBsZXQgbGFzdEhvbGRFbnRyeTogYW55ID0gbnVsbDtcclxuICAgICAgZm9yIChsZXQgaSA9IGhpc3RvcnkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBjb25zdCBoID0gaGlzdG9yeVtpXTtcclxuICAgICAgICBpZiAoaCAmJiBoLmFjdGlvbiA9PT0gJ2hvbGQnKSB7XHJcbiAgICAgICAgICBsYXN0SG9sZEVudHJ5ID0gaDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFsYXN0SG9sZEVudHJ5KSB7XHJcbiAgICAgICAgLy8gZmFsbGJhY2s6IGlmIG5vIGhpc3RvcnksIHJlc3RvcmUgdG8gJ3BlbmRpbmcnIGNvbnNlcnZhdGl2ZWx5XHJcbiAgICAgICAgbGFzdEhvbGRFbnRyeSA9IHsgcHJldlN0YXR1czogJ3BlbmRpbmcnLCBhdDogbnVsbCB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCByZXN0b3JlVG8gPSBsYXN0SG9sZEVudHJ5LnByZXZTdGF0dXMgPz8gJ3BlbmRpbmcnO1xyXG4gICAgICBjb25zdCBub3cyID0gbmV3IERhdGUoKTtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBsZWRnZXI6IHNldCBzdGF0dXMgYmFjayB0byByZXN0b3JlVG8gYW5kIHB1c2ggYSByZWxlYXNlIGhpc3RvcnkgZW50cnkuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25fY29udGFjdHMnKS51cGRhdGVPbmUoXHJcbiAgICAgICAgICB7IF9pZDogZG9jMi5faWQgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgJHNldDogeyBzdGF0dXM6IHJlc3RvcmVUbywgbGFzdEVycm9yOiBudWxsIH0sXHJcbiAgICAgICAgICAgICRwdXNoOiB7XHJcbiAgICAgICAgICAgICAgbWFudWFsSGlzdG9yeToge1xyXG4gICAgICAgICAgICAgICAgYXQ6IG5vdzIsXHJcbiAgICAgICAgICAgICAgICBieTogJ3VzZXInLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAncmVsZWFzZScsXHJcbiAgICAgICAgICAgICAgICByZXN0b3JlZFRvOiByZXN0b3JlVG8sXHJcbiAgICAgICAgICAgICAgICByZWZIb2xkQXQ6IGxhc3RIb2xkRW50cnkuYXQgPz8gbnVsbCxcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcmVsZWFzZSBtYW51YWxfaG9sZCBvbiBsZWRnZXIgcm93JywgZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgZXJyb3I6ICdmYWlsZWQtdG8tcmVsZWFzZS1tYW51YWwtaG9sZCcgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGNpZFN0cjIgPSBjb250YWN0T2JqSWQyLnRvU3RyaW5nID8gY29udGFjdE9iaklkMi50b1N0cmluZygpIDogU3RyaW5nKGNvbnRhY3RPYmpJZDIpO1xyXG5cclxuICAgICAgLy8gSWYgd2UgcmVzdG9yZWQgdG8gcGVuZGluZywgYXR0ZW1wdCB0byByZS1lbnF1ZXVlIHRoZSBqb2IgKGJlc3QtZWZmb3J0KVxyXG4gICAgICBsZXQgZW5xdWV1ZWQgPSBmYWxzZTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAocmVzdG9yZVRvID09PSAncGVuZGluZycpIHtcclxuICAgICAgICAgIC8vIGRlY2lkZSBqb2IgdHlwZSBiYXNlZCBvbiBkb2MyLnN0ZXAgcHJlc2VuY2VcclxuICAgICAgICAgIGNvbnN0IGNvbnRhY3RPYmpGb3JKb2IgPSBkb2MyLmNvbnRhY3RJZCA/IChkb2MyLmNvbnRhY3RJZC50b1N0cmluZyA/IGRvYzIuY29udGFjdElkLnRvU3RyaW5nKCkgOiBTdHJpbmcoZG9jMi5jb250YWN0SWQpKSA6IChkb2MyLl9pZC50b1N0cmluZyA/IGRvYzIuX2lkLnRvU3RyaW5nKCkgOiBTdHJpbmcoZG9jMi5faWQpKTtcclxuICAgICAgICAgIGlmIChkb2MyLnN0ZXApIHtcclxuICAgICAgICAgICAgYXdhaXQgcXVldWUuYWRkKFxyXG4gICAgICAgICAgICAgICdmb2xsb3d1cCcsXHJcbiAgICAgICAgICAgICAgeyBjYW1wYWlnbklkOiBpZCwgY29udGFjdElkOiBjb250YWN0T2JqRm9ySm9iLCBzdGVwOiBkb2MyLnN0ZXAgfSxcclxuICAgICAgICAgICAgICB7IHJlbW92ZU9uQ29tcGxldGU6IHRydWUsIHJlbW92ZU9uRmFpbDogdHJ1ZSwgYXR0ZW1wdHM6IE1BWF9BVFRFTVBUUywgYmFja29mZjogeyB0eXBlOiAnZXhwb25lbnRpYWwnLCBkZWxheTogNjBfMDAwIH0gfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXdhaXQgcXVldWUuYWRkKFxyXG4gICAgICAgICAgICAgICdpbml0aWFsJyxcclxuICAgICAgICAgICAgICB7IGNhbXBhaWduSWQ6IGlkLCBjb250YWN0SWQ6IGNvbnRhY3RPYmpGb3JKb2IgfSxcclxuICAgICAgICAgICAgICB7IHJlbW92ZU9uQ29tcGxldGU6IHRydWUsIHJlbW92ZU9uRmFpbDogdHJ1ZSwgYXR0ZW1wdHM6IE1BWF9BVFRFTVBUUywgYmFja29mZjogeyB0eXBlOiAnZXhwb25lbnRpYWwnLCBkZWxheTogNjBfMDAwIH0gfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZW5xdWV1ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGVucXVldWUgam9iIHdoZW4gcmVsZWFzaW5nIG1hbnVhbCBob2xkJywgZSk7XHJcbiAgICAgICAgLy8gRG8gbm90IHJldmVydCBzdGF0dXMgY2hhbmdlOyBzdXJmYWNlIGJlc3QtZWZmb3J0IHJlc3VsdCBiZWxvd1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBQdWJsaXNoIGNvbnRhY3QtbGV2ZWwgdXBkYXRlXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgc2FmZVB1Ymxpc2goYGNhbXBhaWduOiR7aWR9OmNvbnRhY3RfdXBkYXRlYCwge1xyXG4gICAgICAgICAgY29udGFjdElkOiBjaWRTdHIyLFxyXG4gICAgICAgICAgc3RhdHVzOiByZXN0b3JlVG8sXHJcbiAgICAgICAgICBtYW51YWxBY3Rpb25BdDogbm93Mi50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgcmVxdWV1ZWQ6IGVucXVldWVkLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGNhdGNoIChfKSB7IH1cclxuXHJcbiAgICAgIGF3YWl0IHNhZmVQdWJsaXNoKCdjYW1wYWlnbjpuZXcnLCB7IGlkLCBhY3Rpb246ICdtYW51YWxVbmRvJywgY29udGFjdElkOiBjaWRTdHIyLCByZXN0b3JlZFRvOiByZXN0b3JlVG8sIHJlcXVldWVkOiBlbnF1ZXVlZCB9KTtcclxuXHJcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7IG9rOiB0cnVlLCBhY3Rpb246ICdtYW51YWxVbmRvJywgY29udGFjdElkOiBjaWRTdHIyLCByZXN0b3JlZFRvOiByZXN0b3JlVG8sIHJlcXVldWVkOiBlbnF1ZXVlZCB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTaG91bGQgbm90IHJlYWNoIGhlcmVcclxuICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IGVycm9yOiAnVW5zdXBwb3J0ZWQgYWN0aW9uJyB9KTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0NhbXBhaWduIGNvbnRyb2wgZXJyb3InLCBlcnIpO1xyXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgZXJyb3I6ICdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3InIH0pO1xyXG4gIH1cclxufSJdLCJuYW1lcyI6WyJjbGllbnRQcm9taXNlIiwicmVkaXMiLCJRdWV1ZSIsIk9iamVjdElkIiwicXVldWUiLCJjb25uZWN0aW9uIiwiTUFYX0FUVEVNUFRTIiwiTnVtYmVyIiwicHJvY2VzcyIsImVudiIsIkJBVENIX1JFVFJZX0xJTUlUIiwiUkVTVU1FX0VOUVVFVUVfTElNSVQiLCJTVEFMRV9TRU5ESU5HX01TIiwic2FmZUhTZXQiLCJrZXkiLCJvYmoiLCJoc2V0IiwiZXJyIiwiY29uc29sZSIsIndhcm4iLCJzYWZlUHVibGlzaCIsImNoYW5uZWwiLCJwYXlsb2FkIiwicHVibGlzaCIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZW1vdmVRdWV1ZWRKb2JzRm9yQ2FtcGFpZ24iLCJjYW1wYWlnbklkIiwiam9icyIsImdldEpvYnMiLCJtYXRjaGVkIiwiZmlsdGVyIiwiaiIsImRhdGEiLCJyZW1vdmUiLCJlIiwiaWQiLCJsZW5ndGgiLCJyZW1vdmVRdWV1ZWRKb2JzRm9yQ29udGFjdCIsImNvbnRhY3RJZCIsIlN0cmluZyIsInJlbW92ZWQiLCJzYWZlR2V0TWV0YUludCIsInJlZGlzS2V5IiwiZmllbGQiLCJ2IiwiaGdldCIsImVuc3VyZUNhbXBhaWduRGVmaW5pdGlvbiIsImNhbXBhaWduRG9jIiwiZXhpc3RpbmciLCJnZXQiLCJidWlsdCIsImRlZmluaXRpb24iLCJpbml0aWFsIiwiZm9sbG93VXBzIiwidGVtcGxhdGUiLCJzdWJqZWN0IiwibmFtZSIsImJvZHkiLCJjb250ZW50IiwidGl0bGUiLCJodG1sIiwic3RlcHMiLCJzYW1wbGUiLCJPYmplY3QiLCJrZXlzIiwic2xpY2UiLCJzZXQiLCJsb2ciLCJnZXRRdWV1ZWRDb250YWN0SWRzRm9yQ2FtcGFpZ24iLCJTZXQiLCJhZGQiLCJoYW5kbGVyIiwicmVxIiwicmVzIiwibWV0aG9kIiwic3RhdHVzIiwianNvbiIsImVycm9yIiwicXVlcnkiLCJhY3Rpb24iLCJjb25maXJtIiwiaW5jbHVkZXMiLCJjbGllbnQiLCJkYiIsImNhbXBhaWduT2JqZWN0SWQiLCJjYW1wYWlnbiIsImNvbGxlY3Rpb24iLCJmaW5kT25lIiwiX2lkIiwib2siLCJtZXNzYWdlIiwidXBkYXRlT25lIiwiJHNldCIsInF1ZXVlZFNldCIsInBlbmRpbmdDdXJzb3IiLCJmaW5kIiwicHJvamVjdGlvbiIsInN0ZXAiLCJsaW1pdCIsInBlbmRpbmciLCJ0b0FycmF5IiwiZW5xdWV1ZVByb21pc2VzIiwiZCIsImNpZCIsInRvU3RyaW5nIiwiaGFzIiwicHVzaCIsInJlbW92ZU9uQ29tcGxldGUiLCJyZW1vdmVPbkZhaWwiLCJhdHRlbXB0cyIsImJhY2tvZmYiLCJ0eXBlIiwiZGVsYXkiLCJQcm9taXNlIiwiYWxsU2V0dGxlZCIsInJlcXVldWVkIiwiY3V0b2ZmIiwiRGF0ZSIsIm5vdyIsInN0YWxlQ3Vyc29yIiwibGFzdEF0dGVtcHRBdCIsIiRsdCIsImJnQXR0ZW1wdHMiLCJzdGFsZURvY3MiLCJpZHMiLCJtYXAiLCJ1cGRhdGVNYW55IiwiJGluIiwibGFzdEVycm9yIiwicXVldWVkU2V0MiIsInJlcXVldWVQcm9taXNlcyIsInVuZGVmaW5lZCIsIl8iLCJyZWNvdmVyZWQiLCJzdGFsZVNlbmRpbmciLCJwcm9qZWN0IiwicGVuZGluZ1Jvd3MiLCJhZ2ciLCJhZ2dyZWdhdGUiLCIkbWF0Y2giLCIkZ3JvdXAiLCJjb3VudCIsIiRzdW0iLCJzZW50IiwiZmFpbGVkIiwiciIsInByb2Nlc3NlZCIsImludGVuZGVkIiwidG90YWxzIiwiY291bnREb2N1bWVudHMiLCJ0b3RhbCIsIm5ld1N0YXR1cyIsImNvbXBsZXRlZEF0Iiwic3RhcnRzV2l0aCIsInVwZGF0ZSIsIiRpbmMiLCJ1cGRhdGVSZXN1bHQiLCJjYW5jZWxsZWRDb3VudCIsIm1vZGlmaWVkQ291bnQiLCJoaW5jcmJ5IiwibWV0YSIsImhnZXRhbGwiLCJwcm9jZXNzZWROb3ciLCJzZW50Tm93IiwiZmFpbGVkTm93IiwicmVtb3ZlZEpvYnMiLCJkZWwiLCJzcmVtIiwiY2FtcGFpZ25EZWwiLCJsZWRnZXJEZWwiLCJhbGwiLCJkZWxldGVPbmUiLCJkZWxldGVNYW55IiwiY2FtcGFpZ25EZWxldGVkIiwiZGVsZXRlZENvdW50IiwibGVkZ2VyRGVsZXRlZCIsImhhc0RlZiIsIiRvciIsIiRleGlzdHMiLCIkZ3RlIiwiZmFpbGVkRG9jcyIsInRvUmV0cnlDb3VudCIsInJldHJpZWQiLCJ1cGRhdGVkIiwiQ0hVTksiLCJpIiwiY2h1bmsiLCJkb2MiLCJjb250YWN0T2JqSWQiLCJjdXJyZW50RmFpbGVkIiwiZGVjIiwiTWF0aCIsIm1pbiIsImN1cnJlbnRQcm9jZXNzZWQiLCJkZWNQcm9jIiwiYXR0ZW1wdGVkRW5xdWV1ZSIsImJnRG9uZSIsImNpZFN0ciIsInByZXZTdGF0dXMiLCIkcHVzaCIsIm1hbnVhbEhpc3RvcnkiLCJhdCIsImJ5IiwibWFudWFsQWN0aW9uQXQiLCJ0b0lTT1N0cmluZyIsImNvbnRhY3RPYmpJZDIiLCJkb2MyIiwiaGlzdG9yeSIsIkFycmF5IiwiaXNBcnJheSIsImxhc3RIb2xkRW50cnkiLCJoIiwicmVzdG9yZVRvIiwibm93MiIsInJlc3RvcmVkVG8iLCJyZWZIb2xkQXQiLCJjaWRTdHIyIiwiZW5xdWV1ZWQiLCJjb250YWN0T2JqRm9ySm9iIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./pages/api/campaign/[id]/control.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fcampaign%2F%5Bid%5D%2Fcontrol&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Ccampaign%5C%5Bid%5D%5Ccontrol.ts&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();