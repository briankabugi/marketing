"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/campaign/[id]/control";
exports.ids = ["pages/api/campaign/[id]/control"];
exports.modules = {

/***/ "bullmq":
/*!*************************!*\
  !*** external "bullmq" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("bullmq");

/***/ }),

/***/ "ioredis":
/*!**************************!*\
  !*** external "ioredis" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("ioredis");

/***/ }),

/***/ "mongodb":
/*!**************************!*\
  !*** external "mongodb" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("mongodb");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fcampaign%2F%5Bid%5D%2Fcontrol&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Ccampaign%5C%5Bid%5D%5Ccontrol.ts&middlewareConfigBase64=e30%3D!":
/*!****************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fcampaign%2F%5Bid%5D%2Fcontrol&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Ccampaign%5C%5Bid%5D%5Ccontrol.ts&middlewareConfigBase64=e30%3D! ***!
  \****************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_campaign_id_control_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages\\api\\campaign\\[id]\\control.ts */ \"(api)/./pages/api/campaign/[id]/control.ts\");\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_campaign_id_control_ts__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_campaign_id_control_ts__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/campaign/[id]/control\",\n        pathname: \"/api/campaign/[id]/control\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _pages_api_campaign_id_control_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRmNhbXBhaWduJTJGJTVCaWQlNUQlMkZjb250cm9sJnByZWZlcnJlZFJlZ2lvbj0mYWJzb2x1dGVQYWdlUGF0aD0uJTJGcGFnZXMlNUNhcGklNUNjYW1wYWlnbiU1QyU1QmlkJTVEJTVDY29udHJvbC50cyZtaWRkbGV3YXJlQ29uZmlnQmFzZTY0PWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdkM7QUFDTDtBQUMxRDtBQUNxRTtBQUNyRTtBQUNBLGlFQUFlLHdFQUFLLENBQUMsOERBQVEsWUFBWSxFQUFDO0FBQzFDO0FBQ08sZUFBZSx3RUFBSyxDQUFDLDhEQUFRO0FBQ3BDO0FBQ08sd0JBQXdCLGdIQUFtQjtBQUNsRDtBQUNBLGNBQWMseUVBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZO0FBQ1osQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldGluZy1tdnAvPzhjNzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFnZXNBUElSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL3BhZ2VzLWFwaS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBob2lzdCB9IGZyb20gXCJuZXh0L2Rpc3QvYnVpbGQvdGVtcGxhdGVzL2hlbHBlcnNcIjtcbi8vIEltcG9ydCB0aGUgdXNlcmxhbmQgY29kZS5cbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIuL3BhZ2VzXFxcXGFwaVxcXFxjYW1wYWlnblxcXFxbaWRdXFxcXGNvbnRyb2wudHNcIjtcbi8vIFJlLWV4cG9ydCB0aGUgaGFuZGxlciAoc2hvdWxkIGJlIHRoZSBkZWZhdWx0IGV4cG9ydCkuXG5leHBvcnQgZGVmYXVsdCBob2lzdCh1c2VybGFuZCwgXCJkZWZhdWx0XCIpO1xuLy8gUmUtZXhwb3J0IGNvbmZpZy5cbmV4cG9ydCBjb25zdCBjb25maWcgPSBob2lzdCh1c2VybGFuZCwgXCJjb25maWdcIik7XG4vLyBDcmVhdGUgYW5kIGV4cG9ydCB0aGUgcm91dGUgbW9kdWxlIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbmV4cG9ydCBjb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBQYWdlc0FQSVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5QQUdFU19BUEksXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9jYW1wYWlnbi9baWRdL2NvbnRyb2xcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9jYW1wYWlnbi9baWRdL2NvbnRyb2xcIixcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBhcmVuJ3QgdXNlZCBpbiBwcm9kdWN0aW9uLlxuICAgICAgICBidW5kbGVQYXRoOiBcIlwiLFxuICAgICAgICBmaWxlbmFtZTogXCJcIlxuICAgIH0sXG4gICAgdXNlcmxhbmRcbn0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdlcy1hcGkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fcampaign%2F%5Bid%5D%2Fcontrol&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Ccampaign%5C%5Bid%5D%5Ccontrol.ts&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./lib/mongo.ts":
/*!**********************!*\
  !*** ./lib/mongo.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mongodb */ \"mongodb\");\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mongodb__WEBPACK_IMPORTED_MODULE_0__);\n// lib/mongo.ts\n\nconst uri = process.env.MONGODB_URI;\nif (!uri) throw new Error(\"MONGODB_URI not set\");\nlet client;\nlet clientPromise;\n// Retry logic in case MongoDB connection fails\nasync function connectWithRetry() {\n    const MAX_RETRIES = 5;\n    let attempts = 0;\n    let lastError = null;\n    while(attempts < MAX_RETRIES){\n        try {\n            const client = new mongodb__WEBPACK_IMPORTED_MODULE_0__.MongoClient(uri, {\n                maxPoolSize: 10,\n                serverSelectionTimeoutMS: 10000,\n                socketTimeoutMS: 45000\n            });\n            await client.connect();\n            return client;\n        } catch (err) {\n            lastError = err;\n            attempts++;\n            console.error(`MongoDB connection failed (attempt ${attempts}/${MAX_RETRIES}):`, err);\n            if (attempts < MAX_RETRIES) {\n                await new Promise((resolve)=>setTimeout(resolve, 5000)); // wait for 5 seconds before retrying\n            }\n        }\n    }\n    // After max retries, throw the last error encountered\n    throw lastError || new Error(\"MongoDB connection failed after maximum retry attempts\");\n}\nif (!global._mongoClientPromise) {\n    global._mongoClientPromise = connectWithRetry();\n    // Optional: log connection events\n    global._mongoClientPromise.then((client)=>{\n        client.on(\"serverOpening\", (event)=>console.log(\"MongoDB server opening\", event));\n        client.on(\"serverClosed\", (event)=>console.warn(\"MongoDB server closed\", event));\n        client.on(\"topologyClosed\", ()=>console.warn(\"MongoDB topology closed\"));\n        client.on(\"topologyOpening\", ()=>console.log(\"MongoDB topology opening\"));\n        client.on(\"error\", (err)=>console.error(\"MongoDB error\", err));\n    }).catch((err)=>{\n        console.error(\"MongoDB client failed to connect after retries\", err);\n    });\n}\nclientPromise = global._mongoClientPromise;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (clientPromise);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9saWIvbW9uZ28udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZUFBZTtBQUN1QjtBQUV0QyxNQUFNQyxNQUFNQyxRQUFRQyxHQUFHLENBQUNDLFdBQVc7QUFDbkMsSUFBSSxDQUFDSCxLQUFLLE1BQU0sSUFBSUksTUFBTTtBQUUxQixJQUFJQztBQUNKLElBQUlDO0FBT0osK0NBQStDO0FBQy9DLGVBQWVDO0lBQ2IsTUFBTUMsY0FBYztJQUNwQixJQUFJQyxXQUFXO0lBQ2YsSUFBSUMsWUFBMEI7SUFFOUIsTUFBT0QsV0FBV0QsWUFBYTtRQUM3QixJQUFJO1lBQ0YsTUFBTUgsU0FBUyxJQUFJTixnREFBV0EsQ0FBQ0MsS0FBSztnQkFDbENXLGFBQWE7Z0JBQ2JDLDBCQUEwQjtnQkFDMUJDLGlCQUFpQjtZQUNuQjtZQUNBLE1BQU1SLE9BQU9TLE9BQU87WUFDcEIsT0FBT1Q7UUFDVCxFQUFFLE9BQU9VLEtBQVU7WUFDakJMLFlBQVlLO1lBQ1pOO1lBQ0FPLFFBQVFDLEtBQUssQ0FBQyxDQUFDLG1DQUFtQyxFQUFFUixTQUFTLENBQUMsRUFBRUQsWUFBWSxFQUFFLENBQUMsRUFBRU87WUFDakYsSUFBSU4sV0FBV0QsYUFBYTtnQkFDMUIsTUFBTSxJQUFJVSxRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTLFFBQVEscUNBQXFDO1lBQ2hHO1FBQ0Y7SUFDRjtJQUVBLHNEQUFzRDtJQUN0RCxNQUFNVCxhQUFhLElBQUlOLE1BQU07QUFDL0I7QUFFQSxJQUFJLENBQUNpQixPQUFPQyxtQkFBbUIsRUFBRTtJQUMvQkQsT0FBT0MsbUJBQW1CLEdBQUdmO0lBRTdCLGtDQUFrQztJQUNsQ2MsT0FBT0MsbUJBQW1CLENBQ3ZCQyxJQUFJLENBQUNsQixDQUFBQTtRQUNKQSxPQUFPbUIsRUFBRSxDQUFDLGlCQUFpQixDQUFDQyxRQUFVVCxRQUFRVSxHQUFHLENBQUMsMEJBQTBCRDtRQUM1RXBCLE9BQU9tQixFQUFFLENBQUMsZ0JBQWdCLENBQUNDLFFBQVVULFFBQVFXLElBQUksQ0FBQyx5QkFBeUJGO1FBQzNFcEIsT0FBT21CLEVBQUUsQ0FBQyxrQkFBa0IsSUFBTVIsUUFBUVcsSUFBSSxDQUFDO1FBQy9DdEIsT0FBT21CLEVBQUUsQ0FBQyxtQkFBbUIsSUFBTVIsUUFBUVUsR0FBRyxDQUFDO1FBQy9DckIsT0FBT21CLEVBQUUsQ0FBQyxTQUFTLENBQUNULE1BQVFDLFFBQVFDLEtBQUssQ0FBQyxpQkFBaUJGO0lBQzdELEdBQ0NhLEtBQUssQ0FBQ2IsQ0FBQUE7UUFDTEMsUUFBUUMsS0FBSyxDQUFDLGtEQUFrREY7SUFDbEU7QUFDSjtBQUVBVCxnQkFBZ0JlLE9BQU9DLG1CQUFtQjtBQUUxQyxpRUFBZWhCLGFBQWFBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRpbmctbXZwLy4vbGliL21vbmdvLnRzPzU3ZmUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbGliL21vbmdvLnRzXHJcbmltcG9ydCB7IE1vbmdvQ2xpZW50IH0gZnJvbSAnbW9uZ29kYic7XHJcblxyXG5jb25zdCB1cmkgPSBwcm9jZXNzLmVudi5NT05HT0RCX1VSSTtcclxuaWYgKCF1cmkpIHRocm93IG5ldyBFcnJvcignTU9OR09EQl9VUkkgbm90IHNldCcpO1xyXG5cclxubGV0IGNsaWVudDogTW9uZ29DbGllbnQ7XHJcbmxldCBjbGllbnRQcm9taXNlOiBQcm9taXNlPE1vbmdvQ2xpZW50PjtcclxuXHJcbmRlY2xhcmUgZ2xvYmFsIHtcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdmFyXHJcbiAgdmFyIF9tb25nb0NsaWVudFByb21pc2U6IFByb21pc2U8TW9uZ29DbGllbnQ+IHwgdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vLyBSZXRyeSBsb2dpYyBpbiBjYXNlIE1vbmdvREIgY29ubmVjdGlvbiBmYWlsc1xyXG5hc3luYyBmdW5jdGlvbiBjb25uZWN0V2l0aFJldHJ5KCk6IFByb21pc2U8TW9uZ29DbGllbnQ+IHtcclxuICBjb25zdCBNQVhfUkVUUklFUyA9IDU7XHJcbiAgbGV0IGF0dGVtcHRzID0gMDtcclxuICBsZXQgbGFzdEVycm9yOiBFcnJvciB8IG51bGwgPSBudWxsO1xyXG5cclxuICB3aGlsZSAoYXR0ZW1wdHMgPCBNQVhfUkVUUklFUykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgY2xpZW50ID0gbmV3IE1vbmdvQ2xpZW50KHVyaSwge1xyXG4gICAgICAgIG1heFBvb2xTaXplOiAxMCxcclxuICAgICAgICBzZXJ2ZXJTZWxlY3Rpb25UaW1lb3V0TVM6IDEwMDAwLFxyXG4gICAgICAgIHNvY2tldFRpbWVvdXRNUzogNDUwMDAsXHJcbiAgICAgIH0pO1xyXG4gICAgICBhd2FpdCBjbGllbnQuY29ubmVjdCgpO1xyXG4gICAgICByZXR1cm4gY2xpZW50O1xyXG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcclxuICAgICAgbGFzdEVycm9yID0gZXJyO1xyXG4gICAgICBhdHRlbXB0cysrO1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBNb25nb0RCIGNvbm5lY3Rpb24gZmFpbGVkIChhdHRlbXB0ICR7YXR0ZW1wdHN9LyR7TUFYX1JFVFJJRVN9KTpgLCBlcnIpO1xyXG4gICAgICBpZiAoYXR0ZW1wdHMgPCBNQVhfUkVUUklFUykge1xyXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDAwKSk7IC8vIHdhaXQgZm9yIDUgc2Vjb25kcyBiZWZvcmUgcmV0cnlpbmdcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQWZ0ZXIgbWF4IHJldHJpZXMsIHRocm93IHRoZSBsYXN0IGVycm9yIGVuY291bnRlcmVkXHJcbiAgdGhyb3cgbGFzdEVycm9yIHx8IG5ldyBFcnJvcignTW9uZ29EQiBjb25uZWN0aW9uIGZhaWxlZCBhZnRlciBtYXhpbXVtIHJldHJ5IGF0dGVtcHRzJyk7XHJcbn1cclxuXHJcbmlmICghZ2xvYmFsLl9tb25nb0NsaWVudFByb21pc2UpIHtcclxuICBnbG9iYWwuX21vbmdvQ2xpZW50UHJvbWlzZSA9IGNvbm5lY3RXaXRoUmV0cnkoKTtcclxuICBcclxuICAvLyBPcHRpb25hbDogbG9nIGNvbm5lY3Rpb24gZXZlbnRzXHJcbiAgZ2xvYmFsLl9tb25nb0NsaWVudFByb21pc2VcclxuICAgIC50aGVuKGNsaWVudCA9PiB7XHJcbiAgICAgIGNsaWVudC5vbignc2VydmVyT3BlbmluZycsIChldmVudCkgPT4gY29uc29sZS5sb2coJ01vbmdvREIgc2VydmVyIG9wZW5pbmcnLCBldmVudCkpO1xyXG4gICAgICBjbGllbnQub24oJ3NlcnZlckNsb3NlZCcsIChldmVudCkgPT4gY29uc29sZS53YXJuKCdNb25nb0RCIHNlcnZlciBjbG9zZWQnLCBldmVudCkpO1xyXG4gICAgICBjbGllbnQub24oJ3RvcG9sb2d5Q2xvc2VkJywgKCkgPT4gY29uc29sZS53YXJuKCdNb25nb0RCIHRvcG9sb2d5IGNsb3NlZCcpKTtcclxuICAgICAgY2xpZW50Lm9uKCd0b3BvbG9neU9wZW5pbmcnLCAoKSA9PiBjb25zb2xlLmxvZygnTW9uZ29EQiB0b3BvbG9neSBvcGVuaW5nJykpO1xyXG4gICAgICBjbGllbnQub24oJ2Vycm9yJywgKGVycikgPT4gY29uc29sZS5lcnJvcignTW9uZ29EQiBlcnJvcicsIGVycikpO1xyXG4gICAgfSlcclxuICAgIC5jYXRjaChlcnIgPT4ge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdNb25nb0RCIGNsaWVudCBmYWlsZWQgdG8gY29ubmVjdCBhZnRlciByZXRyaWVzJywgZXJyKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5jbGllbnRQcm9taXNlID0gZ2xvYmFsLl9tb25nb0NsaWVudFByb21pc2U7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGllbnRQcm9taXNlOyJdLCJuYW1lcyI6WyJNb25nb0NsaWVudCIsInVyaSIsInByb2Nlc3MiLCJlbnYiLCJNT05HT0RCX1VSSSIsIkVycm9yIiwiY2xpZW50IiwiY2xpZW50UHJvbWlzZSIsImNvbm5lY3RXaXRoUmV0cnkiLCJNQVhfUkVUUklFUyIsImF0dGVtcHRzIiwibGFzdEVycm9yIiwibWF4UG9vbFNpemUiLCJzZXJ2ZXJTZWxlY3Rpb25UaW1lb3V0TVMiLCJzb2NrZXRUaW1lb3V0TVMiLCJjb25uZWN0IiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZ2xvYmFsIiwiX21vbmdvQ2xpZW50UHJvbWlzZSIsInRoZW4iLCJvbiIsImV2ZW50IiwibG9nIiwid2FybiIsImNhdGNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./lib/mongo.ts\n");

/***/ }),

/***/ "(api)/./lib/redis.ts":
/*!**********************!*\
  !*** ./lib/redis.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   redis: () => (/* binding */ redis),\n/* harmony export */   subscribe: () => (/* binding */ subscribe),\n/* harmony export */   subscribeToChannels: () => (/* binding */ subscribeToChannels)\n/* harmony export */ });\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ioredis */ \"ioredis\");\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ioredis__WEBPACK_IMPORTED_MODULE_0__);\n// lib/redis.ts\n\nconst redis = new (ioredis__WEBPACK_IMPORTED_MODULE_0___default())(process.env.REDIS_URL || \"redis://127.0.0.1:6379\", {\n    maxRetriesPerRequest: null,\n    lazyConnect: true,\n    reconnectOnError: (err)=>{\n        const targetErrors = [\n            \"READONLY\",\n            \"ECONNRESET\",\n            \"ETIMEDOUT\"\n        ];\n        return targetErrors.some((e)=>err.message.includes(e));\n    }\n});\nredis.on(\"connect\", ()=>console.log(\"Redis connected\"));\nredis.on(\"ready\", ()=>console.log(\"Redis ready\"));\nredis.on(\"error\", (err)=>console.error(\"Redis error\", err));\nredis.on(\"close\", ()=>console.warn(\"Redis connection closed\"));\nredis.on(\"reconnecting\", ()=>console.log(\"Redis reconnecting\"));\n/**\r\n * Single-channel subscription helper\r\n */ function subscribe(channel, handler) {\n    const sub = redis.duplicate();\n    const onMessage = (ch, message)=>{\n        if (ch !== channel) return;\n        try {\n            handler(JSON.parse(message));\n        } catch  {\n            handler(message);\n        }\n    };\n    sub.on(\"message\", onMessage);\n    sub.subscribe(channel).catch((err)=>{\n        console.error(`Redis subscribe failed for ${channel}`, err);\n    });\n    return async ()=>{\n        try {\n            sub.off(\"message\", onMessage);\n            await sub.unsubscribe(channel);\n            await sub.quit();\n        } catch (err) {\n            console.warn(`Failed to unsubscribe from ${channel}`, err);\n        }\n    };\n}\n/**\r\n * Multi-channel subscriber (worker & SSE safe)\r\n */ async function subscribeToChannels(sub, channels, handler) {\n    for (const ch of channels){\n        await sub.subscribe(ch);\n    }\n    sub.on(\"message\", (channel, message)=>{\n        if (channels.includes(channel)) {\n            handler(channel, message);\n        }\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9saWIvcmVkaXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxlQUFlO0FBQ2U7QUFFdkIsTUFBTUMsUUFBUSxJQUFJRCxnREFBT0EsQ0FBQ0UsUUFBUUMsR0FBRyxDQUFDQyxTQUFTLElBQUksMEJBQTBCO0lBQ2xGQyxzQkFBc0I7SUFDdEJDLGFBQWE7SUFDYkMsa0JBQWtCLENBQUNDO1FBQ2pCLE1BQU1DLGVBQWU7WUFBQztZQUFZO1lBQWM7U0FBWTtRQUM1RCxPQUFPQSxhQUFhQyxJQUFJLENBQUMsQ0FBQ0MsSUFBTUgsSUFBSUksT0FBTyxDQUFDQyxRQUFRLENBQUNGO0lBQ3ZEO0FBQ0YsR0FBRztBQUVIVixNQUFNYSxFQUFFLENBQUMsV0FBVyxJQUFNQyxRQUFRQyxHQUFHLENBQUM7QUFDdENmLE1BQU1hLEVBQUUsQ0FBQyxTQUFTLElBQU1DLFFBQVFDLEdBQUcsQ0FBQztBQUNwQ2YsTUFBTWEsRUFBRSxDQUFDLFNBQVMsQ0FBQ04sTUFBUU8sUUFBUUUsS0FBSyxDQUFDLGVBQWVUO0FBQ3hEUCxNQUFNYSxFQUFFLENBQUMsU0FBUyxJQUFNQyxRQUFRRyxJQUFJLENBQUM7QUFDckNqQixNQUFNYSxFQUFFLENBQUMsZ0JBQWdCLElBQU1DLFFBQVFDLEdBQUcsQ0FBQztBQUUzQzs7Q0FFQyxHQUNNLFNBQVNHLFVBQ2RDLE9BQWUsRUFDZkMsT0FBNEI7SUFFNUIsTUFBTUMsTUFBTXJCLE1BQU1zQixTQUFTO0lBRTNCLE1BQU1DLFlBQVksQ0FBQ0MsSUFBWWI7UUFDN0IsSUFBSWEsT0FBT0wsU0FBUztRQUNwQixJQUFJO1lBQ0ZDLFFBQVFLLEtBQUtDLEtBQUssQ0FBQ2Y7UUFDckIsRUFBRSxPQUFNO1lBQ05TLFFBQVFUO1FBQ1Y7SUFDRjtJQUVBVSxJQUFJUixFQUFFLENBQUMsV0FBV1U7SUFFbEJGLElBQUlILFNBQVMsQ0FBQ0MsU0FBU1EsS0FBSyxDQUFDLENBQUNwQjtRQUM1Qk8sUUFBUUUsS0FBSyxDQUFDLENBQUMsMkJBQTJCLEVBQUVHLFFBQVEsQ0FBQyxFQUFFWjtJQUN6RDtJQUVBLE9BQU87UUFDTCxJQUFJO1lBQ0ZjLElBQUlPLEdBQUcsQ0FBQyxXQUFXTDtZQUNuQixNQUFNRixJQUFJUSxXQUFXLENBQUNWO1lBQ3RCLE1BQU1FLElBQUlTLElBQUk7UUFDaEIsRUFBRSxPQUFPdkIsS0FBSztZQUNaTyxRQUFRRyxJQUFJLENBQUMsQ0FBQywyQkFBMkIsRUFBRUUsUUFBUSxDQUFDLEVBQUVaO1FBQ3hEO0lBQ0Y7QUFDRjtBQUVBOztDQUVDLEdBQ00sZUFBZXdCLG9CQUNwQlYsR0FBWSxFQUNaVyxRQUFrQixFQUNsQlosT0FBbUQ7SUFFbkQsS0FBSyxNQUFNSSxNQUFNUSxTQUFVO1FBQ3pCLE1BQU1YLElBQUlILFNBQVMsQ0FBQ007SUFDdEI7SUFFQUgsSUFBSVIsRUFBRSxDQUFDLFdBQVcsQ0FBQ00sU0FBU1I7UUFDMUIsSUFBSXFCLFNBQVNwQixRQUFRLENBQUNPLFVBQVU7WUFDOUJDLFFBQVFELFNBQVNSO1FBQ25CO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldGluZy1tdnAvLi9saWIvcmVkaXMudHM/NTFlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBsaWIvcmVkaXMudHNcclxuaW1wb3J0IElPUmVkaXMgZnJvbSBcImlvcmVkaXNcIjtcclxuXHJcbmV4cG9ydCBjb25zdCByZWRpcyA9IG5ldyBJT1JlZGlzKHByb2Nlc3MuZW52LlJFRElTX1VSTCB8fCBcInJlZGlzOi8vMTI3LjAuMC4xOjYzNzlcIiwge1xyXG4gIG1heFJldHJpZXNQZXJSZXF1ZXN0OiBudWxsLFxyXG4gIGxhenlDb25uZWN0OiB0cnVlLFxyXG4gIHJlY29ubmVjdE9uRXJyb3I6IChlcnIpID0+IHtcclxuICAgIGNvbnN0IHRhcmdldEVycm9ycyA9IFtcIlJFQURPTkxZXCIsIFwiRUNPTk5SRVNFVFwiLCBcIkVUSU1FRE9VVFwiXTtcclxuICAgIHJldHVybiB0YXJnZXRFcnJvcnMuc29tZSgoZSkgPT4gZXJyLm1lc3NhZ2UuaW5jbHVkZXMoZSkpO1xyXG4gIH0sXHJcbn0pO1xyXG5cclxucmVkaXMub24oXCJjb25uZWN0XCIsICgpID0+IGNvbnNvbGUubG9nKFwiUmVkaXMgY29ubmVjdGVkXCIpKTtcclxucmVkaXMub24oXCJyZWFkeVwiLCAoKSA9PiBjb25zb2xlLmxvZyhcIlJlZGlzIHJlYWR5XCIpKTtcclxucmVkaXMub24oXCJlcnJvclwiLCAoZXJyKSA9PiBjb25zb2xlLmVycm9yKFwiUmVkaXMgZXJyb3JcIiwgZXJyKSk7XHJcbnJlZGlzLm9uKFwiY2xvc2VcIiwgKCkgPT4gY29uc29sZS53YXJuKFwiUmVkaXMgY29ubmVjdGlvbiBjbG9zZWRcIikpO1xyXG5yZWRpcy5vbihcInJlY29ubmVjdGluZ1wiLCAoKSA9PiBjb25zb2xlLmxvZyhcIlJlZGlzIHJlY29ubmVjdGluZ1wiKSk7XHJcblxyXG4vKipcclxuICogU2luZ2xlLWNoYW5uZWwgc3Vic2NyaXB0aW9uIGhlbHBlclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHN1YnNjcmliZShcclxuICBjaGFubmVsOiBzdHJpbmcsXHJcbiAgaGFuZGxlcjogKGRhdGE6IGFueSkgPT4gdm9pZFxyXG4pOiAoKSA9PiBQcm9taXNlPHZvaWQ+IHtcclxuICBjb25zdCBzdWIgPSByZWRpcy5kdXBsaWNhdGUoKTtcclxuXHJcbiAgY29uc3Qgb25NZXNzYWdlID0gKGNoOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZykgPT4ge1xyXG4gICAgaWYgKGNoICE9PSBjaGFubmVsKSByZXR1cm47XHJcbiAgICB0cnkge1xyXG4gICAgICBoYW5kbGVyKEpTT04ucGFyc2UobWVzc2FnZSkpO1xyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIGhhbmRsZXIobWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgc3ViLm9uKFwibWVzc2FnZVwiLCBvbk1lc3NhZ2UpO1xyXG5cclxuICBzdWIuc3Vic2NyaWJlKGNoYW5uZWwpLmNhdGNoKChlcnIpID0+IHtcclxuICAgIGNvbnNvbGUuZXJyb3IoYFJlZGlzIHN1YnNjcmliZSBmYWlsZWQgZm9yICR7Y2hhbm5lbH1gLCBlcnIpO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgc3ViLm9mZihcIm1lc3NhZ2VcIiwgb25NZXNzYWdlKTtcclxuICAgICAgYXdhaXQgc3ViLnVuc3Vic2NyaWJlKGNoYW5uZWwpO1xyXG4gICAgICBhd2FpdCBzdWIucXVpdCgpO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIHVuc3Vic2NyaWJlIGZyb20gJHtjaGFubmVsfWAsIGVycik7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE11bHRpLWNoYW5uZWwgc3Vic2NyaWJlciAod29ya2VyICYgU1NFIHNhZmUpXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3Vic2NyaWJlVG9DaGFubmVscyhcclxuICBzdWI6IElPUmVkaXMsXHJcbiAgY2hhbm5lbHM6IHN0cmluZ1tdLFxyXG4gIGhhbmRsZXI6IChjaGFubmVsOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZFxyXG4pIHtcclxuICBmb3IgKGNvbnN0IGNoIG9mIGNoYW5uZWxzKSB7XHJcbiAgICBhd2FpdCBzdWIuc3Vic2NyaWJlKGNoKTtcclxuICB9XHJcblxyXG4gIHN1Yi5vbihcIm1lc3NhZ2VcIiwgKGNoYW5uZWwsIG1lc3NhZ2UpID0+IHtcclxuICAgIGlmIChjaGFubmVscy5pbmNsdWRlcyhjaGFubmVsKSkge1xyXG4gICAgICBoYW5kbGVyKGNoYW5uZWwsIG1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJJT1JlZGlzIiwicmVkaXMiLCJwcm9jZXNzIiwiZW52IiwiUkVESVNfVVJMIiwibWF4UmV0cmllc1BlclJlcXVlc3QiLCJsYXp5Q29ubmVjdCIsInJlY29ubmVjdE9uRXJyb3IiLCJlcnIiLCJ0YXJnZXRFcnJvcnMiLCJzb21lIiwiZSIsIm1lc3NhZ2UiLCJpbmNsdWRlcyIsIm9uIiwiY29uc29sZSIsImxvZyIsImVycm9yIiwid2FybiIsInN1YnNjcmliZSIsImNoYW5uZWwiLCJoYW5kbGVyIiwic3ViIiwiZHVwbGljYXRlIiwib25NZXNzYWdlIiwiY2giLCJKU09OIiwicGFyc2UiLCJjYXRjaCIsIm9mZiIsInVuc3Vic2NyaWJlIiwicXVpdCIsInN1YnNjcmliZVRvQ2hhbm5lbHMiLCJjaGFubmVscyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./lib/redis.ts\n");

/***/ }),

/***/ "(api)/./pages/api/campaign/[id]/control.ts":
/*!********************************************!*\
  !*** ./pages/api/campaign/[id]/control.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var _lib_mongo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../lib/mongo */ \"(api)/./lib/mongo.ts\");\n/* harmony import */ var _lib_redis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../lib/redis */ \"(api)/./lib/redis.ts\");\n/* harmony import */ var bullmq__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bullmq */ \"bullmq\");\n/* harmony import */ var bullmq__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(bullmq__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! mongodb */ \"mongodb\");\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(mongodb__WEBPACK_IMPORTED_MODULE_3__);\n// pages/api/campaign/[id]/control.ts \n\n\n\n\nconst queue = new bullmq__WEBPACK_IMPORTED_MODULE_2__.Queue(\"campaigns\", {\n    connection: _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis\n});\n// keep parity with worker; allow env override\nconst MAX_ATTEMPTS = Number(process.env.MAX_ATTEMPTS || 3);\n// server-side cap for batch retries per request\nconst BATCH_RETRY_LIMIT = Number(process.env.BATCH_RETRY_LIMIT || 5000);\n// when resuming, limit how many pending jobs we'll try to (re)enqueue\nconst RESUME_ENQUEUE_LIMIT = Number(process.env.RESUME_ENQUEUE_LIMIT || 5000);\n// how long before a 'sending' row is considered stale and eligible for recovery (ms)\nconst STALE_SENDING_MS = Number(process.env.STALE_SENDING_MS || 90000);\nasync function safeHSet(key, obj) {\n    try {\n        await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hset(key, obj);\n    } catch (err) {\n        console.warn(\"Redis unavailable while setting meta\", err);\n    }\n}\nasync function safePublish(channel, payload) {\n    try {\n        await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.publish(channel, JSON.stringify(payload));\n    } catch (err) {\n        console.warn(\"Redis publish failed\", err);\n    }\n}\n// Remove waiting/delayed/active jobs for a campaignId (best-effort)\nasync function removeQueuedJobsForCampaign(campaignId) {\n    try {\n        // get waiting/delayed/active jobs\n        const jobs = await queue.getJobs([\n            \"waiting\",\n            \"delayed\",\n            \"active\",\n            \"paused\"\n        ], 0, -1);\n        const matched = jobs.filter((j)=>{\n            try {\n                return j.data?.campaignId === campaignId;\n            } catch  {\n                return false;\n            }\n        });\n        for (const j of matched){\n            try {\n                // if the job is active, remove may fail - still try\n                await j.remove();\n            } catch (e) {\n                // best-effort — ignore\n                console.warn(`Failed to remove job ${j.id}`, e);\n            }\n        }\n        return matched.length;\n    } catch (err) {\n        console.warn(\"Failed to enumerate/remove jobs for campaign\", err);\n        return 0;\n    }\n}\n// safe read of redis meta integer field\nasync function safeGetMetaInt(redisKey, field) {\n    try {\n        const v = await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hget(redisKey, field);\n        return Number(v || 0);\n    } catch (e) {\n        return 0;\n    }\n}\n/**\r\n * Ensure there is a usable `campaign:{id}:definition` in Redis.\r\n * If missing, attempt to construct one from the Mongo campaign document.\r\n * Returns true if definition exists or was written successfully.\r\n */ async function ensureCampaignDefinition(id, campaignDoc) {\n    const key = `campaign:${id}:definition`;\n    try {\n        const existing = await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.get(key);\n        if (existing) return true;\n        // Attempt to build a minimal compatible definition\n        // Worker expects { initial: { subject, body }, followUps: [...] }\n        let built = null;\n        // Prefer explicit shapes commonly used\n        if (campaignDoc?.definition && typeof campaignDoc.definition === \"object\") {\n            built = campaignDoc.definition;\n        } else if (campaignDoc?.initial && typeof campaignDoc.initial === \"object\") {\n            built = {\n                initial: campaignDoc.initial,\n                followUps: campaignDoc.followUps || []\n            };\n        } else if (campaignDoc?.template && typeof campaignDoc.template === \"object\") {\n            built = {\n                initial: {\n                    subject: campaignDoc.template.subject || campaignDoc.name,\n                    body: campaignDoc.template.body || campaignDoc.content || \"\"\n                },\n                followUps: campaignDoc.template.followUps || campaignDoc.followUps || []\n            };\n        } else {\n            // fallback: try to glean subject/body from common fields\n            const subject = campaignDoc?.subject || campaignDoc?.title || campaignDoc?.name || `Campaign ${id}`;\n            const body = campaignDoc?.body || campaignDoc?.content || campaignDoc?.html || \"\";\n            const followUps = campaignDoc?.followUps || campaignDoc?.steps || [];\n            built = {\n                initial: {\n                    subject,\n                    body\n                },\n                followUps\n            };\n        }\n        // If built doesn't look right (no initial subject/body), fail safe\n        if (!built || !built.initial || built.initial.subject == null && built.initial.body == null) {\n            console.warn(\"Unable to construct campaign definition from campaign document\", {\n                campaignId: id,\n                sample: campaignDoc ? Object.keys(campaignDoc).slice(0, 8) : null\n            });\n            return false;\n        }\n        // Persist into Redis (no expiry) so worker can read it\n        try {\n            await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.set(key, JSON.stringify(built));\n            console.log(`Wrote fallback campaign definition into redis for ${id}`);\n            return true;\n        } catch (e) {\n            console.warn(\"Failed to write campaign definition to redis\", e);\n            return false;\n        }\n    } catch (e) {\n        console.warn(\"Error checking/writing campaign definition in redis\", e);\n        return false;\n    }\n}\n/**\r\n * Get a set of contactId strings for jobs currently enqueued for this campaign.\r\n * Used to avoid enqueuing duplicates when resuming.\r\n */ async function getQueuedContactIdsForCampaign(campaignId) {\n    const set = new Set();\n    try {\n        const jobs = await queue.getJobs([\n            \"waiting\",\n            \"delayed\",\n            \"active\",\n            \"paused\"\n        ], 0, -1);\n        for (const j of jobs){\n            try {\n                if (j.data?.campaignId === campaignId && j.data?.contactId) {\n                    set.add(String(j.data.contactId));\n                }\n            } catch  {\n            // ignore malformed jobs\n            }\n        }\n    } catch (e) {\n        console.warn(\"Failed to list queued jobs for campaign when checking duplicates\", e);\n    }\n    return set;\n}\nasync function handler(req, res) {\n    if (req.method !== \"POST\") {\n        return res.status(405).json({\n            error: \"Method not allowed\"\n        });\n    }\n    const { id } = req.query;\n    if (!id || typeof id !== \"string\") {\n        return res.status(400).json({\n            error: \"Invalid campaign id\"\n        });\n    }\n    const { action, confirm, contactId } = req.body;\n    if (!action || ![\n        \"pause\",\n        \"resume\",\n        \"cancel\",\n        \"delete\",\n        \"retryFailed\",\n        \"retryContact\"\n    ].includes(action)) {\n        return res.status(400).json({\n            error: \"Invalid action\"\n        });\n    }\n    const client = await _lib_mongo__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    const db = client.db(\"PlatformData\");\n    const campaignObjectId = new mongodb__WEBPACK_IMPORTED_MODULE_3__.ObjectId(id);\n    try {\n        // Reload campaign from Mongo (authoritative)\n        const campaign = await db.collection(\"campaigns\").findOne({\n            _id: campaignObjectId\n        });\n        if (!campaign) {\n            return res.status(404).json({\n                error: \"Campaign not found\"\n            });\n        }\n        // Lightweight helpers\n        const redisKey = `campaign:${id}:meta`;\n        // ACTION: Pause\n        if (action === \"pause\") {\n            if (campaign.status === \"paused\") {\n                return res.status(200).json({\n                    ok: true,\n                    message: \"Already paused\"\n                });\n            }\n            await db.collection(\"campaigns\").updateOne({\n                _id: campaignObjectId\n            }, {\n                $set: {\n                    status: \"paused\"\n                }\n            });\n            await safeHSet(redisKey, {\n                status: \"paused\"\n            });\n            // publish campaign-level event so UI disables retry buttons and updates state\n            await safePublish(\"campaign:new\", {\n                id,\n                status: \"paused\"\n            });\n            return res.status(200).json({\n                ok: true,\n                action: \"paused\"\n            });\n        }\n        // ACTION: Resume\n        if (action === \"resume\") {\n            if (campaign.status === \"running\") {\n                return res.status(200).json({\n                    ok: true,\n                    message: \"Already running\"\n                });\n            }\n            // set running in DB + redis\n            await db.collection(\"campaigns\").updateOne({\n                _id: campaignObjectId\n            }, {\n                $set: {\n                    status: \"running\"\n                }\n            });\n            await safeHSet(redisKey, {\n                status: \"running\"\n            });\n            await safePublish(\"campaign:new\", {\n                id,\n                status: \"running\"\n            });\n            // Re-enqueue pending contacts that currently have no queued job for this campaign.\n            // This addresses cases where jobs were removed or not enqueued while the campaign was paused,\n            // ensuring pending rows actually get processed again after resume.\n            try {\n                const queuedSet = await getQueuedContactIdsForCampaign(id);\n                // fetch pending docs (limit to a sane cap)\n                const pendingCursor = db.collection(\"campaign_contacts\").find({\n                    campaignId: campaignObjectId,\n                    status: \"pending\"\n                }, {\n                    projection: {\n                        _id: 1,\n                        contactId: 1,\n                        step: 1\n                    }\n                }).limit(RESUME_ENQUEUE_LIMIT);\n                const pending = await pendingCursor.toArray();\n                const enqueuePromises = [];\n                for (const d of pending){\n                    const cid = d.contactId ? d.contactId.toString ? d.contactId.toString() : String(d.contactId) : d._id.toString ? d._id.toString() : String(d._id);\n                    if (queuedSet.has(cid)) continue; // already queued\n                    try {\n                        enqueuePromises.push(queue.add(d.step ? \"followup\" : \"initial\", {\n                            campaignId: id,\n                            contactId: cid,\n                            step: d.step\n                        }, {\n                            removeOnComplete: true,\n                            removeOnFail: true,\n                            attempts: MAX_ATTEMPTS,\n                            backoff: {\n                                type: \"exponential\",\n                                delay: 60000\n                            }\n                        }));\n                    } catch (e) {\n                        console.warn(\"Failed to enqueue pending contact on resume\", e);\n                    }\n                }\n                // attempt to enqueue in parallel (best-effort)\n                if (enqueuePromises.length > 0) {\n                    await Promise.allSettled(enqueuePromises);\n                    // notify UI that contacts have been re-queued (counts unchanged, but UI may want to refresh)\n                    await safePublish(\"campaign:new\", {\n                        id,\n                        action: \"resume_requeued\",\n                        requeued: enqueuePromises.length\n                    });\n                }\n            } catch (e) {\n                console.warn(\"Failed to re-enqueue pending contacts on resume\", e);\n            }\n            // Recover stale 'sending' ledger rows that may have been left in 'sending' by a crashed worker or killed process.\n            // Criteria: status === 'sending' AND lastAttemptAt older than STALE_SENDING_MS AND bgAttempts < MAX_ATTEMPTS\n            // We'll set them back to 'pending', reset bgAttempts to 0 (so background cycle restarts), and enqueue jobs.\n            try {\n                const cutoff = new Date(Date.now() - STALE_SENDING_MS);\n                const staleCursor = db.collection(\"campaign_contacts\").find({\n                    campaignId: campaignObjectId,\n                    status: \"sending\",\n                    lastAttemptAt: {\n                        $lt: cutoff\n                    }\n                }, {\n                    projection: {\n                        _id: 1,\n                        contactId: 1,\n                        step: 1,\n                        bgAttempts: 1\n                    }\n                }).limit(RESUME_ENQUEUE_LIMIT);\n                const staleDocs = await staleCursor.toArray();\n                if (staleDocs.length > 0) {\n                    const ids = staleDocs.map((d)=>d._id);\n                    // Reset to pending and clear lastError, reset bgAttempts so background retries start fresh\n                    await db.collection(\"campaign_contacts\").updateMany({\n                        _id: {\n                            $in: ids\n                        }\n                    }, {\n                        $set: {\n                            status: \"pending\",\n                            lastError: null,\n                            bgAttempts: 0\n                        }\n                    });\n                    // Enqueue each stale doc if not already queued\n                    const queuedSet2 = await getQueuedContactIdsForCampaign(id);\n                    const requeuePromises = [];\n                    for (const d of staleDocs){\n                        const cid = d.contactId ? d.contactId.toString ? d.contactId.toString() : String(d.contactId) : d._id.toString ? d._id.toString() : String(d._id);\n                        if (queuedSet2.has(cid)) continue;\n                        try {\n                            requeuePromises.push(queue.add(d.step ? \"followup\" : \"initial\", {\n                                campaignId: id,\n                                contactId: cid,\n                                step: d.step\n                            }, {\n                                removeOnComplete: true,\n                                removeOnFail: true,\n                                attempts: MAX_ATTEMPTS,\n                                backoff: {\n                                    type: \"exponential\",\n                                    delay: 60000\n                                }\n                            }));\n                        } catch (e) {\n                            console.warn(\"Failed to enqueue stale sending contact on resume\", e);\n                        }\n                        // publish contact-level update hint so UI reflects it's now pending\n                        try {\n                            safePublish(`campaign:${id}:contact_update`, {\n                                contactId: cid,\n                                status: \"pending\",\n                                bgAttempts: 0,\n                                attempts: undefined\n                            });\n                        } catch (_) {}\n                    }\n                    if (requeuePromises.length > 0) await Promise.allSettled(requeuePromises);\n                    await safePublish(\"campaign:new\", {\n                        id,\n                        action: \"resume_recovered_sending\",\n                        recovered: staleDocs.length\n                    });\n                }\n            } catch (e) {\n                console.warn(\"Failed to recover stale sending rows on resume\", e);\n            }\n            return res.status(200).json({\n                ok: true,\n                action: \"resumed\"\n            });\n        }\n        // ACTION: Cancel\n        if (action === \"cancel\") {\n            if (campaign.status === \"cancelled\") {\n                return res.status(200).json({\n                    ok: true,\n                    message: \"Already cancelled\"\n                });\n            }\n            // 1) Mark campaign cancelled and completedAt\n            const completedAt = new Date();\n            await db.collection(\"campaigns\").updateOne({\n                _id: campaignObjectId\n            }, {\n                $set: {\n                    status: \"cancelled\",\n                    completedAt\n                }\n            });\n            await safeHSet(redisKey, {\n                status: \"cancelled\"\n            });\n            // 2) Find and atomically mark pending ledger rows as failed (single updateMany)\n            const filter = {\n                campaignId: campaignObjectId,\n                status: \"pending\"\n            };\n            const update = {\n                $set: {\n                    status: \"failed\",\n                    lastError: \"cancelled\",\n                    lastAttemptAt: completedAt\n                },\n                $inc: {\n                    attempts: 1\n                }\n            };\n            const updateResult = await db.collection(\"campaign_contacts\").updateMany(filter, update);\n            const cancelledCount = updateResult.modifiedCount ?? 0;\n            // 3) Update Redis counters (best-effort)\n            try {\n                if (cancelledCount > 0) {\n                    await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hincrby(redisKey, \"processed\", cancelledCount);\n                    await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hincrby(redisKey, \"failed\", cancelledCount);\n                }\n            } catch (e) {\n                console.warn(\"Failed to update redis counters during cancel\", e);\n            }\n            // 4) Persist totals snapshot to campaigns.totals (read redis if available, fallback to db)\n            let meta = {};\n            try {\n                meta = await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hgetall(redisKey) || {};\n            } catch  {\n                meta = {};\n            }\n            // Compute totals final values combining persisted totals and our cancelledCount as fallback\n            const processedNow = Number(meta[\"processed\"] ?? (campaign.totals?.processed ?? 0) + cancelledCount);\n            const sentNow = Number(meta[\"sent\"] ?? campaign.totals?.sent ?? 0);\n            const failedNow = Number(meta[\"failed\"] ?? (campaign.totals?.failed ?? 0) + cancelledCount);\n            await db.collection(\"campaigns\").updateOne({\n                _id: campaignObjectId\n            }, {\n                $set: {\n                    \"totals.processed\": processedNow,\n                    \"totals.sent\": sentNow,\n                    \"totals.failed\": failedNow,\n                    completedAt\n                }\n            });\n            // 5) Remove queued jobs for this campaign (best-effort)\n            const removedJobs = await removeQueuedJobsForCampaign(id);\n            // 6) Publish event\n            await safePublish(\"campaign:new\", {\n                id,\n                status: \"cancelled\",\n                cancelledCount,\n                removedJobs\n            });\n            return res.status(200).json({\n                ok: true,\n                action: \"cancelled\",\n                cancelledCount,\n                removedJobs\n            });\n        }\n        // ACTION: Delete\n        if (action === \"delete\") {\n            // Require explicit confirmation — safeguards in UI must set confirm=true\n            if (confirm !== true) {\n                return res.status(400).json({\n                    error: \"Deletion requires confirm=true in request body\"\n                });\n            }\n            // Prevent accidental deletion while running\n            if (campaign.status === \"running\") {\n                return res.status(400).json({\n                    error: \"Cancel the campaign before deletion\"\n                });\n            }\n            // Remove queued jobs (best-effort)\n            const removedJobs = await removeQueuedJobsForCampaign(id);\n            // Delete Redis keys (best-effort)\n            try {\n                await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.del(`campaign:${id}:meta`);\n                await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.del(`campaign:${id}:definition`);\n                await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.srem(\"campaign:all\", id);\n            } catch (e) {\n                console.warn(\"Redis cleanup on delete failed\", e);\n            }\n            // Delete Mongo docs\n            const [campaignDel, ledgerDel] = await Promise.all([\n                db.collection(\"campaigns\").deleteOne({\n                    _id: campaignObjectId\n                }),\n                db.collection(\"campaign_contacts\").deleteMany({\n                    campaignId: campaignObjectId\n                })\n            ]);\n            await safePublish(\"campaign:new\", {\n                id,\n                status: \"deleted\"\n            });\n            return res.status(200).json({\n                ok: true,\n                action: \"deleted\",\n                campaignDeleted: campaignDel.deletedCount ?? 0,\n                ledgerDeleted: ledgerDel.deletedCount ?? 0,\n                removedJobs\n            });\n        }\n        // ACTION: Retry all failed contacts that are below MAX_ATTEMPTS\n        if (action === \"retryFailed\") {\n            // Disallow retrying if campaign is cancelled/deleted/paused\n            if (campaign.status === \"cancelled\" || campaign.status === \"deleted\" || campaign.status === \"paused\") {\n                return res.status(400).json({\n                    error: \"Cannot retry contacts for cancelled/deleted/paused campaign\"\n                });\n            }\n            // Ensure a Redis campaign definition exists (worker requires it)\n            const hasDef = await ensureCampaignDefinition(id, campaign);\n            if (!hasDef) {\n                return res.status(500).json({\n                    error: \"Missing campaign definition in Redis and unable to construct one from campaign document. Retry cannot proceed.\"\n                });\n            }\n            // find failed contacts with attempts < MAX_ATTEMPTS AND where bgAttempts >= MAX_ATTEMPTS (meaning background cycle finished)\n            // If bgAttempts is missing (undefined/null), treat it as finished (conservative). But prefer explicit >=.\n            const filter = {\n                campaignId: campaignObjectId,\n                status: \"failed\",\n                attempts: {\n                    $lt: MAX_ATTEMPTS\n                },\n                $or: [\n                    {\n                        bgAttempts: {\n                            $exists: false\n                        }\n                    },\n                    {\n                        bgAttempts: {\n                            $gte: MAX_ATTEMPTS\n                        }\n                    }\n                ]\n            };\n            const failedDocs = await db.collection(\"campaign_contacts\").find(filter, {\n                projection: {\n                    _id: 1,\n                    contactId: 1,\n                    step: 1\n                }\n            }).toArray();\n            const toRetryCount = failedDocs.length;\n            if (toRetryCount === 0) {\n                return res.status(200).json({\n                    ok: true,\n                    retried: 0,\n                    message: \"No eligible failed contacts to retry (either none failed, reached max attempts, or background retries still in progress).\"\n                });\n            }\n            // server-side cap enforcement\n            if (toRetryCount > BATCH_RETRY_LIMIT) {\n                return res.status(400).json({\n                    error: \"Batch retry exceeds server limit\",\n                    message: `Trying to retry ${toRetryCount} contacts exceeds server cap of ${BATCH_RETRY_LIMIT}. Use pagination to retry in smaller batches.`,\n                    toRetryCount,\n                    limit: BATCH_RETRY_LIMIT\n                });\n            }\n            // Atomically mark them pending and increment core `attempts` and reset bgAttempts\n            const ids = failedDocs.map((d)=>d._id);\n            const updateResult = await db.collection(\"campaign_contacts\").updateMany({\n                _id: {\n                    $in: ids\n                }\n            }, {\n                $set: {\n                    status: \"pending\",\n                    lastError: null,\n                    bgAttempts: 0\n                },\n                $inc: {\n                    attempts: 1\n                }\n            });\n            const updated = updateResult.modifiedCount ?? 0;\n            // Enqueue jobs (batch), ensure each job has MQ attempts/backoff set\n            const jobs = [];\n            const CHUNK = 200; // reasonable chunking\n            for(let i = 0; i < failedDocs.length; i += CHUNK){\n                const chunk = failedDocs.slice(i, i + CHUNK);\n                for (const doc of chunk){\n                    const contactObjId = doc.contactId ? doc.contactId : doc._id;\n                    try {\n                        if (doc.step) {\n                            jobs.push(queue.add(\"followup\", {\n                                campaignId: id,\n                                contactId: contactObjId.toString ? contactObjId.toString() : String(contactObjId),\n                                step: doc.step\n                            }, {\n                                removeOnComplete: true,\n                                removeOnFail: true,\n                                attempts: MAX_ATTEMPTS,\n                                backoff: {\n                                    type: \"exponential\",\n                                    delay: 60000\n                                }\n                            }));\n                        } else {\n                            jobs.push(queue.add(\"initial\", {\n                                campaignId: id,\n                                contactId: contactObjId.toString ? contactObjId.toString() : String(contactObjId)\n                            }, {\n                                removeOnComplete: true,\n                                removeOnFail: true,\n                                attempts: MAX_ATTEMPTS,\n                                backoff: {\n                                    type: \"exponential\",\n                                    delay: 60000\n                                }\n                            }));\n                        }\n                    } catch (e) {\n                        console.warn(\"Failed to queue job for retryFailed chunk item\", e);\n                    }\n                }\n            }\n            // Wait for enqueues (best-effort)\n            try {\n                await Promise.all(jobs);\n            } catch (e) {\n                console.warn(\"Some queue.add calls failed during retryFailed\", e);\n            }\n            // Update redis counters: decrease failed by updated (best-effort, but avoid negative)\n            try {\n                const currentFailed = await safeGetMetaInt(redisKey, \"failed\");\n                const dec = Math.min(updated, currentFailed);\n                if (dec > 0) {\n                    await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hincrby(redisKey, \"failed\", -dec);\n                }\n            } catch (e) {\n                console.warn(\"Failed to update redis counters during retryFailed\", e);\n            }\n            // Publish contact-level updates for each retried contact (best-effort)\n            try {\n                for (const doc of failedDocs){\n                    const cid = doc.contactId ? doc.contactId.toString ? doc.contactId.toString() : String(doc.contactId) : doc._id.toString ? doc._id.toString() : String(doc._id);\n                    await safePublish(`campaign:${id}:contact_update`, {\n                        contactId: cid,\n                        status: \"pending\",\n                        bgAttempts: 0,\n                        attempts: 1\n                    });\n                }\n            } catch (_) {\n            // ignore publish errors\n            }\n            await safePublish(\"campaign:new\", {\n                id,\n                action: \"retryFailed\",\n                retried: updated\n            });\n            return res.status(200).json({\n                ok: true,\n                retried: updated,\n                attemptedEnqueue: toRetryCount\n            });\n        }\n        // ACTION: Retry a single failed contact by contactId\n        if (action === \"retryContact\") {\n            if (!contactId || typeof contactId !== \"string\") {\n                return res.status(400).json({\n                    error: \"Missing contactId for retryContact\"\n                });\n            }\n            // Disallow retrying if campaign is cancelled/deleted/paused\n            if (campaign.status === \"cancelled\" || campaign.status === \"deleted\" || campaign.status === \"paused\") {\n                return res.status(400).json({\n                    error: \"Cannot retry contacts for cancelled/deleted/paused campaign\"\n                });\n            }\n            // Ensure a Redis campaign definition exists (worker requires it)\n            const hasDef = await ensureCampaignDefinition(id, campaign);\n            if (!hasDef) {\n                return res.status(500).json({\n                    error: \"Missing campaign definition in Redis and unable to construct one from campaign document. Retry cannot proceed.\"\n                });\n            }\n            // Find the ledger row\n            let contactObjId;\n            try {\n                // try parse as ObjectId first\n                contactObjId = new mongodb__WEBPACK_IMPORTED_MODULE_3__.ObjectId(contactId);\n            } catch  {\n                // fallback: use raw string\n                contactObjId = contactId;\n            }\n            const doc = await db.collection(\"campaign_contacts\").findOne({\n                campaignId: campaignObjectId,\n                contactId: contactObjId\n            });\n            if (!doc) {\n                return res.status(404).json({\n                    error: \"Contact ledger row not found for campaign\"\n                });\n            }\n            if (doc.status !== \"failed\") {\n                return res.status(400).json({\n                    error: \"Contact is not in failed state\"\n                });\n            }\n            if ((doc.attempts || 0) >= MAX_ATTEMPTS) {\n                return res.status(400).json({\n                    error: \"Contact has reached max manual attempts and cannot be retried\"\n                });\n            }\n            // Prevent manual retry while BullMQ background retries are still running for this contact\n            // Require bgAttempts >= MAX_ATTEMPTS (or missing) before allowing manual retry\n            const bgDone = typeof doc.bgAttempts === \"number\" ? doc.bgAttempts >= MAX_ATTEMPTS : true;\n            if (!bgDone) {\n                return res.status(400).json({\n                    error: \"Background retries are still in progress for this contact. Please wait until the background retry cycle completes.\"\n                });\n            }\n            // Update single doc to pending, increment core attempts, reset bgAttempts\n            await db.collection(\"campaign_contacts\").updateOne({\n                _id: doc._id\n            }, {\n                $set: {\n                    status: \"pending\",\n                    lastError: null,\n                    bgAttempts: 0\n                },\n                $inc: {\n                    attempts: 1\n                }\n            });\n            // Enqueue appropriate job (use doc.step if present) and ensure MQ attempts/backoff are set\n            try {\n                if (doc.step) {\n                    await queue.add(\"followup\", {\n                        campaignId: id,\n                        contactId: contactObjId.toString ? contactObjId.toString() : String(contactObjId),\n                        step: doc.step\n                    }, {\n                        removeOnComplete: true,\n                        removeOnFail: true,\n                        attempts: MAX_ATTEMPTS,\n                        backoff: {\n                            type: \"exponential\",\n                            delay: 60000\n                        }\n                    });\n                } else {\n                    await queue.add(\"initial\", {\n                        campaignId: id,\n                        contactId: contactObjId.toString ? contactObjId.toString() : String(contactObjId)\n                    }, {\n                        removeOnComplete: true,\n                        removeOnFail: true,\n                        attempts: MAX_ATTEMPTS,\n                        backoff: {\n                            type: \"exponential\",\n                            delay: 60000\n                        }\n                    });\n                }\n            } catch (e) {\n                console.warn(\"Failed to enqueue retry job for contact\", e);\n                // Rollback: try to revert the ledger row changes (best-effort)\n                try {\n                    await db.collection(\"campaign_contacts\").updateOne({\n                        _id: doc._id\n                    }, {\n                        $set: {\n                            status: \"failed\",\n                            lastError: \"enqueue-failed\"\n                        },\n                        $inc: {\n                            attempts: -1\n                        },\n                        $set: {\n                            bgAttempts: doc.bgAttempts ?? 0\n                        }\n                    });\n                } catch (_) {}\n                return res.status(500).json({\n                    error: \"Failed to enqueue retry job\"\n                });\n            }\n            // Update redis counters: decrease failed by 1 if possible (we moved it from failed -> pending)\n            try {\n                const currentFailed = await safeGetMetaInt(redisKey, \"failed\");\n                if (currentFailed > 0) {\n                    await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hincrby(redisKey, \"failed\", -1);\n                }\n            } catch (e) {\n                console.warn(\"Failed to update redis counters during retryContact\", e);\n            }\n            // Publish contact update\n            try {\n                const cidStr = contactObjId.toString ? contactObjId.toString() : String(contactObjId);\n                await safePublish(`campaign:${id}:contact_update`, {\n                    contactId: cidStr,\n                    status: \"pending\",\n                    attempts: (doc.attempts || 0) + 1,\n                    bgAttempts: 0\n                });\n            } catch (_) {}\n            await safePublish(\"campaign:new\", {\n                id,\n                action: \"retryContact\",\n                contactId\n            });\n            return res.status(200).json({\n                ok: true,\n                retried: 1,\n                contactId\n            });\n        }\n        // Should not reach here\n        return res.status(400).json({\n            error: \"Unsupported action\"\n        });\n    } catch (err) {\n        console.error(\"Campaign control error\", err);\n        return res.status(500).json({\n            error: \"Internal server error\"\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9wYWdlcy9hcGkvY2FtcGFpZ24vW2lkXS9jb250cm9sLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxzQ0FBc0M7QUFFWTtBQUNKO0FBQ2Y7QUFDSTtBQUVuQyxNQUFNSSxRQUFRLElBQUlGLHlDQUFLQSxDQUFDLGFBQWE7SUFBRUcsWUFBWUosNkNBQUtBO0FBQUM7QUFFekQsOENBQThDO0FBQzlDLE1BQU1LLGVBQWVDLE9BQU9DLFFBQVFDLEdBQUcsQ0FBQ0gsWUFBWSxJQUFJO0FBQ3hELGdEQUFnRDtBQUNoRCxNQUFNSSxvQkFBb0JILE9BQU9DLFFBQVFDLEdBQUcsQ0FBQ0MsaUJBQWlCLElBQUk7QUFDbEUsc0VBQXNFO0FBQ3RFLE1BQU1DLHVCQUF1QkosT0FBT0MsUUFBUUMsR0FBRyxDQUFDRSxvQkFBb0IsSUFBSTtBQUN4RSxxRkFBcUY7QUFDckYsTUFBTUMsbUJBQW1CTCxPQUFPQyxRQUFRQyxHQUFHLENBQUNHLGdCQUFnQixJQUFJO0FBSWhFLGVBQWVDLFNBQVNDLEdBQVcsRUFBRUMsR0FBMkI7SUFDOUQsSUFBSTtRQUNGLE1BQU1kLDZDQUFLQSxDQUFDZSxJQUFJLENBQUNGLEtBQUtDO0lBQ3hCLEVBQUUsT0FBT0UsS0FBSztRQUNaQyxRQUFRQyxJQUFJLENBQUMsd0NBQXdDRjtJQUN2RDtBQUNGO0FBRUEsZUFBZUcsWUFBWUMsT0FBZSxFQUFFQyxPQUFZO0lBQ3RELElBQUk7UUFDRixNQUFNckIsNkNBQUtBLENBQUNzQixPQUFPLENBQUNGLFNBQVNHLEtBQUtDLFNBQVMsQ0FBQ0g7SUFDOUMsRUFBRSxPQUFPTCxLQUFLO1FBQ1pDLFFBQVFDLElBQUksQ0FBQyx3QkFBd0JGO0lBQ3ZDO0FBQ0Y7QUFFQSxvRUFBb0U7QUFDcEUsZUFBZVMsNEJBQTRCQyxVQUFrQjtJQUMzRCxJQUFJO1FBQ0Ysa0NBQWtDO1FBQ2xDLE1BQU1DLE9BQU8sTUFBTXhCLE1BQU15QixPQUFPLENBQzlCO1lBQUM7WUFBVztZQUFXO1lBQVU7U0FBUyxFQUMx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cEcsVUFBVSxVQUFVLENBQUM7Z0JBQzNDO1lBQ0YsRUFBRSxPQUFPSixHQUFHO2dCQUNWakIsUUFBUUMsSUFBSSxDQUFDLHVEQUF1RGdCO1lBQ3RFO1lBRUEseUJBQXlCO1lBQ3pCLElBQUk7Z0JBQ0YsTUFBTWdKLFNBQVNQLGFBQWFyRSxRQUFRLEdBQUdxRSxhQUFhckUsUUFBUSxLQUFLbEMsT0FBT3VHO2dCQUN4RSxNQUFNeEosWUFBWSxDQUFDLFNBQVMsRUFBRWdCLEdBQUcsZUFBZSxDQUFDLEVBQUU7b0JBQUUrQixXQUFXZ0g7b0JBQVF6RyxRQUFRO29CQUFXa0MsVUFBVSxDQUFDK0QsSUFBSS9ELFFBQVEsSUFBSSxLQUFLO29CQUFHYSxZQUFZO2dCQUFFO1lBQzlJLEVBQUUsT0FBT1UsR0FBRyxDQUFDO1lBRWIsTUFBTS9HLFlBQVksZ0JBQWdCO2dCQUFFZ0I7Z0JBQUkwQyxRQUFRO2dCQUFnQlg7WUFBVTtZQUUxRSxPQUFPSyxJQUFJRSxNQUFNLENBQUMsS0FBS0MsSUFBSSxDQUFDO2dCQUFFYSxJQUFJO2dCQUFNOEUsU0FBUztnQkFBR25HO1lBQVU7UUFDaEU7UUFFQSx3QkFBd0I7UUFDeEIsT0FBT0ssSUFBSUUsTUFBTSxDQUFDLEtBQUtDLElBQUksQ0FBQztZQUFFQyxPQUFPO1FBQXFCO0lBQzVELEVBQUUsT0FBTzNELEtBQUs7UUFDWkMsUUFBUTBELEtBQUssQ0FBQywwQkFBMEIzRDtRQUN4QyxPQUFPdUQsSUFBSUUsTUFBTSxDQUFDLEtBQUtDLElBQUksQ0FBQztZQUFFQyxPQUFPO1FBQXdCO0lBQy9EO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRpbmctbXZwLy4vcGFnZXMvYXBpL2NhbXBhaWduL1tpZF0vY29udHJvbC50cz82NzE2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHBhZ2VzL2FwaS9jYW1wYWlnbi9baWRdL2NvbnRyb2wudHMgXHJcbmltcG9ydCB0eXBlIHsgTmV4dEFwaVJlcXVlc3QsIE5leHRBcGlSZXNwb25zZSB9IGZyb20gJ25leHQnO1xyXG5pbXBvcnQgY2xpZW50UHJvbWlzZSBmcm9tICcuLi8uLi8uLi8uLi9saWIvbW9uZ28nO1xyXG5pbXBvcnQgeyByZWRpcyB9IGZyb20gJy4uLy4uLy4uLy4uL2xpYi9yZWRpcyc7XHJcbmltcG9ydCB7IFF1ZXVlIH0gZnJvbSAnYnVsbG1xJztcclxuaW1wb3J0IHsgT2JqZWN0SWQgfSBmcm9tICdtb25nb2RiJztcclxuXHJcbmNvbnN0IHF1ZXVlID0gbmV3IFF1ZXVlKCdjYW1wYWlnbnMnLCB7IGNvbm5lY3Rpb246IHJlZGlzIH0pO1xyXG5cclxuLy8ga2VlcCBwYXJpdHkgd2l0aCB3b3JrZXI7IGFsbG93IGVudiBvdmVycmlkZVxyXG5jb25zdCBNQVhfQVRURU1QVFMgPSBOdW1iZXIocHJvY2Vzcy5lbnYuTUFYX0FUVEVNUFRTIHx8IDMpO1xyXG4vLyBzZXJ2ZXItc2lkZSBjYXAgZm9yIGJhdGNoIHJldHJpZXMgcGVyIHJlcXVlc3RcclxuY29uc3QgQkFUQ0hfUkVUUllfTElNSVQgPSBOdW1iZXIocHJvY2Vzcy5lbnYuQkFUQ0hfUkVUUllfTElNSVQgfHwgNTAwMCk7XHJcbi8vIHdoZW4gcmVzdW1pbmcsIGxpbWl0IGhvdyBtYW55IHBlbmRpbmcgam9icyB3ZSdsbCB0cnkgdG8gKHJlKWVucXVldWVcclxuY29uc3QgUkVTVU1FX0VOUVVFVUVfTElNSVQgPSBOdW1iZXIocHJvY2Vzcy5lbnYuUkVTVU1FX0VOUVVFVUVfTElNSVQgfHwgNTAwMCk7XHJcbi8vIGhvdyBsb25nIGJlZm9yZSBhICdzZW5kaW5nJyByb3cgaXMgY29uc2lkZXJlZCBzdGFsZSBhbmQgZWxpZ2libGUgZm9yIHJlY292ZXJ5IChtcylcclxuY29uc3QgU1RBTEVfU0VORElOR19NUyA9IE51bWJlcihwcm9jZXNzLmVudi5TVEFMRV9TRU5ESU5HX01TIHx8IDkwXzAwMCk7XHJcblxyXG50eXBlIEFjdGlvbiA9ICdwYXVzZScgfCAncmVzdW1lJyB8ICdjYW5jZWwnIHwgJ2RlbGV0ZScgfCAncmV0cnlGYWlsZWQnIHwgJ3JldHJ5Q29udGFjdCc7XHJcblxyXG5hc3luYyBmdW5jdGlvbiBzYWZlSFNldChrZXk6IHN0cmluZywgb2JqOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KSB7XHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IHJlZGlzLmhzZXQoa2V5LCBvYmopO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgY29uc29sZS53YXJuKCdSZWRpcyB1bmF2YWlsYWJsZSB3aGlsZSBzZXR0aW5nIG1ldGEnLCBlcnIpO1xyXG4gIH1cclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gc2FmZVB1Ymxpc2goY2hhbm5lbDogc3RyaW5nLCBwYXlsb2FkOiBhbnkpIHtcclxuICB0cnkge1xyXG4gICAgYXdhaXQgcmVkaXMucHVibGlzaChjaGFubmVsLCBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ1JlZGlzIHB1Ymxpc2ggZmFpbGVkJywgZXJyKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIFJlbW92ZSB3YWl0aW5nL2RlbGF5ZWQvYWN0aXZlIGpvYnMgZm9yIGEgY2FtcGFpZ25JZCAoYmVzdC1lZmZvcnQpXHJcbmFzeW5jIGZ1bmN0aW9uIHJlbW92ZVF1ZXVlZEpvYnNGb3JDYW1wYWlnbihjYW1wYWlnbklkOiBzdHJpbmcpIHtcclxuICB0cnkge1xyXG4gICAgLy8gZ2V0IHdhaXRpbmcvZGVsYXllZC9hY3RpdmUgam9ic1xyXG4gICAgY29uc3Qgam9icyA9IGF3YWl0IHF1ZXVlLmdldEpvYnMoXHJcbiAgICAgIFsnd2FpdGluZycsICdkZWxheWVkJywgJ2FjdGl2ZScsICdwYXVzZWQnXSxcclxuICAgICAgMCxcclxuICAgICAgLTFcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgbWF0Y2hlZCA9IGpvYnMuZmlsdGVyKChqKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIGouZGF0YT8uY2FtcGFpZ25JZCA9PT0gY2FtcGFpZ25JZDtcclxuICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IGogb2YgbWF0Y2hlZCkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIGlmIHRoZSBqb2IgaXMgYWN0aXZlLCByZW1vdmUgbWF5IGZhaWwgLSBzdGlsbCB0cnlcclxuICAgICAgICBhd2FpdCBqLnJlbW92ZSgpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gYmVzdC1lZmZvcnQg4oCUIGlnbm9yZVxyXG4gICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIHJlbW92ZSBqb2IgJHtqLmlkfWAsIGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWF0Y2hlZC5sZW5ndGg7XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBlbnVtZXJhdGUvcmVtb3ZlIGpvYnMgZm9yIGNhbXBhaWduJywgZXJyKTtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxufVxyXG5cclxuLy8gc2FmZSByZWFkIG9mIHJlZGlzIG1ldGEgaW50ZWdlciBmaWVsZFxyXG5hc3luYyBmdW5jdGlvbiBzYWZlR2V0TWV0YUludChyZWRpc0tleTogc3RyaW5nLCBmaWVsZDogc3RyaW5nKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHYgPSBhd2FpdCByZWRpcy5oZ2V0KHJlZGlzS2V5LCBmaWVsZCk7XHJcbiAgICByZXR1cm4gTnVtYmVyKHYgfHwgMCk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRW5zdXJlIHRoZXJlIGlzIGEgdXNhYmxlIGBjYW1wYWlnbjp7aWR9OmRlZmluaXRpb25gIGluIFJlZGlzLlxyXG4gKiBJZiBtaXNzaW5nLCBhdHRlbXB0IHRvIGNvbnN0cnVjdCBvbmUgZnJvbSB0aGUgTW9uZ28gY2FtcGFpZ24gZG9jdW1lbnQuXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiBkZWZpbml0aW9uIGV4aXN0cyBvciB3YXMgd3JpdHRlbiBzdWNjZXNzZnVsbHkuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBlbnN1cmVDYW1wYWlnbkRlZmluaXRpb24oaWQ6IHN0cmluZywgY2FtcGFpZ25Eb2M6IGFueSk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gIGNvbnN0IGtleSA9IGBjYW1wYWlnbjoke2lkfTpkZWZpbml0aW9uYDtcclxuICB0cnkge1xyXG4gICAgY29uc3QgZXhpc3RpbmcgPSBhd2FpdCByZWRpcy5nZXQoa2V5KTtcclxuICAgIGlmIChleGlzdGluZykgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgLy8gQXR0ZW1wdCB0byBidWlsZCBhIG1pbmltYWwgY29tcGF0aWJsZSBkZWZpbml0aW9uXHJcbiAgICAvLyBXb3JrZXIgZXhwZWN0cyB7IGluaXRpYWw6IHsgc3ViamVjdCwgYm9keSB9LCBmb2xsb3dVcHM6IFsuLi5dIH1cclxuICAgIGxldCBidWlsdDogYW55ID0gbnVsbDtcclxuXHJcbiAgICAvLyBQcmVmZXIgZXhwbGljaXQgc2hhcGVzIGNvbW1vbmx5IHVzZWRcclxuICAgIGlmIChjYW1wYWlnbkRvYz8uZGVmaW5pdGlvbiAmJiB0eXBlb2YgY2FtcGFpZ25Eb2MuZGVmaW5pdGlvbiA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgYnVpbHQgPSBjYW1wYWlnbkRvYy5kZWZpbml0aW9uO1xyXG4gICAgfSBlbHNlIGlmIChjYW1wYWlnbkRvYz8uaW5pdGlhbCAmJiB0eXBlb2YgY2FtcGFpZ25Eb2MuaW5pdGlhbCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgYnVpbHQgPSB7IGluaXRpYWw6IGNhbXBhaWduRG9jLmluaXRpYWwsIGZvbGxvd1VwczogY2FtcGFpZ25Eb2MuZm9sbG93VXBzIHx8IFtdIH07XHJcbiAgICB9IGVsc2UgaWYgKGNhbXBhaWduRG9jPy50ZW1wbGF0ZSAmJiB0eXBlb2YgY2FtcGFpZ25Eb2MudGVtcGxhdGUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIGJ1aWx0ID0geyBpbml0aWFsOiB7IHN1YmplY3Q6IGNhbXBhaWduRG9jLnRlbXBsYXRlLnN1YmplY3QgfHwgY2FtcGFpZ25Eb2MubmFtZSwgYm9keTogY2FtcGFpZ25Eb2MudGVtcGxhdGUuYm9keSB8fCBjYW1wYWlnbkRvYy5jb250ZW50IHx8ICcnIH0sIGZvbGxvd1VwczogY2FtcGFpZ25Eb2MudGVtcGxhdGUuZm9sbG93VXBzIHx8IGNhbXBhaWduRG9jLmZvbGxvd1VwcyB8fCBbXSB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gZmFsbGJhY2s6IHRyeSB0byBnbGVhbiBzdWJqZWN0L2JvZHkgZnJvbSBjb21tb24gZmllbGRzXHJcbiAgICAgIGNvbnN0IHN1YmplY3QgPSBjYW1wYWlnbkRvYz8uc3ViamVjdCB8fCBjYW1wYWlnbkRvYz8udGl0bGUgfHwgY2FtcGFpZ25Eb2M/Lm5hbWUgfHwgYENhbXBhaWduICR7aWR9YDtcclxuICAgICAgY29uc3QgYm9keSA9IGNhbXBhaWduRG9jPy5ib2R5IHx8IGNhbXBhaWduRG9jPy5jb250ZW50IHx8IGNhbXBhaWduRG9jPy5odG1sIHx8ICcnO1xyXG4gICAgICBjb25zdCBmb2xsb3dVcHMgPSBjYW1wYWlnbkRvYz8uZm9sbG93VXBzIHx8IGNhbXBhaWduRG9jPy5zdGVwcyB8fCBbXTtcclxuICAgICAgYnVpbHQgPSB7IGluaXRpYWw6IHsgc3ViamVjdCwgYm9keSB9LCBmb2xsb3dVcHMgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBidWlsdCBkb2Vzbid0IGxvb2sgcmlnaHQgKG5vIGluaXRpYWwgc3ViamVjdC9ib2R5KSwgZmFpbCBzYWZlXHJcbiAgICBpZiAoIWJ1aWx0IHx8ICFidWlsdC5pbml0aWFsIHx8IChidWlsdC5pbml0aWFsLnN1YmplY3QgPT0gbnVsbCAmJiBidWlsdC5pbml0aWFsLmJvZHkgPT0gbnVsbCkpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gY29uc3RydWN0IGNhbXBhaWduIGRlZmluaXRpb24gZnJvbSBjYW1wYWlnbiBkb2N1bWVudCcsIHsgY2FtcGFpZ25JZDogaWQsIHNhbXBsZTogY2FtcGFpZ25Eb2MgPyBPYmplY3Qua2V5cyhjYW1wYWlnbkRvYykuc2xpY2UoMCwgOCkgOiBudWxsIH0pO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGVyc2lzdCBpbnRvIFJlZGlzIChubyBleHBpcnkpIHNvIHdvcmtlciBjYW4gcmVhZCBpdFxyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgcmVkaXMuc2V0KGtleSwgSlNPTi5zdHJpbmdpZnkoYnVpbHQpKTtcclxuICAgICAgY29uc29sZS5sb2coYFdyb3RlIGZhbGxiYWNrIGNhbXBhaWduIGRlZmluaXRpb24gaW50byByZWRpcyBmb3IgJHtpZH1gKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHdyaXRlIGNhbXBhaWduIGRlZmluaXRpb24gdG8gcmVkaXMnLCBlKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGNvbnNvbGUud2FybignRXJyb3IgY2hlY2tpbmcvd3JpdGluZyBjYW1wYWlnbiBkZWZpbml0aW9uIGluIHJlZGlzJywgZSk7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IGEgc2V0IG9mIGNvbnRhY3RJZCBzdHJpbmdzIGZvciBqb2JzIGN1cnJlbnRseSBlbnF1ZXVlZCBmb3IgdGhpcyBjYW1wYWlnbi5cclxuICogVXNlZCB0byBhdm9pZCBlbnF1ZXVpbmcgZHVwbGljYXRlcyB3aGVuIHJlc3VtaW5nLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZ2V0UXVldWVkQ29udGFjdElkc0ZvckNhbXBhaWduKGNhbXBhaWduSWQ6IHN0cmluZyk6IFByb21pc2U8U2V0PHN0cmluZz4+IHtcclxuICBjb25zdCBzZXQgPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgam9icyA9IGF3YWl0IHF1ZXVlLmdldEpvYnMoWyd3YWl0aW5nJywgJ2RlbGF5ZWQnLCAnYWN0aXZlJywgJ3BhdXNlZCddLCAwLCAtMSk7XHJcbiAgICBmb3IgKGNvbnN0IGogb2Ygam9icykge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmIChqLmRhdGE/LmNhbXBhaWduSWQgPT09IGNhbXBhaWduSWQgJiYgai5kYXRhPy5jb250YWN0SWQpIHtcclxuICAgICAgICAgIHNldC5hZGQoU3RyaW5nKGouZGF0YS5jb250YWN0SWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgIC8vIGlnbm9yZSBtYWxmb3JtZWQgam9ic1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gbGlzdCBxdWV1ZWQgam9icyBmb3IgY2FtcGFpZ24gd2hlbiBjaGVja2luZyBkdXBsaWNhdGVzJywgZSk7XHJcbiAgfVxyXG4gIHJldHVybiBzZXQ7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIoXHJcbiAgcmVxOiBOZXh0QXBpUmVxdWVzdCxcclxuICByZXM6IE5leHRBcGlSZXNwb25zZVxyXG4pIHtcclxuICBpZiAocmVxLm1ldGhvZCAhPT0gJ1BPU1QnKSB7XHJcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDUpLmpzb24oeyBlcnJvcjogJ01ldGhvZCBub3QgYWxsb3dlZCcgfSk7XHJcbiAgfVxyXG5cclxuICBjb25zdCB7IGlkIH0gPSByZXEucXVlcnk7XHJcbiAgaWYgKCFpZCB8fCB0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBlcnJvcjogJ0ludmFsaWQgY2FtcGFpZ24gaWQnIH0pO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgeyBhY3Rpb24sIGNvbmZpcm0sIGNvbnRhY3RJZCB9ID0gcmVxLmJvZHkgYXMge1xyXG4gICAgYWN0aW9uPzogQWN0aW9uO1xyXG4gICAgY29uZmlybT86IGJvb2xlYW47XHJcbiAgICBjb250YWN0SWQ/OiBzdHJpbmc7XHJcbiAgfTtcclxuXHJcbiAgaWYgKCFhY3Rpb24gfHwgIVsncGF1c2UnLCAncmVzdW1lJywgJ2NhbmNlbCcsICdkZWxldGUnLCAncmV0cnlGYWlsZWQnLCAncmV0cnlDb250YWN0J10uaW5jbHVkZXMoYWN0aW9uKSkge1xyXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgZXJyb3I6ICdJbnZhbGlkIGFjdGlvbicgfSk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBjbGllbnQgPSBhd2FpdCBjbGllbnRQcm9taXNlO1xyXG4gIGNvbnN0IGRiID0gY2xpZW50LmRiKCdQbGF0Zm9ybURhdGEnKTtcclxuICBjb25zdCBjYW1wYWlnbk9iamVjdElkID0gbmV3IE9iamVjdElkKGlkKTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIFJlbG9hZCBjYW1wYWlnbiBmcm9tIE1vbmdvIChhdXRob3JpdGF0aXZlKVxyXG4gICAgY29uc3QgY2FtcGFpZ24gPSBhd2FpdCBkYlxyXG4gICAgICAuY29sbGVjdGlvbignY2FtcGFpZ25zJylcclxuICAgICAgLmZpbmRPbmUoeyBfaWQ6IGNhbXBhaWduT2JqZWN0SWQgfSk7XHJcblxyXG4gICAgaWYgKCFjYW1wYWlnbikge1xyXG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDQpLmpzb24oeyBlcnJvcjogJ0NhbXBhaWduIG5vdCBmb3VuZCcgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTGlnaHR3ZWlnaHQgaGVscGVyc1xyXG4gICAgY29uc3QgcmVkaXNLZXkgPSBgY2FtcGFpZ246JHtpZH06bWV0YWA7XHJcblxyXG4gICAgLy8gQUNUSU9OOiBQYXVzZVxyXG4gICAgaWYgKGFjdGlvbiA9PT0gJ3BhdXNlJykge1xyXG4gICAgICBpZiAoY2FtcGFpZ24uc3RhdHVzID09PSAncGF1c2VkJykge1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7IG9rOiB0cnVlLCBtZXNzYWdlOiAnQWxyZWFkeSBwYXVzZWQnIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWducycpLnVwZGF0ZU9uZShcclxuICAgICAgICB7IF9pZDogY2FtcGFpZ25PYmplY3RJZCB9LFxyXG4gICAgICAgIHsgJHNldDogeyBzdGF0dXM6ICdwYXVzZWQnIH0gfVxyXG4gICAgICApO1xyXG4gICAgICBhd2FpdCBzYWZlSFNldChyZWRpc0tleSwgeyBzdGF0dXM6ICdwYXVzZWQnIH0pO1xyXG4gICAgICAvLyBwdWJsaXNoIGNhbXBhaWduLWxldmVsIGV2ZW50IHNvIFVJIGRpc2FibGVzIHJldHJ5IGJ1dHRvbnMgYW5kIHVwZGF0ZXMgc3RhdGVcclxuICAgICAgYXdhaXQgc2FmZVB1Ymxpc2goJ2NhbXBhaWduOm5ldycsIHsgaWQsIHN0YXR1czogJ3BhdXNlZCcgfSk7XHJcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7IG9rOiB0cnVlLCBhY3Rpb246ICdwYXVzZWQnIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFDVElPTjogUmVzdW1lXHJcbiAgICBpZiAoYWN0aW9uID09PSAncmVzdW1lJykge1xyXG4gICAgICBpZiAoY2FtcGFpZ24uc3RhdHVzID09PSAncnVubmluZycpIHtcclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oeyBvazogdHJ1ZSwgbWVzc2FnZTogJ0FscmVhZHkgcnVubmluZycgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHNldCBydW5uaW5nIGluIERCICsgcmVkaXNcclxuICAgICAgYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25zJykudXBkYXRlT25lKFxyXG4gICAgICAgIHsgX2lkOiBjYW1wYWlnbk9iamVjdElkIH0sXHJcbiAgICAgICAgeyAkc2V0OiB7IHN0YXR1czogJ3J1bm5pbmcnIH0gfVxyXG4gICAgICApO1xyXG4gICAgICBhd2FpdCBzYWZlSFNldChyZWRpc0tleSwgeyBzdGF0dXM6ICdydW5uaW5nJyB9KTtcclxuICAgICAgYXdhaXQgc2FmZVB1Ymxpc2goJ2NhbXBhaWduOm5ldycsIHsgaWQsIHN0YXR1czogJ3J1bm5pbmcnIH0pO1xyXG5cclxuICAgICAgLy8gUmUtZW5xdWV1ZSBwZW5kaW5nIGNvbnRhY3RzIHRoYXQgY3VycmVudGx5IGhhdmUgbm8gcXVldWVkIGpvYiBmb3IgdGhpcyBjYW1wYWlnbi5cclxuICAgICAgLy8gVGhpcyBhZGRyZXNzZXMgY2FzZXMgd2hlcmUgam9icyB3ZXJlIHJlbW92ZWQgb3Igbm90IGVucXVldWVkIHdoaWxlIHRoZSBjYW1wYWlnbiB3YXMgcGF1c2VkLFxyXG4gICAgICAvLyBlbnN1cmluZyBwZW5kaW5nIHJvd3MgYWN0dWFsbHkgZ2V0IHByb2Nlc3NlZCBhZ2FpbiBhZnRlciByZXN1bWUuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcXVldWVkU2V0ID0gYXdhaXQgZ2V0UXVldWVkQ29udGFjdElkc0ZvckNhbXBhaWduKGlkKTtcclxuXHJcbiAgICAgICAgLy8gZmV0Y2ggcGVuZGluZyBkb2NzIChsaW1pdCB0byBhIHNhbmUgY2FwKVxyXG4gICAgICAgIGNvbnN0IHBlbmRpbmdDdXJzb3IgPSBkYi5jb2xsZWN0aW9uKCdjYW1wYWlnbl9jb250YWN0cycpLmZpbmQoXHJcbiAgICAgICAgICB7IGNhbXBhaWduSWQ6IGNhbXBhaWduT2JqZWN0SWQsIHN0YXR1czogJ3BlbmRpbmcnIH0sXHJcbiAgICAgICAgICB7IHByb2plY3Rpb246IHsgX2lkOiAxLCBjb250YWN0SWQ6IDEsIHN0ZXA6IDEgfSB9XHJcbiAgICAgICAgKS5saW1pdChSRVNVTUVfRU5RVUVVRV9MSU1JVCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHBlbmRpbmc6IGFueVtdID0gYXdhaXQgcGVuZGluZ0N1cnNvci50b0FycmF5KCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGVucXVldWVQcm9taXNlczogUHJvbWlzZTxhbnk+W10gPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGQgb2YgcGVuZGluZykge1xyXG4gICAgICAgICAgY29uc3QgY2lkID0gZC5jb250YWN0SWQgPyAoZC5jb250YWN0SWQudG9TdHJpbmcgPyBkLmNvbnRhY3RJZC50b1N0cmluZygpIDogU3RyaW5nKGQuY29udGFjdElkKSkgOiAoZC5faWQudG9TdHJpbmcgPyBkLl9pZC50b1N0cmluZygpIDogU3RyaW5nKGQuX2lkKSk7XHJcbiAgICAgICAgICBpZiAocXVldWVkU2V0LmhhcyhjaWQpKSBjb250aW51ZTsgLy8gYWxyZWFkeSBxdWV1ZWRcclxuXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBlbnF1ZXVlUHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICBxdWV1ZS5hZGQoXHJcbiAgICAgICAgICAgICAgICBkLnN0ZXAgPyAnZm9sbG93dXAnIDogJ2luaXRpYWwnLFxyXG4gICAgICAgICAgICAgICAgeyBjYW1wYWlnbklkOiBpZCwgY29udGFjdElkOiBjaWQsIHN0ZXA6IGQuc3RlcCB9LFxyXG4gICAgICAgICAgICAgICAgeyByZW1vdmVPbkNvbXBsZXRlOiB0cnVlLCByZW1vdmVPbkZhaWw6IHRydWUsIGF0dGVtcHRzOiBNQVhfQVRURU1QVFMsIGJhY2tvZmY6IHsgdHlwZTogJ2V4cG9uZW50aWFsJywgZGVsYXk6IDYwXzAwMCB9IH1cclxuICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGVucXVldWUgcGVuZGluZyBjb250YWN0IG9uIHJlc3VtZScsIGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYXR0ZW1wdCB0byBlbnF1ZXVlIGluIHBhcmFsbGVsIChiZXN0LWVmZm9ydClcclxuICAgICAgICBpZiAoZW5xdWV1ZVByb21pc2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChlbnF1ZXVlUHJvbWlzZXMpO1xyXG4gICAgICAgICAgLy8gbm90aWZ5IFVJIHRoYXQgY29udGFjdHMgaGF2ZSBiZWVuIHJlLXF1ZXVlZCAoY291bnRzIHVuY2hhbmdlZCwgYnV0IFVJIG1heSB3YW50IHRvIHJlZnJlc2gpXHJcbiAgICAgICAgICBhd2FpdCBzYWZlUHVibGlzaCgnY2FtcGFpZ246bmV3JywgeyBpZCwgYWN0aW9uOiAncmVzdW1lX3JlcXVldWVkJywgcmVxdWV1ZWQ6IGVucXVldWVQcm9taXNlcy5sZW5ndGggfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcmUtZW5xdWV1ZSBwZW5kaW5nIGNvbnRhY3RzIG9uIHJlc3VtZScsIGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZWNvdmVyIHN0YWxlICdzZW5kaW5nJyBsZWRnZXIgcm93cyB0aGF0IG1heSBoYXZlIGJlZW4gbGVmdCBpbiAnc2VuZGluZycgYnkgYSBjcmFzaGVkIHdvcmtlciBvciBraWxsZWQgcHJvY2Vzcy5cclxuICAgICAgLy8gQ3JpdGVyaWE6IHN0YXR1cyA9PT0gJ3NlbmRpbmcnIEFORCBsYXN0QXR0ZW1wdEF0IG9sZGVyIHRoYW4gU1RBTEVfU0VORElOR19NUyBBTkQgYmdBdHRlbXB0cyA8IE1BWF9BVFRFTVBUU1xyXG4gICAgICAvLyBXZSdsbCBzZXQgdGhlbSBiYWNrIHRvICdwZW5kaW5nJywgcmVzZXQgYmdBdHRlbXB0cyB0byAwIChzbyBiYWNrZ3JvdW5kIGN5Y2xlIHJlc3RhcnRzKSwgYW5kIGVucXVldWUgam9icy5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBjdXRvZmYgPSBuZXcgRGF0ZShEYXRlLm5vdygpIC0gU1RBTEVfU0VORElOR19NUyk7XHJcbiAgICAgICAgY29uc3Qgc3RhbGVDdXJzb3IgPSBkYi5jb2xsZWN0aW9uKCdjYW1wYWlnbl9jb250YWN0cycpLmZpbmQoXHJcbiAgICAgICAgICB7IGNhbXBhaWduSWQ6IGNhbXBhaWduT2JqZWN0SWQsIHN0YXR1czogJ3NlbmRpbmcnLCBsYXN0QXR0ZW1wdEF0OiB7ICRsdDogY3V0b2ZmIH0gfSxcclxuICAgICAgICAgIHsgcHJvamVjdGlvbjogeyBfaWQ6IDEsIGNvbnRhY3RJZDogMSwgc3RlcDogMSwgYmdBdHRlbXB0czogMSB9IH1cclxuICAgICAgICApLmxpbWl0KFJFU1VNRV9FTlFVRVVFX0xJTUlUKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc3RhbGVEb2NzID0gYXdhaXQgc3RhbGVDdXJzb3IudG9BcnJheSgpO1xyXG4gICAgICAgIGlmIChzdGFsZURvY3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgY29uc3QgaWRzID0gc3RhbGVEb2NzLm1hcChkID0+IGQuX2lkKTtcclxuICAgICAgICAgIC8vIFJlc2V0IHRvIHBlbmRpbmcgYW5kIGNsZWFyIGxhc3RFcnJvciwgcmVzZXQgYmdBdHRlbXB0cyBzbyBiYWNrZ3JvdW5kIHJldHJpZXMgc3RhcnQgZnJlc2hcclxuICAgICAgICAgIGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWduX2NvbnRhY3RzJykudXBkYXRlTWFueShcclxuICAgICAgICAgICAgeyBfaWQ6IHsgJGluOiBpZHMgfSB9LFxyXG4gICAgICAgICAgICB7ICRzZXQ6IHsgc3RhdHVzOiAncGVuZGluZycsIGxhc3RFcnJvcjogbnVsbCwgYmdBdHRlbXB0czogMCB9IH1cclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgLy8gRW5xdWV1ZSBlYWNoIHN0YWxlIGRvYyBpZiBub3QgYWxyZWFkeSBxdWV1ZWRcclxuICAgICAgICAgIGNvbnN0IHF1ZXVlZFNldDIgPSBhd2FpdCBnZXRRdWV1ZWRDb250YWN0SWRzRm9yQ2FtcGFpZ24oaWQpO1xyXG4gICAgICAgICAgY29uc3QgcmVxdWV1ZVByb21pc2VzOiBQcm9taXNlPGFueT5bXSA9IFtdO1xyXG4gICAgICAgICAgZm9yIChjb25zdCBkIG9mIHN0YWxlRG9jcykge1xyXG4gICAgICAgICAgICBjb25zdCBjaWQgPSBkLmNvbnRhY3RJZCA/IChkLmNvbnRhY3RJZC50b1N0cmluZyA/IGQuY29udGFjdElkLnRvU3RyaW5nKCkgOiBTdHJpbmcoZC5jb250YWN0SWQpKSA6IChkLl9pZC50b1N0cmluZyA/IGQuX2lkLnRvU3RyaW5nKCkgOiBTdHJpbmcoZC5faWQpKTtcclxuICAgICAgICAgICAgaWYgKHF1ZXVlZFNldDIuaGFzKGNpZCkpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIHJlcXVldWVQcm9taXNlcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgcXVldWUuYWRkKFxyXG4gICAgICAgICAgICAgICAgICBkLnN0ZXAgPyAnZm9sbG93dXAnIDogJ2luaXRpYWwnLFxyXG4gICAgICAgICAgICAgICAgICB7IGNhbXBhaWduSWQ6IGlkLCBjb250YWN0SWQ6IGNpZCwgc3RlcDogZC5zdGVwIH0sXHJcbiAgICAgICAgICAgICAgICAgIHsgcmVtb3ZlT25Db21wbGV0ZTogdHJ1ZSwgcmVtb3ZlT25GYWlsOiB0cnVlLCBhdHRlbXB0czogTUFYX0FUVEVNUFRTLCBiYWNrb2ZmOiB7IHR5cGU6ICdleHBvbmVudGlhbCcsIGRlbGF5OiA2MF8wMDAgfSB9XHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGVucXVldWUgc3RhbGUgc2VuZGluZyBjb250YWN0IG9uIHJlc3VtZScsIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHB1Ymxpc2ggY29udGFjdC1sZXZlbCB1cGRhdGUgaGludCBzbyBVSSByZWZsZWN0cyBpdCdzIG5vdyBwZW5kaW5nXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgc2FmZVB1Ymxpc2goYGNhbXBhaWduOiR7aWR9OmNvbnRhY3RfdXBkYXRlYCwgeyBjb250YWN0SWQ6IGNpZCwgc3RhdHVzOiAncGVuZGluZycsIGJnQXR0ZW1wdHM6IDAsIGF0dGVtcHRzOiB1bmRlZmluZWQgfSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHt9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHJlcXVldWVQcm9taXNlcy5sZW5ndGggPiAwKSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQocmVxdWV1ZVByb21pc2VzKTtcclxuICAgICAgICAgIGF3YWl0IHNhZmVQdWJsaXNoKCdjYW1wYWlnbjpuZXcnLCB7IGlkLCBhY3Rpb246ICdyZXN1bWVfcmVjb3ZlcmVkX3NlbmRpbmcnLCByZWNvdmVyZWQ6IHN0YWxlRG9jcy5sZW5ndGggfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcmVjb3ZlciBzdGFsZSBzZW5kaW5nIHJvd3Mgb24gcmVzdW1lJywgZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7IG9rOiB0cnVlLCBhY3Rpb246ICdyZXN1bWVkJyB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBQ1RJT046IENhbmNlbFxyXG4gICAgaWYgKGFjdGlvbiA9PT0gJ2NhbmNlbCcpIHtcclxuICAgICAgaWYgKGNhbXBhaWduLnN0YXR1cyA9PT0gJ2NhbmNlbGxlZCcpIHtcclxuICAgICAgICByZXR1cm4gcmVzXHJcbiAgICAgICAgICAuc3RhdHVzKDIwMClcclxuICAgICAgICAgIC5qc29uKHsgb2s6IHRydWUsIG1lc3NhZ2U6ICdBbHJlYWR5IGNhbmNlbGxlZCcgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIDEpIE1hcmsgY2FtcGFpZ24gY2FuY2VsbGVkIGFuZCBjb21wbGV0ZWRBdFxyXG4gICAgICBjb25zdCBjb21wbGV0ZWRBdCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgIGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWducycpLnVwZGF0ZU9uZShcclxuICAgICAgICB7IF9pZDogY2FtcGFpZ25PYmplY3RJZCB9LFxyXG4gICAgICAgIHsgJHNldDogeyBzdGF0dXM6ICdjYW5jZWxsZWQnLCBjb21wbGV0ZWRBdCB9IH1cclxuICAgICAgKTtcclxuICAgICAgYXdhaXQgc2FmZUhTZXQocmVkaXNLZXksIHsgc3RhdHVzOiAnY2FuY2VsbGVkJyB9KTtcclxuXHJcbiAgICAgIC8vIDIpIEZpbmQgYW5kIGF0b21pY2FsbHkgbWFyayBwZW5kaW5nIGxlZGdlciByb3dzIGFzIGZhaWxlZCAoc2luZ2xlIHVwZGF0ZU1hbnkpXHJcbiAgICAgIGNvbnN0IGZpbHRlciA9IHsgY2FtcGFpZ25JZDogY2FtcGFpZ25PYmplY3RJZCwgc3RhdHVzOiAncGVuZGluZycgfTtcclxuICAgICAgY29uc3QgdXBkYXRlID0ge1xyXG4gICAgICAgICRzZXQ6IHtcclxuICAgICAgICAgIHN0YXR1czogJ2ZhaWxlZCcsXHJcbiAgICAgICAgICBsYXN0RXJyb3I6ICdjYW5jZWxsZWQnLFxyXG4gICAgICAgICAgbGFzdEF0dGVtcHRBdDogY29tcGxldGVkQXQsXHJcbiAgICAgICAgfSxcclxuICAgICAgICAkaW5jOiB7IGF0dGVtcHRzOiAxIH0sXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCB1cGRhdGVSZXN1bHQgPSBhd2FpdCBkYlxyXG4gICAgICAgIC5jb2xsZWN0aW9uKCdjYW1wYWlnbl9jb250YWN0cycpXHJcbiAgICAgICAgLnVwZGF0ZU1hbnkoZmlsdGVyLCB1cGRhdGUpO1xyXG5cclxuICAgICAgY29uc3QgY2FuY2VsbGVkQ291bnQgPSB1cGRhdGVSZXN1bHQubW9kaWZpZWRDb3VudCA/PyAwO1xyXG5cclxuICAgICAgLy8gMykgVXBkYXRlIFJlZGlzIGNvdW50ZXJzIChiZXN0LWVmZm9ydClcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAoY2FuY2VsbGVkQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICBhd2FpdCByZWRpcy5oaW5jcmJ5KHJlZGlzS2V5LCAncHJvY2Vzc2VkJywgY2FuY2VsbGVkQ291bnQpO1xyXG4gICAgICAgICAgYXdhaXQgcmVkaXMuaGluY3JieShyZWRpc0tleSwgJ2ZhaWxlZCcsIGNhbmNlbGxlZENvdW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byB1cGRhdGUgcmVkaXMgY291bnRlcnMgZHVyaW5nIGNhbmNlbCcsIGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyA0KSBQZXJzaXN0IHRvdGFscyBzbmFwc2hvdCB0byBjYW1wYWlnbnMudG90YWxzIChyZWFkIHJlZGlzIGlmIGF2YWlsYWJsZSwgZmFsbGJhY2sgdG8gZGIpXHJcbiAgICAgIGxldCBtZXRhID0ge307XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgbWV0YSA9IChhd2FpdCByZWRpcy5oZ2V0YWxsKHJlZGlzS2V5KSkgfHwge307XHJcbiAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgIG1ldGEgPSB7fTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ29tcHV0ZSB0b3RhbHMgZmluYWwgdmFsdWVzIGNvbWJpbmluZyBwZXJzaXN0ZWQgdG90YWxzIGFuZCBvdXIgY2FuY2VsbGVkQ291bnQgYXMgZmFsbGJhY2tcclxuICAgICAgY29uc3QgcHJvY2Vzc2VkTm93ID0gTnVtYmVyKG1ldGFbJ3Byb2Nlc3NlZCddID8/IChjYW1wYWlnbi50b3RhbHM/LnByb2Nlc3NlZCA/PyAwKSArIGNhbmNlbGxlZENvdW50KTtcclxuICAgICAgY29uc3Qgc2VudE5vdyA9IE51bWJlcihtZXRhWydzZW50J10gPz8gKGNhbXBhaWduLnRvdGFscz8uc2VudCA/PyAwKSk7XHJcbiAgICAgIGNvbnN0IGZhaWxlZE5vdyA9IE51bWJlcihtZXRhWydmYWlsZWQnXSA/PyAoY2FtcGFpZ24udG90YWxzPy5mYWlsZWQgPz8gMCkgKyBjYW5jZWxsZWRDb3VudCk7XHJcblxyXG4gICAgICBhd2FpdCBkYi5jb2xsZWN0aW9uKCdjYW1wYWlnbnMnKS51cGRhdGVPbmUoXHJcbiAgICAgICAgeyBfaWQ6IGNhbXBhaWduT2JqZWN0SWQgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAkc2V0OiB7XHJcbiAgICAgICAgICAgICd0b3RhbHMucHJvY2Vzc2VkJzogcHJvY2Vzc2VkTm93LFxyXG4gICAgICAgICAgICAndG90YWxzLnNlbnQnOiBzZW50Tm93LFxyXG4gICAgICAgICAgICAndG90YWxzLmZhaWxlZCc6IGZhaWxlZE5vdyxcclxuICAgICAgICAgICAgY29tcGxldGVkQXQsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH1cclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIDUpIFJlbW92ZSBxdWV1ZWQgam9icyBmb3IgdGhpcyBjYW1wYWlnbiAoYmVzdC1lZmZvcnQpXHJcbiAgICAgIGNvbnN0IHJlbW92ZWRKb2JzID0gYXdhaXQgcmVtb3ZlUXVldWVkSm9ic0ZvckNhbXBhaWduKGlkKTtcclxuXHJcbiAgICAgIC8vIDYpIFB1Ymxpc2ggZXZlbnRcclxuICAgICAgYXdhaXQgc2FmZVB1Ymxpc2goJ2NhbXBhaWduOm5ldycsIHsgaWQsIHN0YXR1czogJ2NhbmNlbGxlZCcsIGNhbmNlbGxlZENvdW50LCByZW1vdmVkSm9icyB9KTtcclxuXHJcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7XHJcbiAgICAgICAgb2s6IHRydWUsXHJcbiAgICAgICAgYWN0aW9uOiAnY2FuY2VsbGVkJyxcclxuICAgICAgICBjYW5jZWxsZWRDb3VudCxcclxuICAgICAgICByZW1vdmVkSm9icyxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQUNUSU9OOiBEZWxldGVcclxuICAgIGlmIChhY3Rpb24gPT09ICdkZWxldGUnKSB7XHJcbiAgICAgIC8vIFJlcXVpcmUgZXhwbGljaXQgY29uZmlybWF0aW9uIOKAlCBzYWZlZ3VhcmRzIGluIFVJIG11c3Qgc2V0IGNvbmZpcm09dHJ1ZVxyXG4gICAgICBpZiAoY29uZmlybSAhPT0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybiByZXNcclxuICAgICAgICAgIC5zdGF0dXMoNDAwKVxyXG4gICAgICAgICAgLmpzb24oeyBlcnJvcjogJ0RlbGV0aW9uIHJlcXVpcmVzIGNvbmZpcm09dHJ1ZSBpbiByZXF1ZXN0IGJvZHknIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBQcmV2ZW50IGFjY2lkZW50YWwgZGVsZXRpb24gd2hpbGUgcnVubmluZ1xyXG4gICAgICBpZiAoY2FtcGFpZ24uc3RhdHVzID09PSAncnVubmluZycpIHtcclxuICAgICAgICByZXR1cm4gcmVzXHJcbiAgICAgICAgICAuc3RhdHVzKDQwMClcclxuICAgICAgICAgIC5qc29uKHsgZXJyb3I6ICdDYW5jZWwgdGhlIGNhbXBhaWduIGJlZm9yZSBkZWxldGlvbicgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbW92ZSBxdWV1ZWQgam9icyAoYmVzdC1lZmZvcnQpXHJcbiAgICAgIGNvbnN0IHJlbW92ZWRKb2JzID0gYXdhaXQgcmVtb3ZlUXVldWVkSm9ic0ZvckNhbXBhaWduKGlkKTtcclxuXHJcbiAgICAgIC8vIERlbGV0ZSBSZWRpcyBrZXlzIChiZXN0LWVmZm9ydClcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCByZWRpcy5kZWwoYGNhbXBhaWduOiR7aWR9Om1ldGFgKTtcclxuICAgICAgICBhd2FpdCByZWRpcy5kZWwoYGNhbXBhaWduOiR7aWR9OmRlZmluaXRpb25gKTtcclxuICAgICAgICBhd2FpdCByZWRpcy5zcmVtKCdjYW1wYWlnbjphbGwnLCBpZCk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ1JlZGlzIGNsZWFudXAgb24gZGVsZXRlIGZhaWxlZCcsIGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEZWxldGUgTW9uZ28gZG9jc1xyXG4gICAgICBjb25zdCBbY2FtcGFpZ25EZWwsIGxlZGdlckRlbF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgZGIuY29sbGVjdGlvbignY2FtcGFpZ25zJykuZGVsZXRlT25lKHsgX2lkOiBjYW1wYWlnbk9iamVjdElkIH0pLFxyXG4gICAgICAgIGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWduX2NvbnRhY3RzJykuZGVsZXRlTWFueSh7IGNhbXBhaWduSWQ6IGNhbXBhaWduT2JqZWN0SWQgfSksXHJcbiAgICAgIF0pO1xyXG5cclxuICAgICAgYXdhaXQgc2FmZVB1Ymxpc2goJ2NhbXBhaWduOm5ldycsIHsgaWQsIHN0YXR1czogJ2RlbGV0ZWQnIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHtcclxuICAgICAgICBvazogdHJ1ZSxcclxuICAgICAgICBhY3Rpb246ICdkZWxldGVkJyxcclxuICAgICAgICBjYW1wYWlnbkRlbGV0ZWQ6IGNhbXBhaWduRGVsLmRlbGV0ZWRDb3VudCA/PyAwLFxyXG4gICAgICAgIGxlZGdlckRlbGV0ZWQ6IGxlZGdlckRlbC5kZWxldGVkQ291bnQgPz8gMCxcclxuICAgICAgICByZW1vdmVkSm9icyxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQUNUSU9OOiBSZXRyeSBhbGwgZmFpbGVkIGNvbnRhY3RzIHRoYXQgYXJlIGJlbG93IE1BWF9BVFRFTVBUU1xyXG4gICAgaWYgKGFjdGlvbiA9PT0gJ3JldHJ5RmFpbGVkJykge1xyXG4gICAgICAvLyBEaXNhbGxvdyByZXRyeWluZyBpZiBjYW1wYWlnbiBpcyBjYW5jZWxsZWQvZGVsZXRlZC9wYXVzZWRcclxuICAgICAgaWYgKGNhbXBhaWduLnN0YXR1cyA9PT0gJ2NhbmNlbGxlZCcgfHwgY2FtcGFpZ24uc3RhdHVzID09PSAnZGVsZXRlZCcgfHwgY2FtcGFpZ24uc3RhdHVzID09PSAncGF1c2VkJykge1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IGVycm9yOiAnQ2Fubm90IHJldHJ5IGNvbnRhY3RzIGZvciBjYW5jZWxsZWQvZGVsZXRlZC9wYXVzZWQgY2FtcGFpZ24nIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBFbnN1cmUgYSBSZWRpcyBjYW1wYWlnbiBkZWZpbml0aW9uIGV4aXN0cyAod29ya2VyIHJlcXVpcmVzIGl0KVxyXG4gICAgICBjb25zdCBoYXNEZWYgPSBhd2FpdCBlbnN1cmVDYW1wYWlnbkRlZmluaXRpb24oaWQsIGNhbXBhaWduKTtcclxuICAgICAgaWYgKCFoYXNEZWYpIHtcclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg1MDApLmpzb24oeyBlcnJvcjogJ01pc3NpbmcgY2FtcGFpZ24gZGVmaW5pdGlvbiBpbiBSZWRpcyBhbmQgdW5hYmxlIHRvIGNvbnN0cnVjdCBvbmUgZnJvbSBjYW1wYWlnbiBkb2N1bWVudC4gUmV0cnkgY2Fubm90IHByb2NlZWQuJyB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZmluZCBmYWlsZWQgY29udGFjdHMgd2l0aCBhdHRlbXB0cyA8IE1BWF9BVFRFTVBUUyBBTkQgd2hlcmUgYmdBdHRlbXB0cyA+PSBNQVhfQVRURU1QVFMgKG1lYW5pbmcgYmFja2dyb3VuZCBjeWNsZSBmaW5pc2hlZClcclxuICAgICAgLy8gSWYgYmdBdHRlbXB0cyBpcyBtaXNzaW5nICh1bmRlZmluZWQvbnVsbCksIHRyZWF0IGl0IGFzIGZpbmlzaGVkIChjb25zZXJ2YXRpdmUpLiBCdXQgcHJlZmVyIGV4cGxpY2l0ID49LlxyXG4gICAgICBjb25zdCBmaWx0ZXI6IGFueSA9IHtcclxuICAgICAgICBjYW1wYWlnbklkOiBjYW1wYWlnbk9iamVjdElkLFxyXG4gICAgICAgIHN0YXR1czogJ2ZhaWxlZCcsXHJcbiAgICAgICAgYXR0ZW1wdHM6IHsgJGx0OiBNQVhfQVRURU1QVFMgfSxcclxuICAgICAgICAkb3I6IFtcclxuICAgICAgICAgIHsgYmdBdHRlbXB0czogeyAkZXhpc3RzOiBmYWxzZSB9IH0sXHJcbiAgICAgICAgICB7IGJnQXR0ZW1wdHM6IHsgJGd0ZTogTUFYX0FUVEVNUFRTIH0gfSxcclxuICAgICAgICBdLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgY29uc3QgZmFpbGVkRG9jcyA9IGF3YWl0IGRiXHJcbiAgICAgICAgLmNvbGxlY3Rpb24oJ2NhbXBhaWduX2NvbnRhY3RzJylcclxuICAgICAgICAuZmluZChmaWx0ZXIsIHsgcHJvamVjdGlvbjogeyBfaWQ6IDEsIGNvbnRhY3RJZDogMSwgc3RlcDogMSB9IH0pXHJcbiAgICAgICAgLnRvQXJyYXkoKTtcclxuXHJcbiAgICAgIGNvbnN0IHRvUmV0cnlDb3VudCA9IGZhaWxlZERvY3MubGVuZ3RoO1xyXG4gICAgICBpZiAodG9SZXRyeUNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHsgb2s6IHRydWUsIHJldHJpZWQ6IDAsIG1lc3NhZ2U6ICdObyBlbGlnaWJsZSBmYWlsZWQgY29udGFjdHMgdG8gcmV0cnkgKGVpdGhlciBub25lIGZhaWxlZCwgcmVhY2hlZCBtYXggYXR0ZW1wdHMsIG9yIGJhY2tncm91bmQgcmV0cmllcyBzdGlsbCBpbiBwcm9ncmVzcykuJyB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gc2VydmVyLXNpZGUgY2FwIGVuZm9yY2VtZW50XHJcbiAgICAgIGlmICh0b1JldHJ5Q291bnQgPiBCQVRDSF9SRVRSWV9MSU1JVCkge1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7XHJcbiAgICAgICAgICBlcnJvcjogJ0JhdGNoIHJldHJ5IGV4Y2VlZHMgc2VydmVyIGxpbWl0JyxcclxuICAgICAgICAgIG1lc3NhZ2U6IGBUcnlpbmcgdG8gcmV0cnkgJHt0b1JldHJ5Q291bnR9IGNvbnRhY3RzIGV4Y2VlZHMgc2VydmVyIGNhcCBvZiAke0JBVENIX1JFVFJZX0xJTUlUfS4gVXNlIHBhZ2luYXRpb24gdG8gcmV0cnkgaW4gc21hbGxlciBiYXRjaGVzLmAsXHJcbiAgICAgICAgICB0b1JldHJ5Q291bnQsXHJcbiAgICAgICAgICBsaW1pdDogQkFUQ0hfUkVUUllfTElNSVQsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEF0b21pY2FsbHkgbWFyayB0aGVtIHBlbmRpbmcgYW5kIGluY3JlbWVudCBjb3JlIGBhdHRlbXB0c2AgYW5kIHJlc2V0IGJnQXR0ZW1wdHNcclxuICAgICAgY29uc3QgaWRzID0gZmFpbGVkRG9jcy5tYXAoZCA9PiBkLl9pZCk7XHJcbiAgICAgIGNvbnN0IHVwZGF0ZVJlc3VsdCA9IGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWduX2NvbnRhY3RzJykudXBkYXRlTWFueShcclxuICAgICAgICB7IF9pZDogeyAkaW46IGlkcyB9IH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgJHNldDogeyBzdGF0dXM6ICdwZW5kaW5nJywgbGFzdEVycm9yOiBudWxsLCBiZ0F0dGVtcHRzOiAwIH0sXHJcbiAgICAgICAgICAkaW5jOiB7IGF0dGVtcHRzOiAxIH0sXHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc3QgdXBkYXRlZCA9IHVwZGF0ZVJlc3VsdC5tb2RpZmllZENvdW50ID8/IDA7XHJcblxyXG4gICAgICAvLyBFbnF1ZXVlIGpvYnMgKGJhdGNoKSwgZW5zdXJlIGVhY2ggam9iIGhhcyBNUSBhdHRlbXB0cy9iYWNrb2ZmIHNldFxyXG4gICAgICBjb25zdCBqb2JzOiBQcm9taXNlPGFueT5bXSA9IFtdO1xyXG4gICAgICBjb25zdCBDSFVOSyA9IDIwMDsgLy8gcmVhc29uYWJsZSBjaHVua2luZ1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZhaWxlZERvY3MubGVuZ3RoOyBpICs9IENIVU5LKSB7XHJcbiAgICAgICAgY29uc3QgY2h1bmsgPSBmYWlsZWREb2NzLnNsaWNlKGksIGkgKyBDSFVOSyk7XHJcbiAgICAgICAgZm9yIChjb25zdCBkb2Mgb2YgY2h1bmspIHtcclxuICAgICAgICAgIGNvbnN0IGNvbnRhY3RPYmpJZCA9IGRvYy5jb250YWN0SWQgPyBkb2MuY29udGFjdElkIDogZG9jLl9pZDtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChkb2Muc3RlcCkge1xyXG4gICAgICAgICAgICAgIGpvYnMucHVzaChcclxuICAgICAgICAgICAgICAgIHF1ZXVlLmFkZChcclxuICAgICAgICAgICAgICAgICAgJ2ZvbGxvd3VwJyxcclxuICAgICAgICAgICAgICAgICAgeyBjYW1wYWlnbklkOiBpZCwgY29udGFjdElkOiBjb250YWN0T2JqSWQudG9TdHJpbmcgPyBjb250YWN0T2JqSWQudG9TdHJpbmcoKSA6IFN0cmluZyhjb250YWN0T2JqSWQpLCBzdGVwOiBkb2Muc3RlcCB9LFxyXG4gICAgICAgICAgICAgICAgICB7IHJlbW92ZU9uQ29tcGxldGU6IHRydWUsIHJlbW92ZU9uRmFpbDogdHJ1ZSwgYXR0ZW1wdHM6IE1BWF9BVFRFTVBUUywgYmFja29mZjogeyB0eXBlOiAnZXhwb25lbnRpYWwnLCBkZWxheTogNjBfMDAwIH0gfVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgam9icy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgcXVldWUuYWRkKFxyXG4gICAgICAgICAgICAgICAgICAnaW5pdGlhbCcsXHJcbiAgICAgICAgICAgICAgICAgIHsgY2FtcGFpZ25JZDogaWQsIGNvbnRhY3RJZDogY29udGFjdE9iaklkLnRvU3RyaW5nID8gY29udGFjdE9iaklkLnRvU3RyaW5nKCkgOiBTdHJpbmcoY29udGFjdE9iaklkKSB9LFxyXG4gICAgICAgICAgICAgICAgICB7IHJlbW92ZU9uQ29tcGxldGU6IHRydWUsIHJlbW92ZU9uRmFpbDogdHJ1ZSwgYXR0ZW1wdHM6IE1BWF9BVFRFTVBUUywgYmFja29mZjogeyB0eXBlOiAnZXhwb25lbnRpYWwnLCBkZWxheTogNjBfMDAwIH0gfVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcXVldWUgam9iIGZvciByZXRyeUZhaWxlZCBjaHVuayBpdGVtJywgZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBXYWl0IGZvciBlbnF1ZXVlcyAoYmVzdC1lZmZvcnQpXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoam9icyk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ1NvbWUgcXVldWUuYWRkIGNhbGxzIGZhaWxlZCBkdXJpbmcgcmV0cnlGYWlsZWQnLCBlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVXBkYXRlIHJlZGlzIGNvdW50ZXJzOiBkZWNyZWFzZSBmYWlsZWQgYnkgdXBkYXRlZCAoYmVzdC1lZmZvcnQsIGJ1dCBhdm9pZCBuZWdhdGl2ZSlcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBjdXJyZW50RmFpbGVkID0gYXdhaXQgc2FmZUdldE1ldGFJbnQocmVkaXNLZXksICdmYWlsZWQnKTtcclxuICAgICAgICBjb25zdCBkZWMgPSBNYXRoLm1pbih1cGRhdGVkLCBjdXJyZW50RmFpbGVkKTtcclxuICAgICAgICBpZiAoZGVjID4gMCkge1xyXG4gICAgICAgICAgYXdhaXQgcmVkaXMuaGluY3JieShyZWRpc0tleSwgJ2ZhaWxlZCcsIC1kZWMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHVwZGF0ZSByZWRpcyBjb3VudGVycyBkdXJpbmcgcmV0cnlGYWlsZWQnLCBlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUHVibGlzaCBjb250YWN0LWxldmVsIHVwZGF0ZXMgZm9yIGVhY2ggcmV0cmllZCBjb250YWN0IChiZXN0LWVmZm9ydClcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBmb3IgKGNvbnN0IGRvYyBvZiBmYWlsZWREb2NzKSB7XHJcbiAgICAgICAgICBjb25zdCBjaWQgPSBkb2MuY29udGFjdElkID8gKGRvYy5jb250YWN0SWQudG9TdHJpbmcgPyBkb2MuY29udGFjdElkLnRvU3RyaW5nKCkgOiBTdHJpbmcoZG9jLmNvbnRhY3RJZCkpIDogKGRvYy5faWQudG9TdHJpbmcgPyBkb2MuX2lkLnRvU3RyaW5nKCkgOiBTdHJpbmcoZG9jLl9pZCkpO1xyXG4gICAgICAgICAgYXdhaXQgc2FmZVB1Ymxpc2goYGNhbXBhaWduOiR7aWR9OmNvbnRhY3RfdXBkYXRlYCwgeyBjb250YWN0SWQ6IGNpZCwgc3RhdHVzOiAncGVuZGluZycsIGJnQXR0ZW1wdHM6IDAsIGF0dGVtcHRzOiAxIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoXykge1xyXG4gICAgICAgIC8vIGlnbm9yZSBwdWJsaXNoIGVycm9yc1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhd2FpdCBzYWZlUHVibGlzaCgnY2FtcGFpZ246bmV3JywgeyBpZCwgYWN0aW9uOiAncmV0cnlGYWlsZWQnLCByZXRyaWVkOiB1cGRhdGVkIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHsgb2s6IHRydWUsIHJldHJpZWQ6IHVwZGF0ZWQsIGF0dGVtcHRlZEVucXVldWU6IHRvUmV0cnlDb3VudCB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBQ1RJT046IFJldHJ5IGEgc2luZ2xlIGZhaWxlZCBjb250YWN0IGJ5IGNvbnRhY3RJZFxyXG4gICAgaWYgKGFjdGlvbiA9PT0gJ3JldHJ5Q29udGFjdCcpIHtcclxuICAgICAgaWYgKCFjb250YWN0SWQgfHwgdHlwZW9mIGNvbnRhY3RJZCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBlcnJvcjogJ01pc3NpbmcgY29udGFjdElkIGZvciByZXRyeUNvbnRhY3QnIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEaXNhbGxvdyByZXRyeWluZyBpZiBjYW1wYWlnbiBpcyBjYW5jZWxsZWQvZGVsZXRlZC9wYXVzZWRcclxuICAgICAgaWYgKGNhbXBhaWduLnN0YXR1cyA9PT0gJ2NhbmNlbGxlZCcgfHwgY2FtcGFpZ24uc3RhdHVzID09PSAnZGVsZXRlZCcgfHwgY2FtcGFpZ24uc3RhdHVzID09PSAncGF1c2VkJykge1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IGVycm9yOiAnQ2Fubm90IHJldHJ5IGNvbnRhY3RzIGZvciBjYW5jZWxsZWQvZGVsZXRlZC9wYXVzZWQgY2FtcGFpZ24nIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBFbnN1cmUgYSBSZWRpcyBjYW1wYWlnbiBkZWZpbml0aW9uIGV4aXN0cyAod29ya2VyIHJlcXVpcmVzIGl0KVxyXG4gICAgICBjb25zdCBoYXNEZWYgPSBhd2FpdCBlbnN1cmVDYW1wYWlnbkRlZmluaXRpb24oaWQsIGNhbXBhaWduKTtcclxuICAgICAgaWYgKCFoYXNEZWYpIHtcclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg1MDApLmpzb24oeyBlcnJvcjogJ01pc3NpbmcgY2FtcGFpZ24gZGVmaW5pdGlvbiBpbiBSZWRpcyBhbmQgdW5hYmxlIHRvIGNvbnN0cnVjdCBvbmUgZnJvbSBjYW1wYWlnbiBkb2N1bWVudC4gUmV0cnkgY2Fubm90IHByb2NlZWQuJyB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRmluZCB0aGUgbGVkZ2VyIHJvd1xyXG4gICAgICBsZXQgY29udGFjdE9iaklkO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIHRyeSBwYXJzZSBhcyBPYmplY3RJZCBmaXJzdFxyXG4gICAgICAgIGNvbnRhY3RPYmpJZCA9IG5ldyBPYmplY3RJZChjb250YWN0SWQpO1xyXG4gICAgICB9IGNhdGNoIHtcclxuICAgICAgICAvLyBmYWxsYmFjazogdXNlIHJhdyBzdHJpbmdcclxuICAgICAgICBjb250YWN0T2JqSWQgPSBjb250YWN0SWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGRvYyA9IGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWduX2NvbnRhY3RzJykuZmluZE9uZSh7XHJcbiAgICAgICAgY2FtcGFpZ25JZDogY2FtcGFpZ25PYmplY3RJZCxcclxuICAgICAgICBjb250YWN0SWQ6IGNvbnRhY3RPYmpJZCxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoIWRvYykge1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwNCkuanNvbih7IGVycm9yOiAnQ29udGFjdCBsZWRnZXIgcm93IG5vdCBmb3VuZCBmb3IgY2FtcGFpZ24nIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZG9jLnN0YXR1cyAhPT0gJ2ZhaWxlZCcpIHtcclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBlcnJvcjogJ0NvbnRhY3QgaXMgbm90IGluIGZhaWxlZCBzdGF0ZScgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICgoZG9jLmF0dGVtcHRzIHx8IDApID49IE1BWF9BVFRFTVBUUykge1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IGVycm9yOiAnQ29udGFjdCBoYXMgcmVhY2hlZCBtYXggbWFudWFsIGF0dGVtcHRzIGFuZCBjYW5ub3QgYmUgcmV0cmllZCcgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFByZXZlbnQgbWFudWFsIHJldHJ5IHdoaWxlIEJ1bGxNUSBiYWNrZ3JvdW5kIHJldHJpZXMgYXJlIHN0aWxsIHJ1bm5pbmcgZm9yIHRoaXMgY29udGFjdFxyXG4gICAgICAvLyBSZXF1aXJlIGJnQXR0ZW1wdHMgPj0gTUFYX0FUVEVNUFRTIChvciBtaXNzaW5nKSBiZWZvcmUgYWxsb3dpbmcgbWFudWFsIHJldHJ5XHJcbiAgICAgIGNvbnN0IGJnRG9uZSA9ICh0eXBlb2YgZG9jLmJnQXR0ZW1wdHMgPT09ICdudW1iZXInID8gZG9jLmJnQXR0ZW1wdHMgPj0gTUFYX0FUVEVNUFRTIDogdHJ1ZSk7XHJcbiAgICAgIGlmICghYmdEb25lKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgZXJyb3I6ICdCYWNrZ3JvdW5kIHJldHJpZXMgYXJlIHN0aWxsIGluIHByb2dyZXNzIGZvciB0aGlzIGNvbnRhY3QuIFBsZWFzZSB3YWl0IHVudGlsIHRoZSBiYWNrZ3JvdW5kIHJldHJ5IGN5Y2xlIGNvbXBsZXRlcy4nIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBVcGRhdGUgc2luZ2xlIGRvYyB0byBwZW5kaW5nLCBpbmNyZW1lbnQgY29yZSBhdHRlbXB0cywgcmVzZXQgYmdBdHRlbXB0c1xyXG4gICAgICBhd2FpdCBkYi5jb2xsZWN0aW9uKCdjYW1wYWlnbl9jb250YWN0cycpLnVwZGF0ZU9uZShcclxuICAgICAgICB7IF9pZDogZG9jLl9pZCB9LFxyXG4gICAgICAgIHsgJHNldDogeyBzdGF0dXM6ICdwZW5kaW5nJywgbGFzdEVycm9yOiBudWxsLCBiZ0F0dGVtcHRzOiAwIH0sICRpbmM6IHsgYXR0ZW1wdHM6IDEgfSB9XHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBFbnF1ZXVlIGFwcHJvcHJpYXRlIGpvYiAodXNlIGRvYy5zdGVwIGlmIHByZXNlbnQpIGFuZCBlbnN1cmUgTVEgYXR0ZW1wdHMvYmFja29mZiBhcmUgc2V0XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKGRvYy5zdGVwKSB7XHJcbiAgICAgICAgICBhd2FpdCBxdWV1ZS5hZGQoXHJcbiAgICAgICAgICAgICdmb2xsb3d1cCcsXHJcbiAgICAgICAgICAgIHsgY2FtcGFpZ25JZDogaWQsIGNvbnRhY3RJZDogY29udGFjdE9iaklkLnRvU3RyaW5nID8gY29udGFjdE9iaklkLnRvU3RyaW5nKCkgOiBTdHJpbmcoY29udGFjdE9iaklkKSwgc3RlcDogZG9jLnN0ZXAgfSxcclxuICAgICAgICAgICAgeyByZW1vdmVPbkNvbXBsZXRlOiB0cnVlLCByZW1vdmVPbkZhaWw6IHRydWUsIGF0dGVtcHRzOiBNQVhfQVRURU1QVFMsIGJhY2tvZmY6IHsgdHlwZTogJ2V4cG9uZW50aWFsJywgZGVsYXk6IDYwXzAwMCB9IH1cclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGF3YWl0IHF1ZXVlLmFkZChcclxuICAgICAgICAgICAgJ2luaXRpYWwnLFxyXG4gICAgICAgICAgICB7IGNhbXBhaWduSWQ6IGlkLCBjb250YWN0SWQ6IGNvbnRhY3RPYmpJZC50b1N0cmluZyA/IGNvbnRhY3RPYmpJZC50b1N0cmluZygpIDogU3RyaW5nKGNvbnRhY3RPYmpJZCkgfSxcclxuICAgICAgICAgICAgeyByZW1vdmVPbkNvbXBsZXRlOiB0cnVlLCByZW1vdmVPbkZhaWw6IHRydWUsIGF0dGVtcHRzOiBNQVhfQVRURU1QVFMsIGJhY2tvZmY6IHsgdHlwZTogJ2V4cG9uZW50aWFsJywgZGVsYXk6IDYwXzAwMCB9IH1cclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gZW5xdWV1ZSByZXRyeSBqb2IgZm9yIGNvbnRhY3QnLCBlKTtcclxuICAgICAgICAvLyBSb2xsYmFjazogdHJ5IHRvIHJldmVydCB0aGUgbGVkZ2VyIHJvdyBjaGFuZ2VzIChiZXN0LWVmZm9ydClcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25fY29udGFjdHMnKS51cGRhdGVPbmUoXHJcbiAgICAgICAgICAgIHsgX2lkOiBkb2MuX2lkIH0sXHJcbiAgICAgICAgICAgIHsgJHNldDogeyBzdGF0dXM6ICdmYWlsZWQnLCBsYXN0RXJyb3I6ICdlbnF1ZXVlLWZhaWxlZCcgfSwgJGluYzogeyBhdHRlbXB0czogLTEgfSwgJHNldDogeyBiZ0F0dGVtcHRzOiBkb2MuYmdBdHRlbXB0cyA/PyAwIH0gfSBhcyBhbnlcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSBjYXRjaCAoXykge31cclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg1MDApLmpzb24oeyBlcnJvcjogJ0ZhaWxlZCB0byBlbnF1ZXVlIHJldHJ5IGpvYicgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFVwZGF0ZSByZWRpcyBjb3VudGVyczogZGVjcmVhc2UgZmFpbGVkIGJ5IDEgaWYgcG9zc2libGUgKHdlIG1vdmVkIGl0IGZyb20gZmFpbGVkIC0+IHBlbmRpbmcpXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudEZhaWxlZCA9IGF3YWl0IHNhZmVHZXRNZXRhSW50KHJlZGlzS2V5LCAnZmFpbGVkJyk7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRGYWlsZWQgPiAwKSB7XHJcbiAgICAgICAgICBhd2FpdCByZWRpcy5oaW5jcmJ5KHJlZGlzS2V5LCAnZmFpbGVkJywgLTEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHVwZGF0ZSByZWRpcyBjb3VudGVycyBkdXJpbmcgcmV0cnlDb250YWN0JywgZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFB1Ymxpc2ggY29udGFjdCB1cGRhdGVcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBjaWRTdHIgPSBjb250YWN0T2JqSWQudG9TdHJpbmcgPyBjb250YWN0T2JqSWQudG9TdHJpbmcoKSA6IFN0cmluZyhjb250YWN0T2JqSWQpO1xyXG4gICAgICAgIGF3YWl0IHNhZmVQdWJsaXNoKGBjYW1wYWlnbjoke2lkfTpjb250YWN0X3VwZGF0ZWAsIHsgY29udGFjdElkOiBjaWRTdHIsIHN0YXR1czogJ3BlbmRpbmcnLCBhdHRlbXB0czogKGRvYy5hdHRlbXB0cyB8fCAwKSArIDEsIGJnQXR0ZW1wdHM6IDAgfSk7XHJcbiAgICAgIH0gY2F0Y2ggKF8pIHt9XHJcblxyXG4gICAgICBhd2FpdCBzYWZlUHVibGlzaCgnY2FtcGFpZ246bmV3JywgeyBpZCwgYWN0aW9uOiAncmV0cnlDb250YWN0JywgY29udGFjdElkIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHsgb2s6IHRydWUsIHJldHJpZWQ6IDEsIGNvbnRhY3RJZCB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTaG91bGQgbm90IHJlYWNoIGhlcmVcclxuICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IGVycm9yOiAnVW5zdXBwb3J0ZWQgYWN0aW9uJyB9KTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0NhbXBhaWduIGNvbnRyb2wgZXJyb3InLCBlcnIpO1xyXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgZXJyb3I6ICdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3InIH0pO1xyXG4gIH1cclxufSJdLCJuYW1lcyI6WyJjbGllbnRQcm9taXNlIiwicmVkaXMiLCJRdWV1ZSIsIk9iamVjdElkIiwicXVldWUiLCJjb25uZWN0aW9uIiwiTUFYX0FUVEVNUFRTIiwiTnVtYmVyIiwicHJvY2VzcyIsImVudiIsIkJBVENIX1JFVFJZX0xJTUlUIiwiUkVTVU1FX0VOUVVFVUVfTElNSVQiLCJTVEFMRV9TRU5ESU5HX01TIiwic2FmZUhTZXQiLCJrZXkiLCJvYmoiLCJoc2V0IiwiZXJyIiwiY29uc29sZSIsIndhcm4iLCJzYWZlUHVibGlzaCIsImNoYW5uZWwiLCJwYXlsb2FkIiwicHVibGlzaCIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZW1vdmVRdWV1ZWRKb2JzRm9yQ2FtcGFpZ24iLCJjYW1wYWlnbklkIiwiam9icyIsImdldEpvYnMiLCJtYXRjaGVkIiwiZmlsdGVyIiwiaiIsImRhdGEiLCJyZW1vdmUiLCJlIiwiaWQiLCJsZW5ndGgiLCJzYWZlR2V0TWV0YUludCIsInJlZGlzS2V5IiwiZmllbGQiLCJ2IiwiaGdldCIsImVuc3VyZUNhbXBhaWduRGVmaW5pdGlvbiIsImNhbXBhaWduRG9jIiwiZXhpc3RpbmciLCJnZXQiLCJidWlsdCIsImRlZmluaXRpb24iLCJpbml0aWFsIiwiZm9sbG93VXBzIiwidGVtcGxhdGUiLCJzdWJqZWN0IiwibmFtZSIsImJvZHkiLCJjb250ZW50IiwidGl0bGUiLCJodG1sIiwic3RlcHMiLCJzYW1wbGUiLCJPYmplY3QiLCJrZXlzIiwic2xpY2UiLCJzZXQiLCJsb2ciLCJnZXRRdWV1ZWRDb250YWN0SWRzRm9yQ2FtcGFpZ24iLCJTZXQiLCJjb250YWN0SWQiLCJhZGQiLCJTdHJpbmciLCJoYW5kbGVyIiwicmVxIiwicmVzIiwibWV0aG9kIiwic3RhdHVzIiwianNvbiIsImVycm9yIiwicXVlcnkiLCJhY3Rpb24iLCJjb25maXJtIiwiaW5jbHVkZXMiLCJjbGllbnQiLCJkYiIsImNhbXBhaWduT2JqZWN0SWQiLCJjYW1wYWlnbiIsImNvbGxlY3Rpb24iLCJmaW5kT25lIiwiX2lkIiwib2siLCJtZXNzYWdlIiwidXBkYXRlT25lIiwiJHNldCIsInF1ZXVlZFNldCIsInBlbmRpbmdDdXJzb3IiLCJmaW5kIiwicHJvamVjdGlvbiIsInN0ZXAiLCJsaW1pdCIsInBlbmRpbmciLCJ0b0FycmF5IiwiZW5xdWV1ZVByb21pc2VzIiwiZCIsImNpZCIsInRvU3RyaW5nIiwiaGFzIiwicHVzaCIsInJlbW92ZU9uQ29tcGxldGUiLCJyZW1vdmVPbkZhaWwiLCJhdHRlbXB0cyIsImJhY2tvZmYiLCJ0eXBlIiwiZGVsYXkiLCJQcm9taXNlIiwiYWxsU2V0dGxlZCIsInJlcXVldWVkIiwiY3V0b2ZmIiwiRGF0ZSIsIm5vdyIsInN0YWxlQ3Vyc29yIiwibGFzdEF0dGVtcHRBdCIsIiRsdCIsImJnQXR0ZW1wdHMiLCJzdGFsZURvY3MiLCJpZHMiLCJtYXAiLCJ1cGRhdGVNYW55IiwiJGluIiwibGFzdEVycm9yIiwicXVldWVkU2V0MiIsInJlcXVldWVQcm9taXNlcyIsInVuZGVmaW5lZCIsIl8iLCJyZWNvdmVyZWQiLCJjb21wbGV0ZWRBdCIsInVwZGF0ZSIsIiRpbmMiLCJ1cGRhdGVSZXN1bHQiLCJjYW5jZWxsZWRDb3VudCIsIm1vZGlmaWVkQ291bnQiLCJoaW5jcmJ5IiwibWV0YSIsImhnZXRhbGwiLCJwcm9jZXNzZWROb3ciLCJ0b3RhbHMiLCJwcm9jZXNzZWQiLCJzZW50Tm93Iiwic2VudCIsImZhaWxlZE5vdyIsImZhaWxlZCIsInJlbW92ZWRKb2JzIiwiZGVsIiwic3JlbSIsImNhbXBhaWduRGVsIiwibGVkZ2VyRGVsIiwiYWxsIiwiZGVsZXRlT25lIiwiZGVsZXRlTWFueSIsImNhbXBhaWduRGVsZXRlZCIsImRlbGV0ZWRDb3VudCIsImxlZGdlckRlbGV0ZWQiLCJoYXNEZWYiLCIkb3IiLCIkZXhpc3RzIiwiJGd0ZSIsImZhaWxlZERvY3MiLCJ0b1JldHJ5Q291bnQiLCJyZXRyaWVkIiwidXBkYXRlZCIsIkNIVU5LIiwiaSIsImNodW5rIiwiZG9jIiwiY29udGFjdE9iaklkIiwiY3VycmVudEZhaWxlZCIsImRlYyIsIk1hdGgiLCJtaW4iLCJhdHRlbXB0ZWRFbnF1ZXVlIiwiYmdEb25lIiwiY2lkU3RyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./pages/api/campaign/[id]/control.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fcampaign%2F%5Bid%5D%2Fcontrol&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Ccampaign%5C%5Bid%5D%5Ccontrol.ts&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();