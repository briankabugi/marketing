"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/campaign/[id]/control";
exports.ids = ["pages/api/campaign/[id]/control"];
exports.modules = {

/***/ "bullmq":
/*!*************************!*\
  !*** external "bullmq" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("bullmq");

/***/ }),

/***/ "ioredis":
/*!**************************!*\
  !*** external "ioredis" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("ioredis");

/***/ }),

/***/ "mongodb":
/*!**************************!*\
  !*** external "mongodb" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("mongodb");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fcampaign%2F%5Bid%5D%2Fcontrol&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Ccampaign%5C%5Bid%5D%5Ccontrol.ts&middlewareConfigBase64=e30%3D!":
/*!****************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fcampaign%2F%5Bid%5D%2Fcontrol&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Ccampaign%5C%5Bid%5D%5Ccontrol.ts&middlewareConfigBase64=e30%3D! ***!
  \****************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_campaign_id_control_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages\\api\\campaign\\[id]\\control.ts */ \"(api)/./pages/api/campaign/[id]/control.ts\");\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_campaign_id_control_ts__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_campaign_id_control_ts__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/campaign/[id]/control\",\n        pathname: \"/api/campaign/[id]/control\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _pages_api_campaign_id_control_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRmNhbXBhaWduJTJGJTVCaWQlNUQlMkZjb250cm9sJnByZWZlcnJlZFJlZ2lvbj0mYWJzb2x1dGVQYWdlUGF0aD0uJTJGcGFnZXMlNUNhcGklNUNjYW1wYWlnbiU1QyU1QmlkJTVEJTVDY29udHJvbC50cyZtaWRkbGV3YXJlQ29uZmlnQmFzZTY0PWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdkM7QUFDTDtBQUMxRDtBQUNxRTtBQUNyRTtBQUNBLGlFQUFlLHdFQUFLLENBQUMsOERBQVEsWUFBWSxFQUFDO0FBQzFDO0FBQ08sZUFBZSx3RUFBSyxDQUFDLDhEQUFRO0FBQ3BDO0FBQ08sd0JBQXdCLGdIQUFtQjtBQUNsRDtBQUNBLGNBQWMseUVBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZO0FBQ1osQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldGluZy1tdnAvPzhjNzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFnZXNBUElSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL3BhZ2VzLWFwaS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBob2lzdCB9IGZyb20gXCJuZXh0L2Rpc3QvYnVpbGQvdGVtcGxhdGVzL2hlbHBlcnNcIjtcbi8vIEltcG9ydCB0aGUgdXNlcmxhbmQgY29kZS5cbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIuL3BhZ2VzXFxcXGFwaVxcXFxjYW1wYWlnblxcXFxbaWRdXFxcXGNvbnRyb2wudHNcIjtcbi8vIFJlLWV4cG9ydCB0aGUgaGFuZGxlciAoc2hvdWxkIGJlIHRoZSBkZWZhdWx0IGV4cG9ydCkuXG5leHBvcnQgZGVmYXVsdCBob2lzdCh1c2VybGFuZCwgXCJkZWZhdWx0XCIpO1xuLy8gUmUtZXhwb3J0IGNvbmZpZy5cbmV4cG9ydCBjb25zdCBjb25maWcgPSBob2lzdCh1c2VybGFuZCwgXCJjb25maWdcIik7XG4vLyBDcmVhdGUgYW5kIGV4cG9ydCB0aGUgcm91dGUgbW9kdWxlIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbmV4cG9ydCBjb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBQYWdlc0FQSVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5QQUdFU19BUEksXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9jYW1wYWlnbi9baWRdL2NvbnRyb2xcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9jYW1wYWlnbi9baWRdL2NvbnRyb2xcIixcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBhcmVuJ3QgdXNlZCBpbiBwcm9kdWN0aW9uLlxuICAgICAgICBidW5kbGVQYXRoOiBcIlwiLFxuICAgICAgICBmaWxlbmFtZTogXCJcIlxuICAgIH0sXG4gICAgdXNlcmxhbmRcbn0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdlcy1hcGkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fcampaign%2F%5Bid%5D%2Fcontrol&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Ccampaign%5C%5Bid%5D%5Ccontrol.ts&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./lib/mongo.ts":
/*!**********************!*\
  !*** ./lib/mongo.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mongodb */ \"mongodb\");\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mongodb__WEBPACK_IMPORTED_MODULE_0__);\n// lib/mongo.ts\n\nconst uri = process.env.MONGODB_URI;\nif (!uri) throw new Error(\"MONGODB_URI not set\");\nlet client;\nlet clientPromise;\n// Retry logic in case MongoDB connection fails\nasync function connectWithRetry() {\n    const MAX_RETRIES = 5;\n    let attempts = 0;\n    let lastError = null;\n    while(attempts < MAX_RETRIES){\n        try {\n            const client = new mongodb__WEBPACK_IMPORTED_MODULE_0__.MongoClient(uri, {\n                maxPoolSize: 10,\n                serverSelectionTimeoutMS: 10000,\n                socketTimeoutMS: 45000\n            });\n            await client.connect();\n            return client;\n        } catch (err) {\n            lastError = err;\n            attempts++;\n            console.error(`MongoDB connection failed (attempt ${attempts}/${MAX_RETRIES}):`, err);\n            if (attempts < MAX_RETRIES) {\n                await new Promise((resolve)=>setTimeout(resolve, 5000)); // wait for 5 seconds before retrying\n            }\n        }\n    }\n    // After max retries, throw the last error encountered\n    throw lastError || new Error(\"MongoDB connection failed after maximum retry attempts\");\n}\nif (!global._mongoClientPromise) {\n    global._mongoClientPromise = connectWithRetry();\n    // Optional: log connection events\n    global._mongoClientPromise.then((client)=>{\n        client.on(\"serverOpening\", (event)=>console.log(\"MongoDB server opening\", event));\n        client.on(\"serverClosed\", (event)=>console.warn(\"MongoDB server closed\", event));\n        client.on(\"topologyClosed\", ()=>console.warn(\"MongoDB topology closed\"));\n        client.on(\"topologyOpening\", ()=>console.log(\"MongoDB topology opening\"));\n        client.on(\"error\", (err)=>console.error(\"MongoDB error\", err));\n    }).catch((err)=>{\n        console.error(\"MongoDB client failed to connect after retries\", err);\n    });\n}\nclientPromise = global._mongoClientPromise;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (clientPromise);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9saWIvbW9uZ28udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZUFBZTtBQUN1QjtBQUV0QyxNQUFNQyxNQUFNQyxRQUFRQyxHQUFHLENBQUNDLFdBQVc7QUFDbkMsSUFBSSxDQUFDSCxLQUFLLE1BQU0sSUFBSUksTUFBTTtBQUUxQixJQUFJQztBQUNKLElBQUlDO0FBT0osK0NBQStDO0FBQy9DLGVBQWVDO0lBQ2IsTUFBTUMsY0FBYztJQUNwQixJQUFJQyxXQUFXO0lBQ2YsSUFBSUMsWUFBMEI7SUFFOUIsTUFBT0QsV0FBV0QsWUFBYTtRQUM3QixJQUFJO1lBQ0YsTUFBTUgsU0FBUyxJQUFJTixnREFBV0EsQ0FBQ0MsS0FBSztnQkFDbENXLGFBQWE7Z0JBQ2JDLDBCQUEwQjtnQkFDMUJDLGlCQUFpQjtZQUNuQjtZQUNBLE1BQU1SLE9BQU9TLE9BQU87WUFDcEIsT0FBT1Q7UUFDVCxFQUFFLE9BQU9VLEtBQVU7WUFDakJMLFlBQVlLO1lBQ1pOO1lBQ0FPLFFBQVFDLEtBQUssQ0FBQyxDQUFDLG1DQUFtQyxFQUFFUixTQUFTLENBQUMsRUFBRUQsWUFBWSxFQUFFLENBQUMsRUFBRU87WUFDakYsSUFBSU4sV0FBV0QsYUFBYTtnQkFDMUIsTUFBTSxJQUFJVSxRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTLFFBQVEscUNBQXFDO1lBQ2hHO1FBQ0Y7SUFDRjtJQUVBLHNEQUFzRDtJQUN0RCxNQUFNVCxhQUFhLElBQUlOLE1BQU07QUFDL0I7QUFFQSxJQUFJLENBQUNpQixPQUFPQyxtQkFBbUIsRUFBRTtJQUMvQkQsT0FBT0MsbUJBQW1CLEdBQUdmO0lBRTdCLGtDQUFrQztJQUNsQ2MsT0FBT0MsbUJBQW1CLENBQ3ZCQyxJQUFJLENBQUNsQixDQUFBQTtRQUNKQSxPQUFPbUIsRUFBRSxDQUFDLGlCQUFpQixDQUFDQyxRQUFVVCxRQUFRVSxHQUFHLENBQUMsMEJBQTBCRDtRQUM1RXBCLE9BQU9tQixFQUFFLENBQUMsZ0JBQWdCLENBQUNDLFFBQVVULFFBQVFXLElBQUksQ0FBQyx5QkFBeUJGO1FBQzNFcEIsT0FBT21CLEVBQUUsQ0FBQyxrQkFBa0IsSUFBTVIsUUFBUVcsSUFBSSxDQUFDO1FBQy9DdEIsT0FBT21CLEVBQUUsQ0FBQyxtQkFBbUIsSUFBTVIsUUFBUVUsR0FBRyxDQUFDO1FBQy9DckIsT0FBT21CLEVBQUUsQ0FBQyxTQUFTLENBQUNULE1BQVFDLFFBQVFDLEtBQUssQ0FBQyxpQkFBaUJGO0lBQzdELEdBQ0NhLEtBQUssQ0FBQ2IsQ0FBQUE7UUFDTEMsUUFBUUMsS0FBSyxDQUFDLGtEQUFrREY7SUFDbEU7QUFDSjtBQUVBVCxnQkFBZ0JlLE9BQU9DLG1CQUFtQjtBQUUxQyxpRUFBZWhCLGFBQWFBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRpbmctbXZwLy4vbGliL21vbmdvLnRzPzU3ZmUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbGliL21vbmdvLnRzXHJcbmltcG9ydCB7IE1vbmdvQ2xpZW50IH0gZnJvbSAnbW9uZ29kYic7XHJcblxyXG5jb25zdCB1cmkgPSBwcm9jZXNzLmVudi5NT05HT0RCX1VSSTtcclxuaWYgKCF1cmkpIHRocm93IG5ldyBFcnJvcignTU9OR09EQl9VUkkgbm90IHNldCcpO1xyXG5cclxubGV0IGNsaWVudDogTW9uZ29DbGllbnQ7XHJcbmxldCBjbGllbnRQcm9taXNlOiBQcm9taXNlPE1vbmdvQ2xpZW50PjtcclxuXHJcbmRlY2xhcmUgZ2xvYmFsIHtcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdmFyXHJcbiAgdmFyIF9tb25nb0NsaWVudFByb21pc2U6IFByb21pc2U8TW9uZ29DbGllbnQ+IHwgdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vLyBSZXRyeSBsb2dpYyBpbiBjYXNlIE1vbmdvREIgY29ubmVjdGlvbiBmYWlsc1xyXG5hc3luYyBmdW5jdGlvbiBjb25uZWN0V2l0aFJldHJ5KCk6IFByb21pc2U8TW9uZ29DbGllbnQ+IHtcclxuICBjb25zdCBNQVhfUkVUUklFUyA9IDU7XHJcbiAgbGV0IGF0dGVtcHRzID0gMDtcclxuICBsZXQgbGFzdEVycm9yOiBFcnJvciB8IG51bGwgPSBudWxsO1xyXG5cclxuICB3aGlsZSAoYXR0ZW1wdHMgPCBNQVhfUkVUUklFUykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgY2xpZW50ID0gbmV3IE1vbmdvQ2xpZW50KHVyaSwge1xyXG4gICAgICAgIG1heFBvb2xTaXplOiAxMCxcclxuICAgICAgICBzZXJ2ZXJTZWxlY3Rpb25UaW1lb3V0TVM6IDEwMDAwLFxyXG4gICAgICAgIHNvY2tldFRpbWVvdXRNUzogNDUwMDAsXHJcbiAgICAgIH0pO1xyXG4gICAgICBhd2FpdCBjbGllbnQuY29ubmVjdCgpO1xyXG4gICAgICByZXR1cm4gY2xpZW50O1xyXG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcclxuICAgICAgbGFzdEVycm9yID0gZXJyO1xyXG4gICAgICBhdHRlbXB0cysrO1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBNb25nb0RCIGNvbm5lY3Rpb24gZmFpbGVkIChhdHRlbXB0ICR7YXR0ZW1wdHN9LyR7TUFYX1JFVFJJRVN9KTpgLCBlcnIpO1xyXG4gICAgICBpZiAoYXR0ZW1wdHMgPCBNQVhfUkVUUklFUykge1xyXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDAwKSk7IC8vIHdhaXQgZm9yIDUgc2Vjb25kcyBiZWZvcmUgcmV0cnlpbmdcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQWZ0ZXIgbWF4IHJldHJpZXMsIHRocm93IHRoZSBsYXN0IGVycm9yIGVuY291bnRlcmVkXHJcbiAgdGhyb3cgbGFzdEVycm9yIHx8IG5ldyBFcnJvcignTW9uZ29EQiBjb25uZWN0aW9uIGZhaWxlZCBhZnRlciBtYXhpbXVtIHJldHJ5IGF0dGVtcHRzJyk7XHJcbn1cclxuXHJcbmlmICghZ2xvYmFsLl9tb25nb0NsaWVudFByb21pc2UpIHtcclxuICBnbG9iYWwuX21vbmdvQ2xpZW50UHJvbWlzZSA9IGNvbm5lY3RXaXRoUmV0cnkoKTtcclxuICBcclxuICAvLyBPcHRpb25hbDogbG9nIGNvbm5lY3Rpb24gZXZlbnRzXHJcbiAgZ2xvYmFsLl9tb25nb0NsaWVudFByb21pc2VcclxuICAgIC50aGVuKGNsaWVudCA9PiB7XHJcbiAgICAgIGNsaWVudC5vbignc2VydmVyT3BlbmluZycsIChldmVudCkgPT4gY29uc29sZS5sb2coJ01vbmdvREIgc2VydmVyIG9wZW5pbmcnLCBldmVudCkpO1xyXG4gICAgICBjbGllbnQub24oJ3NlcnZlckNsb3NlZCcsIChldmVudCkgPT4gY29uc29sZS53YXJuKCdNb25nb0RCIHNlcnZlciBjbG9zZWQnLCBldmVudCkpO1xyXG4gICAgICBjbGllbnQub24oJ3RvcG9sb2d5Q2xvc2VkJywgKCkgPT4gY29uc29sZS53YXJuKCdNb25nb0RCIHRvcG9sb2d5IGNsb3NlZCcpKTtcclxuICAgICAgY2xpZW50Lm9uKCd0b3BvbG9neU9wZW5pbmcnLCAoKSA9PiBjb25zb2xlLmxvZygnTW9uZ29EQiB0b3BvbG9neSBvcGVuaW5nJykpO1xyXG4gICAgICBjbGllbnQub24oJ2Vycm9yJywgKGVycikgPT4gY29uc29sZS5lcnJvcignTW9uZ29EQiBlcnJvcicsIGVycikpO1xyXG4gICAgfSlcclxuICAgIC5jYXRjaChlcnIgPT4ge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdNb25nb0RCIGNsaWVudCBmYWlsZWQgdG8gY29ubmVjdCBhZnRlciByZXRyaWVzJywgZXJyKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5jbGllbnRQcm9taXNlID0gZ2xvYmFsLl9tb25nb0NsaWVudFByb21pc2U7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGllbnRQcm9taXNlOyJdLCJuYW1lcyI6WyJNb25nb0NsaWVudCIsInVyaSIsInByb2Nlc3MiLCJlbnYiLCJNT05HT0RCX1VSSSIsIkVycm9yIiwiY2xpZW50IiwiY2xpZW50UHJvbWlzZSIsImNvbm5lY3RXaXRoUmV0cnkiLCJNQVhfUkVUUklFUyIsImF0dGVtcHRzIiwibGFzdEVycm9yIiwibWF4UG9vbFNpemUiLCJzZXJ2ZXJTZWxlY3Rpb25UaW1lb3V0TVMiLCJzb2NrZXRUaW1lb3V0TVMiLCJjb25uZWN0IiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZ2xvYmFsIiwiX21vbmdvQ2xpZW50UHJvbWlzZSIsInRoZW4iLCJvbiIsImV2ZW50IiwibG9nIiwid2FybiIsImNhdGNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./lib/mongo.ts\n");

/***/ }),

/***/ "(api)/./lib/redis.ts":
/*!**********************!*\
  !*** ./lib/redis.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   redis: () => (/* binding */ redis),\n/* harmony export */   subscribe: () => (/* binding */ subscribe),\n/* harmony export */   subscribeToChannels: () => (/* binding */ subscribeToChannels)\n/* harmony export */ });\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ioredis */ \"ioredis\");\n/* harmony import */ var ioredis__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ioredis__WEBPACK_IMPORTED_MODULE_0__);\n// lib/redis.ts\n\nconst redis = new (ioredis__WEBPACK_IMPORTED_MODULE_0___default())(process.env.REDIS_URL || \"redis://127.0.0.1:6379\", {\n    maxRetriesPerRequest: null,\n    lazyConnect: true,\n    reconnectOnError: (err)=>{\n        const targetErrors = [\n            \"READONLY\",\n            \"ECONNRESET\",\n            \"ETIMEDOUT\"\n        ];\n        try {\n            if (err && typeof err.message === \"string\") {\n                return targetErrors.some((e)=>err.message.includes(e));\n            }\n        } catch  {\n        // fall through\n        }\n        return false;\n    }\n});\nredis.on(\"connect\", ()=>console.log(\"Redis connected\"));\nredis.on(\"ready\", ()=>console.log(\"Redis ready\"));\nredis.on(\"error\", (err)=>console.error(\"Redis error\", err));\nredis.on(\"close\", ()=>console.warn(\"Redis connection closed\"));\nredis.on(\"reconnecting\", ()=>console.log(\"Redis reconnecting\"));\n/**\r\n * Subscribe to a single Redis channel (ioredis-style).\r\n * Returns an async unsubscribe function.\r\n */ async function subscribe(channel, handler) {\n    const sub = redis.duplicate();\n    const onMessage = (msgChannel, message)=>{\n        if (msgChannel !== channel) return;\n        try {\n            handler(JSON.parse(message));\n        } catch  {\n            handler(message);\n        }\n    };\n    sub.on(\"error\", (err)=>{\n        console.error(`Redis subscriber error for channel ${channel}`, err);\n    });\n    sub.on(\"message\", onMessage);\n    try {\n        // connect only if not already connecting/ready\n        try {\n            if (typeof sub.connect === \"function\") {\n                const status = sub.status;\n                if (status !== \"ready\" && status !== \"connecting\") {\n                    await sub.connect().catch((err)=>{\n                        console.warn(\"Subscriber connect error (continuing):\", err);\n                    });\n                } else {\n                // already connecting/ready — skip connect\n                }\n            }\n        } catch (e) {\n            console.warn(\"Subscriber connect guard error\", e);\n        }\n        await sub.subscribe(channel).catch((err)=>{\n            console.warn(`subscribe(${channel}) failed`, err);\n        });\n    } catch (err) {\n        console.error(`Failed to subscribe to Redis channel ${channel}`, err);\n    }\n    return async ()=>{\n        try {\n            sub.off(\"message\", onMessage);\n            try {\n                await sub.unsubscribe(channel);\n            } catch (e) {}\n            try {\n                await sub.quit();\n            } catch (e) {}\n        } catch (err) {\n            console.warn(`Failed to cleanly unsubscribe from Redis channel ${channel}`, err);\n        }\n    };\n}\n/**\r\n * Robust multi-channel subscription helper.\r\n */ async function subscribeToChannels(sub, channels, handler) {\n    if (!sub || !channels || channels.length === 0) return;\n    // ensure connection if possible (guard against duplicate connect calls)\n    try {\n        if (typeof sub.connect === \"function\") {\n            const status = sub.status;\n            if (status !== \"ready\" && status !== \"connecting\") {\n                await sub.connect().catch((err)=>{\n                    console.warn(\"subscribeToChannels: subscriber connect warning\", err);\n                });\n            } else {\n            // already connecting/ready, skip connect\n            }\n        }\n    } catch (e) {\n    // ignore connect errors\n    }\n    for (const ch of channels){\n        try {\n            if (typeof sub.subscribe === \"function\") {\n                await sub.subscribe(ch).catch((err)=>{\n                    console.warn(`subscribeToChannels: subscribe(${ch}) failed`, err);\n                });\n            } else {\n                await sub.subscribe(ch);\n            }\n        } catch (e) {\n            console.warn(`subscribe failed for channel ${ch}, will attempt fallback`, e);\n        }\n    }\n    // Attach 'message' listener\n    try {\n        if (typeof sub.on === \"function\") {\n            const onMsg = (a, b)=>{\n                if (typeof a === \"string\" && typeof b === \"string\") {\n                    handler(a, b);\n                } else if (typeof b === \"string\" && channels.includes(b)) {\n                    handler(b, a);\n                } else {\n                    handler(String(a), String(b));\n                }\n            };\n            sub.__subscribe_to_channels_on_message = onMsg;\n            sub.on(\"message\", onMsg);\n        }\n    } catch (e) {\n        console.warn(\"Fallback Redis message hook failed\", e);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFJLE9BQU9BLE1BQU0sWUFBWUwsU0FBU3RCLFFBQVEsQ0FBQzJCLElBQUk7b0JBQ3hEbkIsUUFBUW1CLEdBQUdEO2dCQUNiLE9BQU87b0JBQ0xsQixRQUFRb0IsT0FBT0YsSUFBSUUsT0FBT0Q7Z0JBQzVCO1lBQ0Y7WUFDQ2xCLElBQVlvQixrQ0FBa0MsR0FBR0o7WUFDbERoQixJQUFJUixFQUFFLENBQUMsV0FBV3dCO1FBQ3BCO0lBQ0YsRUFBRSxPQUFPMUIsR0FBRztRQUNWRyxRQUFRRyxJQUFJLENBQUMsc0NBQXNDTjtJQUNyRDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFya2V0aW5nLW12cC8uL2xpYi9yZWRpcy50cz81MWU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGxpYi9yZWRpcy50c1xyXG5pbXBvcnQgSU9SZWRpcyBmcm9tICdpb3JlZGlzJztcclxuXHJcbmV4cG9ydCBjb25zdCByZWRpcyA9IG5ldyBJT1JlZGlzKHByb2Nlc3MuZW52LlJFRElTX1VSTCB8fCAncmVkaXM6Ly8xMjcuMC4wLjE6NjM3OScsIHtcclxuICBtYXhSZXRyaWVzUGVyUmVxdWVzdDogbnVsbCxcclxuICBsYXp5Q29ubmVjdDogdHJ1ZSxcclxuICByZWNvbm5lY3RPbkVycm9yOiAoZXJyOiBhbnkpID0+IHtcclxuICAgIGNvbnN0IHRhcmdldEVycm9ycyA9IFsnUkVBRE9OTFknLCAnRUNPTk5SRVNFVCcsICdFVElNRURPVVQnXTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGlmIChlcnIgJiYgdHlwZW9mIGVyci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXRFcnJvcnMuc29tZShlID0+IGVyci5tZXNzYWdlLmluY2x1ZGVzKGUpKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIC8vIGZhbGwgdGhyb3VnaFxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sXHJcbn0pO1xyXG5cclxucmVkaXMub24oJ2Nvbm5lY3QnLCAoKSA9PiBjb25zb2xlLmxvZygnUmVkaXMgY29ubmVjdGVkJykpO1xyXG5yZWRpcy5vbigncmVhZHknLCAoKSA9PiBjb25zb2xlLmxvZygnUmVkaXMgcmVhZHknKSk7XHJcbnJlZGlzLm9uKCdlcnJvcicsIChlcnIpID0+IGNvbnNvbGUuZXJyb3IoJ1JlZGlzIGVycm9yJywgZXJyKSk7XHJcbnJlZGlzLm9uKCdjbG9zZScsICgpID0+IGNvbnNvbGUud2FybignUmVkaXMgY29ubmVjdGlvbiBjbG9zZWQnKSk7XHJcbnJlZGlzLm9uKCdyZWNvbm5lY3RpbmcnLCAoKSA9PiBjb25zb2xlLmxvZygnUmVkaXMgcmVjb25uZWN0aW5nJykpO1xyXG5cclxuLyoqXHJcbiAqIFN1YnNjcmliZSB0byBhIHNpbmdsZSBSZWRpcyBjaGFubmVsIChpb3JlZGlzLXN0eWxlKS5cclxuICogUmV0dXJucyBhbiBhc3luYyB1bnN1YnNjcmliZSBmdW5jdGlvbi5cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdWJzY3JpYmUoY2hhbm5lbDogc3RyaW5nLCBoYW5kbGVyOiAoZGF0YTogYW55KSA9PiB2b2lkKTogUHJvbWlzZTwoKSA9PiBQcm9taXNlPHZvaWQ+PiB7XHJcbiAgY29uc3Qgc3ViID0gcmVkaXMuZHVwbGljYXRlKCk7XHJcblxyXG4gIGNvbnN0IG9uTWVzc2FnZSA9IChtc2dDaGFubmVsOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZykgPT4ge1xyXG4gICAgaWYgKG1zZ0NoYW5uZWwgIT09IGNoYW5uZWwpIHJldHVybjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGhhbmRsZXIoSlNPTi5wYXJzZShtZXNzYWdlKSk7XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgaGFuZGxlcihtZXNzYWdlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBzdWIub24oJ2Vycm9yJywgKGVycjogYW55KSA9PiB7XHJcbiAgICBjb25zb2xlLmVycm9yKGBSZWRpcyBzdWJzY3JpYmVyIGVycm9yIGZvciBjaGFubmVsICR7Y2hhbm5lbH1gLCBlcnIpO1xyXG4gIH0pO1xyXG5cclxuICBzdWIub24oJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpO1xyXG5cclxuICB0cnkge1xyXG4gICAgLy8gY29ubmVjdCBvbmx5IGlmIG5vdCBhbHJlYWR5IGNvbm5lY3RpbmcvcmVhZHlcclxuICAgIHRyeSB7XHJcbiAgICAgIGlmICh0eXBlb2YgKHN1YiBhcyBhbnkpLmNvbm5lY3QgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBjb25zdCBzdGF0dXMgPSAoc3ViIGFzIGFueSkuc3RhdHVzO1xyXG4gICAgICAgIGlmIChzdGF0dXMgIT09ICdyZWFkeScgJiYgc3RhdHVzICE9PSAnY29ubmVjdGluZycpIHtcclxuICAgICAgICAgIGF3YWl0IChzdWIgYXMgYW55KS5jb25uZWN0KCkuY2F0Y2goKGVycjogYW55KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignU3Vic2NyaWJlciBjb25uZWN0IGVycm9yIChjb250aW51aW5nKTonLCBlcnIpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIGFscmVhZHkgY29ubmVjdGluZy9yZWFkeSDigJQgc2tpcCBjb25uZWN0XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignU3Vic2NyaWJlciBjb25uZWN0IGd1YXJkIGVycm9yJywgZSk7XHJcbiAgICB9XHJcblxyXG4gICAgYXdhaXQgKHN1YiBhcyBhbnkpLnN1YnNjcmliZShjaGFubmVsKS5jYXRjaCgoZXJyOiBhbnkpID0+IHtcclxuICAgICAgY29uc29sZS53YXJuKGBzdWJzY3JpYmUoJHtjaGFubmVsfSkgZmFpbGVkYCwgZXJyKTtcclxuICAgIH0pO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHN1YnNjcmliZSB0byBSZWRpcyBjaGFubmVsICR7Y2hhbm5lbH1gLCBlcnIpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHN1Yi5vZmYoJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpO1xyXG4gICAgICB0cnkgeyBhd2FpdCAoc3ViIGFzIGFueSkudW5zdWJzY3JpYmUoY2hhbm5lbCk7IH0gY2F0Y2ggKGUpIHt9XHJcbiAgICAgIHRyeSB7IGF3YWl0IChzdWIgYXMgYW55KS5xdWl0KCk7IH0gY2F0Y2ggKGUpIHt9XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gY2xlYW5seSB1bnN1YnNjcmliZSBmcm9tIFJlZGlzIGNoYW5uZWwgJHtjaGFubmVsfWAsIGVycik7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJvYnVzdCBtdWx0aS1jaGFubmVsIHN1YnNjcmlwdGlvbiBoZWxwZXIuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3Vic2NyaWJlVG9DaGFubmVscyhcclxuICBzdWI6IGFueSxcclxuICBjaGFubmVsczogc3RyaW5nW10sXHJcbiAgaGFuZGxlcjogKGNoYW5uZWw6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkXHJcbik6IFByb21pc2U8dm9pZD4ge1xyXG4gIGlmICghc3ViIHx8ICFjaGFubmVscyB8fCBjaGFubmVscy5sZW5ndGggPT09IDApIHJldHVybjtcclxuXHJcbiAgLy8gZW5zdXJlIGNvbm5lY3Rpb24gaWYgcG9zc2libGUgKGd1YXJkIGFnYWluc3QgZHVwbGljYXRlIGNvbm5lY3QgY2FsbHMpXHJcbiAgdHJ5IHtcclxuICAgIGlmICh0eXBlb2Ygc3ViLmNvbm5lY3QgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgY29uc3Qgc3RhdHVzID0gKHN1YiBhcyBhbnkpLnN0YXR1cztcclxuICAgICAgaWYgKHN0YXR1cyAhPT0gJ3JlYWR5JyAmJiBzdGF0dXMgIT09ICdjb25uZWN0aW5nJykge1xyXG4gICAgICAgIGF3YWl0IHN1Yi5jb25uZWN0KCkuY2F0Y2goKGVycjogYW55KSA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ3N1YnNjcmliZVRvQ2hhbm5lbHM6IHN1YnNjcmliZXIgY29ubmVjdCB3YXJuaW5nJywgZXJyKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBhbHJlYWR5IGNvbm5lY3RpbmcvcmVhZHksIHNraXAgY29ubmVjdFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgLy8gaWdub3JlIGNvbm5lY3QgZXJyb3JzXHJcbiAgfVxyXG5cclxuICBmb3IgKGNvbnN0IGNoIG9mIGNoYW5uZWxzKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAodHlwZW9mIHN1Yi5zdWJzY3JpYmUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBhd2FpdCBzdWIuc3Vic2NyaWJlKGNoKS5jYXRjaCgoZXJyOiBhbnkpID0+IHtcclxuICAgICAgICAgIGNvbnNvbGUud2Fybihgc3Vic2NyaWJlVG9DaGFubmVsczogc3Vic2NyaWJlKCR7Y2h9KSBmYWlsZWRgLCBlcnIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGF3YWl0IChzdWIgYXMgYW55KS5zdWJzY3JpYmUoY2gpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUud2Fybihgc3Vic2NyaWJlIGZhaWxlZCBmb3IgY2hhbm5lbCAke2NofSwgd2lsbCBhdHRlbXB0IGZhbGxiYWNrYCwgZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBBdHRhY2ggJ21lc3NhZ2UnIGxpc3RlbmVyXHJcbiAgdHJ5IHtcclxuICAgIGlmICh0eXBlb2Ygc3ViLm9uID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGNvbnN0IG9uTXNnID0gKGE6IGFueSwgYjogYW55KSA9PiB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIGhhbmRsZXIoYSwgYik7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYiA9PT0gJ3N0cmluZycgJiYgY2hhbm5lbHMuaW5jbHVkZXMoYikpIHtcclxuICAgICAgICAgIGhhbmRsZXIoYiwgYSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGhhbmRsZXIoU3RyaW5nKGEpLCBTdHJpbmcoYikpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgKHN1YiBhcyBhbnkpLl9fc3Vic2NyaWJlX3RvX2NoYW5uZWxzX29uX21lc3NhZ2UgPSBvbk1zZztcclxuICAgICAgc3ViLm9uKCdtZXNzYWdlJywgb25Nc2cpO1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGNvbnNvbGUud2FybignRmFsbGJhY2sgUmVkaXMgbWVzc2FnZSBob29rIGZhaWxlZCcsIGUpO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsiSU9SZWRpcyIsInJlZGlzIiwicHJvY2VzcyIsImVudiIsIlJFRElTX1VSTCIsIm1heFJldHJpZXNQZXJSZXF1ZXN0IiwibGF6eUNvbm5lY3QiLCJyZWNvbm5lY3RPbkVycm9yIiwiZXJyIiwidGFyZ2V0RXJyb3JzIiwibWVzc2FnZSIsInNvbWUiLCJlIiwiaW5jbHVkZXMiLCJvbiIsImNvbnNvbGUiLCJsb2ciLCJlcnJvciIsIndhcm4iLCJzdWJzY3JpYmUiLCJjaGFubmVsIiwiaGFuZGxlciIsInN1YiIsImR1cGxpY2F0ZSIsIm9uTWVzc2FnZSIsIm1zZ0NoYW5uZWwiLCJKU09OIiwicGFyc2UiLCJjb25uZWN0Iiwic3RhdHVzIiwiY2F0Y2giLCJvZmYiLCJ1bnN1YnNjcmliZSIsInF1aXQiLCJzdWJzY3JpYmVUb0NoYW5uZWxzIiwiY2hhbm5lbHMiLCJsZW5ndGgiLCJjaCIsIm9uTXNnIiwiYSIsImIiLCJTdHJpbmciLCJfX3N1YnNjcmliZV90b19jaGFubmVsc19vbl9tZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./lib/redis.ts\n");

/***/ }),

/***/ "(api)/./pages/api/campaign/[id]/control.ts":
/*!********************************************!*\
  !*** ./pages/api/campaign/[id]/control.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var _lib_mongo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../lib/mongo */ \"(api)/./lib/mongo.ts\");\n/* harmony import */ var _lib_redis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../lib/redis */ \"(api)/./lib/redis.ts\");\n/* harmony import */ var bullmq__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bullmq */ \"bullmq\");\n/* harmony import */ var bullmq__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(bullmq__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! mongodb */ \"mongodb\");\n/* harmony import */ var mongodb__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(mongodb__WEBPACK_IMPORTED_MODULE_3__);\n// pages/api/campaign/[id]/control.ts\n\n\n\n\nconst queue = new bullmq__WEBPACK_IMPORTED_MODULE_2__.Queue(\"campaigns\", {\n    connection: _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis\n});\n// keep parity with worker; allow env override\nconst MAX_ATTEMPTS = Number(process.env.MAX_ATTEMPTS || 3);\n// server-side cap for batch retries per request\nconst BATCH_RETRY_LIMIT = Number(process.env.BATCH_RETRY_LIMIT || 5000);\n// when resuming, limit how many pending jobs we'll try to (re)enqueue\nconst RESUME_ENQUEUE_LIMIT = Number(process.env.RESUME_ENQUEUE_LIMIT || 5000);\n// how long before a 'sending' row is considered stale and eligible for recovery (ms)\nconst STALE_SENDING_MS = Number(process.env.STALE_SENDING_MS || 90000);\nasync function safeHSet(key, obj) {\n    try {\n        await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hset(key, obj);\n    } catch (err) {\n        console.warn(\"Redis unavailable while setting meta\", err);\n    }\n}\nasync function safePublish(channel, payload) {\n    try {\n        await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.publish(channel, JSON.stringify(payload));\n    } catch (err) {\n        console.warn(\"Redis publish failed\", err);\n    }\n}\n// Remove waiting/delayed/active jobs for a campaignId (best-effort)\nasync function removeQueuedJobsForCampaign(campaignId) {\n    try {\n        // get waiting/delayed/active jobs\n        const jobs = await queue.getJobs([\n            \"waiting\",\n            \"delayed\",\n            \"active\",\n            \"paused\"\n        ], 0, -1);\n        const matched = jobs.filter((j)=>{\n            try {\n                return j.data?.campaignId === campaignId;\n            } catch  {\n                return false;\n            }\n        });\n        for (const j of matched){\n            try {\n                // if the job is active, remove may fail - still try\n                await j.remove();\n            } catch (e) {\n                // best-effort — ignore\n                console.warn(`Failed to remove job ${j.id}`, e);\n            }\n        }\n        return matched.length;\n    } catch (err) {\n        console.warn(\"Failed to enumerate/remove jobs for campaign\", err);\n        return 0;\n    }\n}\n// Remove queued jobs for a specific contact within a campaign (best-effort)\nasync function removeQueuedJobsForCampaignContact(campaignId, contactId) {\n    try {\n        const jobs = await queue.getJobs([\n            \"waiting\",\n            \"delayed\",\n            \"active\",\n            \"paused\"\n        ], 0, -1);\n        const matched = jobs.filter((j)=>{\n            try {\n                return j.data?.campaignId === campaignId && String(j.data?.contactId) === String(contactId);\n            } catch  {\n                return false;\n            }\n        });\n        for (const j of matched){\n            try {\n                await j.remove();\n            } catch (e) {\n                console.warn(`Failed to remove job ${j.id} for contact ${contactId}`, e);\n            }\n        }\n        return matched.length;\n    } catch (e) {\n        console.warn(\"Failed to enumerate/remove jobs for campaign contact\", e);\n        return 0;\n    }\n}\n// safe read of redis meta integer field\nasync function safeGetMetaInt(redisKey, field) {\n    try {\n        const v = await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hget(redisKey, field);\n        return Number(v || 0);\n    } catch (e) {\n        return 0;\n    }\n}\n/**\r\n * Ensure there is a usable `campaign:{id}:definition` in Redis.\r\n * If missing, attempt to construct one from the Mongo campaign document.\r\n * Returns true if definition exists or was written successfully.\r\n */ async function ensureCampaignDefinition(id, campaignDoc) {\n    const key = `campaign:${id}:definition`;\n    try {\n        const existing = await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.get(key);\n        if (existing) return true;\n        // Attempt to build a minimal compatible definition\n        // Worker expects { initial: { subject, body }, followUps: [...] }\n        let built = null;\n        // Prefer explicit shapes commonly used\n        if (campaignDoc?.definition && typeof campaignDoc.definition === \"object\") {\n            built = campaignDoc.definition;\n        } else if (campaignDoc?.initial && typeof campaignDoc.initial === \"object\") {\n            built = {\n                initial: campaignDoc.initial,\n                followUps: campaignDoc.followUps || []\n            };\n        } else if (campaignDoc?.template && typeof campaignDoc.template === \"object\") {\n            built = {\n                initial: {\n                    subject: campaignDoc.template.subject || campaignDoc.name,\n                    body: campaignDoc.template.body || campaignDoc.content || \"\"\n                },\n                followUps: campaignDoc.template.followUps || campaignDoc.followUps || []\n            };\n        } else {\n            // fallback: try to glean subject/body from common fields\n            const subject = campaignDoc?.subject || campaignDoc?.title || campaignDoc?.name || `Campaign ${id}`;\n            const body = campaignDoc?.body || campaignDoc?.content || campaignDoc?.html || \"\";\n            const followUps = campaignDoc?.followUps || campaignDoc?.steps || [];\n            built = {\n                initial: {\n                    subject,\n                    body\n                },\n                followUps\n            };\n        }\n        // If built doesn't look right (no initial subject/body), fail safe\n        if (!built || !built.initial || built.initial.subject == null && built.initial.body == null) {\n            console.warn(\"Unable to construct campaign definition from campaign document\", {\n                campaignId: id,\n                sample: campaignDoc ? Object.keys(campaignDoc).slice(0, 8) : null\n            });\n            return false;\n        }\n        // Persist into Redis (no expiry) so worker can read it\n        try {\n            await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.set(key, JSON.stringify(built));\n            console.log(`Wrote fallback campaign definition into redis for ${id}`);\n            return true;\n        } catch (e) {\n            console.warn(\"Failed to write campaign definition to redis\", e);\n            return false;\n        }\n    } catch (e) {\n        console.warn(\"Error checking/writing campaign definition in redis\", e);\n        return false;\n    }\n}\n/**\r\n * Get a set of contactId strings for jobs currently enqueued for this campaign.\r\n * Used to avoid enqueuing duplicates when resuming.\r\n */ async function getQueuedContactIdsForCampaign(campaignId) {\n    const set = new Set();\n    try {\n        const jobs = await queue.getJobs([\n            \"waiting\",\n            \"delayed\",\n            \"active\",\n            \"paused\"\n        ], 0, -1);\n        for (const j of jobs){\n            try {\n                if (j.data?.campaignId === campaignId && j.data?.contactId) {\n                    set.add(String(j.data.contactId));\n                }\n            } catch  {\n            // ignore malformed jobs\n            }\n        }\n    } catch (e) {\n        console.warn(\"Failed to list queued jobs for campaign when checking duplicates\", e);\n    }\n    return set;\n}\nfunction tryParseObjectId(s) {\n    if (!s) return null;\n    if (typeof s === \"object\" && s instanceof mongodb__WEBPACK_IMPORTED_MODULE_3__.ObjectId) return s;\n    if (typeof s === \"string\" && /^[0-9a-fA-F]{24}$/.test(s)) {\n        try {\n            return new mongodb__WEBPACK_IMPORTED_MODULE_3__.ObjectId(s);\n        } catch  {\n            return null;\n        }\n    }\n    return null;\n}\nasync function handler(req, res) {\n    if (req.method !== \"POST\") {\n        return res.status(405).json({\n            error: \"Method not allowed\"\n        });\n    }\n    const { id } = req.query;\n    if (!id || typeof id !== \"string\") {\n        return res.status(400).json({\n            error: \"Invalid campaign id\"\n        });\n    }\n    const { action, confirm, contactId, email, reason, by } = req.body;\n    const allowedActions = [\n        \"pause\",\n        \"resume\",\n        \"cancel\",\n        \"delete\",\n        \"retryFailed\",\n        \"retryContact\",\n        \"reconcile\",\n        \"overrideCreate\",\n        \"overrideDelete\",\n        \"overrideList\"\n    ];\n    if (!action || !allowedActions.includes(action)) {\n        return res.status(400).json({\n            error: \"Invalid action\"\n        });\n    }\n    const client = await _lib_mongo__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    const db = client.db(\"PlatformData\");\n    let campaignObjectId = null;\n    try {\n        campaignObjectId = new mongodb__WEBPACK_IMPORTED_MODULE_3__.ObjectId(id);\n    } catch  {\n        // if id isn't a valid ObjectId, keep null and use string match fallback\n        campaignObjectId = null;\n    }\n    try {\n        // Reload campaign from Mongo (authoritative) unless action is overrideList (listing overrides can still proceed)\n        const campaign = campaignObjectId ? await db.collection(\"campaigns\").findOne({\n            _id: campaignObjectId\n        }) : await db.collection(\"campaigns\").findOne({\n            _id: id\n        });\n        if (!campaign && action !== \"overrideList\") {\n            return res.status(404).json({\n                error: \"Campaign not found\"\n            });\n        }\n        // Lightweight helpers\n        const redisKey = `campaign:${id}:meta`;\n        // ---------------------------\n        // Manual override actions\n        // ---------------------------\n        // Create a manual override: persist doc, mark ledger row(s), remove queued jobs for that contact\n        if (action === \"overrideCreate\") {\n            if (!contactId && !email) {\n                return res.status(400).json({\n                    error: \"contactId or email required for overrideCreate\"\n                });\n            }\n            const now = new Date().toISOString();\n            const campaignIdStore = campaignObjectId ?? id;\n            const insertDoc = {\n                campaignId: campaignIdStore,\n                contactId: contactId ?? null,\n                email: email ?? null,\n                reason: reason ?? \"manual_override\",\n                by: by ?? null,\n                at: now\n            };\n            // Persist override doc\n            const insertRes = await db.collection(\"campaign_overrides\").insertOne(insertDoc);\n            // Build contact filters (support objectId/string/email/_id)\n            const contactFilters = [];\n            if (contactId) {\n                const maybeObj = tryParseObjectId(contactId);\n                if (maybeObj) contactFilters.push({\n                    contactId: maybeObj\n                });\n                contactFilters.push({\n                    contactId: String(contactId)\n                });\n                // support ledger _id if provided\n                if (/^[0-9a-fA-F]{24}$/.test(String(contactId))) {\n                    try {\n                        contactFilters.push({\n                            _id: new mongodb__WEBPACK_IMPORTED_MODULE_3__.ObjectId(String(contactId))\n                        });\n                    } catch  {}\n                }\n            }\n            if (email) {\n                contactFilters.push({\n                    email: String(email)\n                });\n            }\n            if (contactFilters.length > 0) {\n                // Mark matching campaign_contacts rows as manually overridden\n                const updateFilter = campaignObjectId ? {\n                    $and: [\n                        {\n                            $or: [\n                                {\n                                    campaignId: campaignObjectId\n                                },\n                                {\n                                    campaignId: id\n                                }\n                            ]\n                        },\n                        {\n                            $or: contactFilters\n                        }\n                    ]\n                } : {\n                    $and: [\n                        {\n                            campaignId: id\n                        },\n                        {\n                            $or: contactFilters\n                        }\n                    ]\n                };\n                await db.collection(\"campaign_contacts\").updateMany(updateFilter, {\n                    $set: {\n                        manuallyOverridden: true,\n                        status: \"overridden\",\n                        overrideAt: now,\n                        overrideReason: insertDoc.reason,\n                        overrideBy: insertDoc.by\n                    }\n                });\n            }\n            // Remove queued jobs for that contact (best-effort)\n            let removedJobs = 0;\n            if (contactId) {\n                try {\n                    removedJobs = await removeQueuedJobsForCampaignContact(id, contactId);\n                } catch (e) {\n                    console.warn(\"Failed to remove queued jobs for overridden contact\", e);\n                }\n            }\n            // Publish contact update and campaign-level event\n            try {\n                if (contactId) {\n                    await safePublish(`campaign:${id}:contact_update`, {\n                        contactId: String(contactId),\n                        status: \"overridden\",\n                        manuallyOverridden: true\n                    });\n                }\n            } catch (_) {}\n            await safePublish(\"campaign:new\", {\n                id,\n                action: \"overrideCreate\",\n                overrideId: insertRes.insertedId?.toString?.(),\n                contactId: contactId ?? null,\n                email: email ?? null,\n                removedJobs\n            });\n            return res.status(200).json({\n                ok: true,\n                override: {\n                    ...insertDoc,\n                    _id: insertRes.insertedId\n                },\n                removedJobs\n            });\n        }\n        // Delete/undo override: remove override docs, unset ledger flag and optionally restore status\n        if (action === \"overrideDelete\") {\n            if (!contactId && !email) {\n                return res.status(400).json({\n                    error: \"contactId or email required for overrideDelete\"\n                });\n            }\n            const campaignIdStore = campaignObjectId ?? id;\n            const query = {\n                campaignId: campaignIdStore,\n                $or: []\n            };\n            if (contactId) {\n                query.$or.push({\n                    contactId: contactId\n                });\n                const maybeObj = tryParseObjectId(contactId);\n                if (maybeObj) query.$or.push({\n                    contactId: maybeObj\n                });\n                if (/^[0-9a-fA-F]{24}$/.test(String(contactId))) {\n                    try {\n                        query.$or.push({\n                            _id: new mongodb__WEBPACK_IMPORTED_MODULE_3__.ObjectId(String(contactId))\n                        });\n                    } catch  {}\n                }\n            }\n            if (email) query.$or.push({\n                email: String(email)\n            });\n            if (query.$or.length === 0) {\n                return res.status(400).json({\n                    error: \"no valid identifier provided\"\n                });\n            }\n            const delRes = await db.collection(\"campaign_overrides\").deleteMany(query);\n            // Unset manuallyOverridden flag on ledger rows and clear override metadata\n            const contactFilters = [];\n            if (contactId) {\n                const maybeObj = tryParseObjectId(contactId);\n                if (maybeObj) contactFilters.push({\n                    contactId: maybeObj\n                });\n                contactFilters.push({\n                    contactId: String(contactId)\n                });\n                if (/^[0-9a-fA-F]{24}$/.test(String(contactId))) {\n                    try {\n                        contactFilters.push({\n                            _id: new mongodb__WEBPACK_IMPORTED_MODULE_3__.ObjectId(String(contactId))\n                        });\n                    } catch  {}\n                }\n            }\n            if (email) contactFilters.push({\n                email: String(email)\n            });\n            if (contactFilters.length > 0) {\n                const updateFilter = campaignObjectId ? {\n                    $and: [\n                        {\n                            $or: [\n                                {\n                                    campaignId: campaignObjectId\n                                },\n                                {\n                                    campaignId: id\n                                }\n                            ]\n                        },\n                        {\n                            $or: contactFilters\n                        }\n                    ]\n                } : {\n                    $and: [\n                        {\n                            campaignId: id\n                        },\n                        {\n                            $or: contactFilters\n                        }\n                    ]\n                };\n                // Unset flags and metadata\n                await db.collection(\"campaign_contacts\").updateMany(updateFilter, {\n                    $set: {\n                        manuallyOverridden: false\n                    },\n                    $unset: {\n                        overrideAt: \"\",\n                        overrideReason: \"\",\n                        overrideBy: \"\"\n                    }\n                });\n                // If a ledger row currently has status 'overridden' restore it to 'pending' so campaign continues for that contact.\n                await db.collection(\"campaign_contacts\").updateMany({\n                    $and: [\n                        updateFilter,\n                        {\n                            status: \"overridden\"\n                        }\n                    ]\n                }, {\n                    $set: {\n                        status: \"pending\",\n                        lastError: null,\n                        bgAttempts: 0\n                    }\n                });\n            }\n            // Publish campaign event so UI refreshes\n            await safePublish(\"campaign:new\", {\n                id,\n                action: \"overrideDelete\",\n                removed: delRes.deletedCount || 0\n            });\n            return res.status(200).json({\n                ok: true,\n                removed: delRes.deletedCount ?? 0\n            });\n        }\n        // List overrides for a campaign\n        if (action === \"overrideList\") {\n            try {\n                const campaignIdStore = campaignObjectId ?? id;\n                const items = await db.collection(\"campaign_overrides\").find({\n                    campaignId: campaignIdStore\n                }).sort({\n                    at: -1\n                }).toArray();\n                return res.status(200).json({\n                    ok: true,\n                    items\n                });\n            } catch (e) {\n                console.error(\"Failed to list overrides\", e);\n                return res.status(500).json({\n                    error: \"overrides-list-failed\"\n                });\n            }\n        }\n        // ---------------------------\n        // Existing actions (unchanged)\n        // ---------------------------\n        // ACTION: Pause\n        if (action === \"pause\") {\n            if (campaign.status === \"paused\") {\n                return res.status(200).json({\n                    ok: true,\n                    message: \"Already paused\"\n                });\n            }\n            await db.collection(\"campaigns\").updateOne({\n                _id: campaignObjectId\n            }, {\n                $set: {\n                    status: \"paused\"\n                }\n            });\n            await safeHSet(redisKey, {\n                status: \"paused\"\n            });\n            // publish campaign-level event so UI disables retry buttons and updates state\n            await safePublish(\"campaign:new\", {\n                id,\n                status: \"paused\"\n            });\n            return res.status(200).json({\n                ok: true,\n                action: \"paused\"\n            });\n        }\n        // ACTION: Resume\n        if (action === \"resume\") {\n            if (campaign.status === \"running\") {\n                return res.status(200).json({\n                    ok: true,\n                    message: \"Already running\"\n                });\n            }\n            // set running in DB + redis\n            await db.collection(\"campaigns\").updateOne({\n                _id: campaignObjectId\n            }, {\n                $set: {\n                    status: \"running\"\n                }\n            });\n            await safeHSet(redisKey, {\n                status: \"running\"\n            });\n            await safePublish(\"campaign:new\", {\n                id,\n                status: \"running\"\n            });\n            // Re-enqueue pending contacts that currently have no queued job for this campaign.\n            // This addresses cases where jobs were removed or not enqueued while the campaign was paused,\n            // ensuring pending rows actually get processed again after resume.\n            try {\n                const queuedSet = await getQueuedContactIdsForCampaign(id);\n                // fetch pending docs (limit to a sane cap)\n                const pendingCursor = db.collection(\"campaign_contacts\").find({\n                    campaignId: campaignObjectId,\n                    status: \"pending\"\n                }, {\n                    projection: {\n                        _id: 1,\n                        contactId: 1,\n                        step: 1\n                    }\n                }).limit(RESUME_ENQUEUE_LIMIT);\n                const pending = await pendingCursor.toArray();\n                const enqueuePromises = [];\n                for (const d of pending){\n                    const cid = d.contactId ? d.contactId.toString ? d.contactId.toString() : String(d.contactId) : d._id.toString ? d._id.toString() : String(d._id);\n                    if (queuedSet.has(cid)) continue; // already queued\n                    try {\n                        enqueuePromises.push(queue.add(d.step ? \"followup\" : \"initial\", {\n                            campaignId: id,\n                            contactId: cid,\n                            step: d.step\n                        }, {\n                            removeOnComplete: true,\n                            removeOnFail: true,\n                            attempts: MAX_ATTEMPTS,\n                            backoff: {\n                                type: \"exponential\",\n                                delay: 60000\n                            }\n                        }));\n                    } catch (e) {\n                        console.warn(\"Failed to enqueue pending contact on resume\", e);\n                    }\n                }\n                // attempt to enqueue in parallel (best-effort)\n                if (enqueuePromises.length > 0) {\n                    await Promise.allSettled(enqueuePromises);\n                    // notify UI that contacts have been re-queued (counts unchanged, but UI may want to refresh)\n                    await safePublish(\"campaign:new\", {\n                        id,\n                        action: \"resume_requeued\",\n                        requeued: enqueuePromises.length\n                    });\n                }\n            } catch (e) {\n                console.warn(\"Failed to re-enqueue pending contacts on resume\", e);\n            }\n            // Recover stale 'sending' ledger rows that may have been left in 'sending' by a crashed worker or killed process.\n            // Criteria: status === 'sending' AND lastAttemptAt older than STALE_SENDING_MS AND bgAttempts < MAX_ATTEMPTS\n            // We'll set them back to 'pending', reset bgAttempts to 0 (so background cycle restarts), and enqueue jobs.\n            try {\n                const cutoff = new Date(Date.now() - STALE_SENDING_MS);\n                const staleCursor = db.collection(\"campaign_contacts\").find({\n                    campaignId: campaignObjectId,\n                    status: \"sending\",\n                    lastAttemptAt: {\n                        $lt: cutoff\n                    }\n                }, {\n                    projection: {\n                        _id: 1,\n                        contactId: 1,\n                        step: 1,\n                        bgAttempts: 1\n                    }\n                }).limit(RESUME_ENQUEUE_LIMIT);\n                const staleDocs = await staleCursor.toArray();\n                if (staleDocs.length > 0) {\n                    const ids = staleDocs.map((d)=>d._id);\n                    // Reset to pending and clear lastError, reset bgAttempts so background retries start fresh\n                    await db.collection(\"campaign_contacts\").updateMany({\n                        _id: {\n                            $in: ids\n                        }\n                    }, {\n                        $set: {\n                            status: \"pending\",\n                            lastError: null,\n                            bgAttempts: 0\n                        }\n                    });\n                    // Enqueue each stale doc if not already queued\n                    const queuedSet2 = await getQueuedContactIdsForCampaign(id);\n                    const requeuePromises = [];\n                    for (const d of staleDocs){\n                        const cid = d.contactId ? d.contactId.toString ? d.contactId.toString() : String(d.contactId) : d._id.toString ? d._id.toString() : String(d._id);\n                        if (queuedSet2.has(cid)) continue;\n                        try {\n                            requeuePromises.push(queue.add(d.step ? \"followup\" : \"initial\", {\n                                campaignId: id,\n                                contactId: cid,\n                                step: d.step\n                            }, {\n                                removeOnComplete: true,\n                                removeOnFail: true,\n                                attempts: MAX_ATTEMPTS,\n                                backoff: {\n                                    type: \"exponential\",\n                                    delay: 60000\n                                }\n                            }));\n                        } catch (e) {\n                            console.warn(\"Failed to enqueue stale sending contact on resume\", e);\n                        }\n                        // publish contact-level update hint so UI reflects it's now pending\n                        try {\n                            safePublish(`campaign:${id}:contact_update`, {\n                                contactId: cid,\n                                status: \"pending\",\n                                bgAttempts: 0,\n                                attempts: undefined\n                            });\n                        } catch (_) {}\n                    }\n                    if (requeuePromises.length > 0) await Promise.allSettled(requeuePromises);\n                    await safePublish(\"campaign:new\", {\n                        id,\n                        action: \"resume_recovered_sending\",\n                        recovered: staleDocs.length\n                    });\n                }\n            } catch (e) {\n                console.warn(\"Failed to recover stale sending rows on resume\", e);\n            }\n            return res.status(200).json({\n                ok: true,\n                action: \"resumed\"\n            });\n        }\n        // ACTION: Reconcile (lightweight, single-request reconciliation)\n        if (action === \"reconcile\") {\n            try {\n                // 1) Recover stale 'sending' rows -> pending\n                const cutoff = new Date(Date.now() - STALE_SENDING_MS);\n                const staleSending = await db.collection(\"campaign_contacts\").find({\n                    campaignId: campaignObjectId,\n                    status: \"sending\",\n                    lastAttemptAt: {\n                        $lt: cutoff\n                    }\n                }).project({\n                    _id: 1,\n                    contactId: 1,\n                    step: 1\n                }).limit(RESUME_ENQUEUE_LIMIT).toArray();\n                if (staleSending.length > 0) {\n                    const ids = staleSending.map((d)=>d._id);\n                    await db.collection(\"campaign_contacts\").updateMany({\n                        _id: {\n                            $in: ids\n                        }\n                    }, {\n                        $set: {\n                            status: \"pending\",\n                            lastError: null,\n                            bgAttempts: 0\n                        }\n                    });\n                }\n                // 2) Enqueue pending docs that do not currently have a job\n                const queuedSet = await getQueuedContactIdsForCampaign(id);\n                const pendingCursor = db.collection(\"campaign_contacts\").find({\n                    campaignId: campaignObjectId,\n                    status: \"pending\"\n                }, {\n                    projection: {\n                        _id: 1,\n                        contactId: 1,\n                        step: 1\n                    }\n                }).limit(RESUME_ENQUEUE_LIMIT);\n                const pendingRows = await pendingCursor.toArray();\n                const enqueuePromises = [];\n                for (const d of pendingRows){\n                    const cid = d.contactId ? d.contactId.toString ? d.contactId.toString() : String(d.contactId) : d._id.toString ? d._id.toString() : String(d._id);\n                    if (queuedSet.has(cid)) continue;\n                    try {\n                        enqueuePromises.push(queue.add(d.step ? \"followup\" : \"initial\", {\n                            campaignId: id,\n                            contactId: cid,\n                            step: d.step\n                        }, {\n                            removeOnComplete: true,\n                            removeOnFail: true,\n                            attempts: MAX_ATTEMPTS,\n                            backoff: {\n                                type: \"exponential\",\n                                delay: 60000\n                            }\n                        }));\n                    } catch (e) {\n                        console.warn(\"Reconcile: failed to enqueue\", e);\n                    }\n                }\n                if (enqueuePromises.length) await Promise.allSettled(enqueuePromises);\n                // 3) Recalculate totals from DB (authoritative)\n                const agg = await db.collection(\"campaign_contacts\").aggregate([\n                    {\n                        $match: {\n                            campaignId: campaignObjectId\n                        }\n                    },\n                    {\n                        $group: {\n                            _id: \"$status\",\n                            count: {\n                                $sum: 1\n                            }\n                        }\n                    }\n                ]).toArray();\n                let pending = 0, sent = 0, failed = 0;\n                for (const r of agg){\n                    if (r._id === \"pending\") pending = r.count;\n                    else if (r._id === \"sent\") sent = r.count;\n                    else if (r._id === \"failed\") failed = r.count;\n                }\n                const processed = sent + failed;\n                const intended = campaign.totals?.intended ?? await db.collection(\"campaign_contacts\").countDocuments({\n                    campaignId: campaignObjectId\n                });\n                // Write back authoritative totals to DB\n                await db.collection(\"campaigns\").updateOne({\n                    _id: campaignObjectId\n                }, {\n                    $set: {\n                        \"totals.processed\": processed,\n                        \"totals.sent\": sent,\n                        \"totals.failed\": failed\n                    }\n                });\n                // Best-effort write to Redis meta\n                try {\n                    await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hset(redisKey, {\n                        processed: String(processed),\n                        sent: String(sent),\n                        failed: String(failed),\n                        total: String(intended)\n                    });\n                } catch (_) {}\n                // 4) Decide canonical campaign status\n                let newStatus = campaign.status;\n                if (processed >= intended) {\n                    if (failed > 0) newStatus = \"completed_with_failures\";\n                    else newStatus = \"completed\";\n                } else {\n                    newStatus = \"running\";\n                }\n                // persist status if changed\n                if (newStatus !== campaign.status) {\n                    await db.collection(\"campaigns\").updateOne({\n                        _id: campaignObjectId\n                    }, {\n                        $set: {\n                            status: newStatus,\n                            completedAt: newStatus.startsWith(\"completed\") ? new Date() : null\n                        }\n                    });\n                    await safeHSet(redisKey, {\n                        status: newStatus\n                    });\n                }\n                await safePublish(\"campaign:new\", {\n                    id,\n                    action: \"reconcile\",\n                    requeued: enqueuePromises.length,\n                    recovered: staleSending.length,\n                    status: newStatus\n                });\n                return res.status(200).json({\n                    ok: true,\n                    requeued: enqueuePromises.length,\n                    recovered: staleSending.length,\n                    status: newStatus\n                });\n            } catch (e) {\n                console.error(\"Reconcile failed\", e);\n                return res.status(500).json({\n                    error: \"reconcile-failed\"\n                });\n            }\n        }\n        // ACTION: Cancel\n        if (action === \"cancel\") {\n            if (campaign.status === \"cancelled\") {\n                return res.status(200).json({\n                    ok: true,\n                    message: \"Already cancelled\"\n                });\n            }\n            // 1) Mark campaign cancelled and completedAt\n            const completedAt = new Date();\n            await db.collection(\"campaigns\").updateOne({\n                _id: campaignObjectId\n            }, {\n                $set: {\n                    status: \"cancelled\",\n                    completedAt\n                }\n            });\n            await safeHSet(redisKey, {\n                status: \"cancelled\"\n            });\n            // 2) Find and atomically mark pending ledger rows as failed (single updateMany)\n            const filter = {\n                campaignId: campaignObjectId,\n                status: \"pending\"\n            };\n            const update = {\n                $set: {\n                    status: \"failed\",\n                    lastError: \"cancelled\",\n                    lastAttemptAt: completedAt\n                },\n                $inc: {\n                    attempts: 1\n                }\n            };\n            const updateResult = await db.collection(\"campaign_contacts\").updateMany(filter, update);\n            const cancelledCount = updateResult.modifiedCount ?? 0;\n            // 3) Update Redis counters (best-effort)\n            try {\n                if (cancelledCount > 0) {\n                    await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hincrby(redisKey, \"processed\", cancelledCount);\n                    await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hincrby(redisKey, \"failed\", cancelledCount);\n                }\n            } catch (e) {\n                console.warn(\"Failed to update redis counters during cancel\", e);\n            }\n            // 4) Persist totals snapshot to campaigns.totals (read redis if available, fallback to db)\n            let meta = {};\n            try {\n                meta = await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hgetall(redisKey) || {};\n            } catch  {\n                meta = {};\n            }\n            // Compute totals final values combining persisted totals and our cancelledCount as fallback\n            const processedNow = Number(meta[\"processed\"] ?? (campaign.totals?.processed ?? 0) + cancelledCount);\n            const sentNow = Number(meta[\"sent\"] ?? campaign.totals?.sent ?? 0);\n            const failedNow = Number(meta[\"failed\"] ?? (campaign.totals?.failed ?? 0) + cancelledCount);\n            await db.collection(\"campaigns\").updateOne({\n                _id: campaignObjectId\n            }, {\n                $set: {\n                    \"totals.processed\": processedNow,\n                    \"totals.sent\": sentNow,\n                    \"totals.failed\": failedNow,\n                    completedAt\n                }\n            });\n            // 5) Remove queued jobs for this campaign (best-effort)\n            const removedJobs = await removeQueuedJobsForCampaign(id);\n            // 6) Publish event\n            await safePublish(\"campaign:new\", {\n                id,\n                status: \"cancelled\",\n                cancelledCount,\n                removedJobs\n            });\n            return res.status(200).json({\n                ok: true,\n                action: \"cancelled\",\n                cancelledCount,\n                removedJobs\n            });\n        }\n        // ACTION: Delete\n        if (action === \"delete\") {\n            // Require explicit confirmation — safeguards in UI must set confirm=true\n            if (confirm !== true) {\n                return res.status(400).json({\n                    error: \"Deletion requires confirm=true in request body\"\n                });\n            }\n            // Prevent accidental deletion while running\n            if (campaign.status === \"running\") {\n                return res.status(400).json({\n                    error: \"Cancel the campaign before deletion\"\n                });\n            }\n            // Remove queued jobs (best-effort)\n            const removedJobs = await removeQueuedJobsForCampaign(id);\n            // Delete Redis keys (best-effort)\n            try {\n                await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.del(`campaign:${id}:meta`);\n                await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.del(`campaign:${id}:definition`);\n                await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.srem(\"campaign:all\", id);\n            } catch (e) {\n                console.warn(\"Redis cleanup on delete failed\", e);\n            }\n            // Delete Mongo docs\n            const [campaignDel, ledgerDel] = await Promise.all([\n                db.collection(\"campaigns\").deleteOne({\n                    _id: campaignObjectId\n                }),\n                db.collection(\"campaign_contacts\").deleteMany({\n                    campaignId: campaignObjectId\n                })\n            ]);\n            await safePublish(\"campaign:new\", {\n                id,\n                status: \"deleted\"\n            });\n            return res.status(200).json({\n                ok: true,\n                action: \"deleted\",\n                campaignDeleted: campaignDel.deletedCount ?? 0,\n                ledgerDeleted: ledgerDel.deletedCount ?? 0,\n                removedJobs\n            });\n        }\n        // ACTION: Retry all failed contacts that are below MAX_ATTEMPTS\n        if (action === \"retryFailed\") {\n            // Disallow retrying if campaign is cancelled/deleted/paused\n            if (campaign.status === \"cancelled\" || campaign.status === \"deleted\" || campaign.status === \"paused\") {\n                return res.status(400).json({\n                    error: \"Cannot retry contacts for cancelled/deleted/paused campaign\"\n                });\n            }\n            // Ensure a Redis campaign definition exists (worker requires it)\n            const hasDef = await ensureCampaignDefinition(id, campaign);\n            if (!hasDef) {\n                return res.status(500).json({\n                    error: \"Missing campaign definition in Redis and unable to construct one from campaign document. Retry cannot proceed.\"\n                });\n            }\n            // find failed contacts with attempts < MAX_ATTEMPTS AND where bgAttempts >= MAX_ATTEMPTS (meaning background cycle finished)\n            // If bgAttempts is missing (undefined/null), treat it as finished (conservative). But prefer explicit >=.\n            const filter = {\n                campaignId: campaignObjectId,\n                status: \"failed\",\n                attempts: {\n                    $lt: MAX_ATTEMPTS\n                },\n                $or: [\n                    {\n                        bgAttempts: {\n                            $exists: false\n                        }\n                    },\n                    {\n                        bgAttempts: {\n                            $gte: MAX_ATTEMPTS\n                        }\n                    }\n                ]\n            };\n            const failedDocs = await db.collection(\"campaign_contacts\").find(filter, {\n                projection: {\n                    _id: 1,\n                    contactId: 1,\n                    step: 1\n                }\n            }).toArray();\n            const toRetryCount = failedDocs.length;\n            if (toRetryCount === 0) {\n                return res.status(200).json({\n                    ok: true,\n                    retried: 0,\n                    message: \"No eligible failed contacts to retry (either none failed, reached max attempts, or background retries still in progress).\"\n                });\n            }\n            // server-side cap enforcement\n            if (toRetryCount > BATCH_RETRY_LIMIT) {\n                return res.status(400).json({\n                    error: \"Batch retry exceeds server limit\",\n                    message: `Trying to retry ${toRetryCount} contacts exceeds server cap of ${BATCH_RETRY_LIMIT}. Use pagination to retry in smaller batches.`,\n                    toRetryCount,\n                    limit: BATCH_RETRY_LIMIT\n                });\n            }\n            // Atomically mark them pending and increment core `attempts` and reset bgAttempts\n            const ids = failedDocs.map((d)=>d._id);\n            const updateResult = await db.collection(\"campaign_contacts\").updateMany({\n                _id: {\n                    $in: ids\n                }\n            }, {\n                $set: {\n                    status: \"pending\",\n                    lastError: null,\n                    bgAttempts: 0\n                },\n                $inc: {\n                    attempts: 1\n                }\n            });\n            const updated = updateResult.modifiedCount ?? 0;\n            // Enqueue jobs (batch), ensure each job has MQ attempts/backoff set\n            const jobs = [];\n            const CHUNK = 200; // reasonable chunking\n            for(let i = 0; i < failedDocs.length; i += CHUNK){\n                const chunk = failedDocs.slice(i, i + CHUNK);\n                for (const doc of chunk){\n                    const contactObjId = doc.contactId ? doc.contactId : doc._id;\n                    try {\n                        if (doc.step) {\n                            jobs.push(queue.add(\"followup\", {\n                                campaignId: id,\n                                contactId: contactObjId.toString ? contactObjId.toString() : String(contactObjId),\n                                step: doc.step\n                            }, {\n                                removeOnComplete: true,\n                                removeOnFail: true,\n                                attempts: MAX_ATTEMPTS,\n                                backoff: {\n                                    type: \"exponential\",\n                                    delay: 60000\n                                }\n                            }));\n                        } else {\n                            jobs.push(queue.add(\"initial\", {\n                                campaignId: id,\n                                contactId: contactObjId.toString ? contactObjId.toString() : String(contactObjId)\n                            }, {\n                                removeOnComplete: true,\n                                removeOnFail: true,\n                                attempts: MAX_ATTEMPTS,\n                                backoff: {\n                                    type: \"exponential\",\n                                    delay: 60000\n                                }\n                            }));\n                        }\n                    } catch (e) {\n                        console.warn(\"Failed to queue job for retryFailed chunk item\", e);\n                    }\n                }\n            }\n            // Wait for enqueues (best-effort)\n            try {\n                await Promise.all(jobs);\n            } catch (e) {\n                console.warn(\"Some queue.add calls failed during retryFailed\", e);\n            }\n            // Update redis counters: decrease failed by updated (best-effort, but avoid negative)\n            try {\n                const currentFailed = await safeGetMetaInt(redisKey, \"failed\");\n                const dec = Math.min(updated, currentFailed);\n                if (dec > 0) {\n                    await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hincrby(redisKey, \"failed\", -dec);\n                }\n            } catch (e) {\n                console.warn(\"Failed to update redis counters during retryFailed\", e);\n            }\n            // Also correct processed counter because we are moving final failed -> pending (processed should drop)\n            try {\n                const currentProcessed = await safeGetMetaInt(redisKey, \"processed\");\n                const decProc = Math.min(updated, currentProcessed);\n                if (decProc > 0) {\n                    await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hincrby(redisKey, \"processed\", -decProc);\n                }\n            } catch (e) {\n                console.warn(\"Failed to update processed counter during retryFailed\", e);\n            }\n            // Publish contact-level updates for each retried contact (best-effort)\n            try {\n                for (const doc of failedDocs){\n                    const cid = doc.contactId ? doc.contactId.toString ? doc.contactId.toString() : String(doc.contactId) : doc._id.toString ? doc._id.toString() : String(doc._id);\n                    await safePublish(`campaign:${id}:contact_update`, {\n                        contactId: cid,\n                        status: \"pending\",\n                        bgAttempts: 0,\n                        attempts: 1\n                    });\n                }\n            } catch (_) {\n            // ignore publish errors\n            }\n            await safePublish(\"campaign:new\", {\n                id,\n                action: \"retryFailed\",\n                retried: updated\n            });\n            return res.status(200).json({\n                ok: true,\n                retried: updated,\n                attemptedEnqueue: toRetryCount\n            });\n        }\n        // ACTION: Retry a single failed contact by contactId\n        if (action === \"retryContact\") {\n            if (!contactId || typeof contactId !== \"string\") {\n                return res.status(400).json({\n                    error: \"Missing contactId for retryContact\"\n                });\n            }\n            // Disallow retrying if campaign is cancelled/deleted/paused\n            if (campaign.status === \"cancelled\" || campaign.status === \"deleted\" || campaign.status === \"paused\") {\n                return res.status(400).json({\n                    error: \"Cannot retry contacts for cancelled/deleted/paused campaign\"\n                });\n            }\n            // Ensure a Redis campaign definition exists (worker requires it)\n            const hasDef = await ensureCampaignDefinition(id, campaign);\n            if (!hasDef) {\n                return res.status(500).json({\n                    error: \"Missing campaign definition in Redis and unable to construct one from campaign document. Retry cannot proceed.\"\n                });\n            }\n            // Find the ledger row\n            let contactObjId;\n            try {\n                // try parse as ObjectId first\n                contactObjId = new mongodb__WEBPACK_IMPORTED_MODULE_3__.ObjectId(contactId);\n            } catch  {\n                // fallback: use raw string\n                contactObjId = contactId;\n            }\n            const doc = await db.collection(\"campaign_contacts\").findOne({\n                campaignId: campaignObjectId,\n                contactId: contactObjId\n            });\n            if (!doc) {\n                return res.status(404).json({\n                    error: \"Contact ledger row not found for campaign\"\n                });\n            }\n            if (doc.status !== \"failed\") {\n                return res.status(400).json({\n                    error: \"Contact is not in failed state\"\n                });\n            }\n            if ((doc.attempts || 0) >= MAX_ATTEMPTS) {\n                return res.status(400).json({\n                    error: \"Contact has reached max manual attempts and cannot be retried\"\n                });\n            }\n            // Prevent manual retry while BullMQ background retries are still running for this contact\n            // Require bgAttempts >= MAX_ATTEMPTS (or missing) before allowing manual retry\n            const bgDone = typeof doc.bgAttempts === \"number\" ? doc.bgAttempts >= MAX_ATTEMPTS : true;\n            if (!bgDone) {\n                return res.status(400).json({\n                    error: \"Background retries are still in progress for this contact. Please wait until the background retry cycle completes.\"\n                });\n            }\n            // Update single doc to pending, increment core attempts, reset bgAttempts\n            await db.collection(\"campaign_contacts\").updateOne({\n                _id: doc._id\n            }, {\n                $set: {\n                    status: \"pending\",\n                    lastError: null,\n                    bgAttempts: 0\n                },\n                $inc: {\n                    attempts: 1\n                }\n            });\n            // Enqueue appropriate job (use doc.step if present) and ensure MQ attempts/backoff are set\n            try {\n                if (doc.step) {\n                    await queue.add(\"followup\", {\n                        campaignId: id,\n                        contactId: contactObjId.toString ? contactObjId.toString() : String(contactObjId),\n                        step: doc.step\n                    }, {\n                        removeOnComplete: true,\n                        removeOnFail: true,\n                        attempts: MAX_ATTEMPTS,\n                        backoff: {\n                            type: \"exponential\",\n                            delay: 60000\n                        }\n                    });\n                } else {\n                    await queue.add(\"initial\", {\n                        campaignId: id,\n                        contactId: contactObjId.toString ? contactObjId.toString() : String(contactObjId)\n                    }, {\n                        removeOnComplete: true,\n                        removeOnFail: true,\n                        attempts: MAX_ATTEMPTS,\n                        backoff: {\n                            type: \"exponential\",\n                            delay: 60000\n                        }\n                    });\n                }\n            } catch (e) {\n                console.warn(\"Failed to enqueue retry job for contact\", e);\n                // Rollback: try to revert the ledger row changes (best-effort)\n                try {\n                    await db.collection(\"campaign_contacts\").updateOne({\n                        _id: doc._id\n                    }, {\n                        $set: {\n                            status: \"failed\",\n                            lastError: \"enqueue-failed\"\n                        },\n                        $inc: {\n                            attempts: -1\n                        },\n                        $set: {\n                            bgAttempts: doc.bgAttempts ?? 0\n                        }\n                    });\n                } catch (_) {}\n                return res.status(500).json({\n                    error: \"Failed to enqueue retry job\"\n                });\n            }\n            // Update redis counters: decrease failed by 1 if possible (we moved it from failed -> pending)\n            try {\n                const currentFailed = await safeGetMetaInt(redisKey, \"failed\");\n                if (currentFailed > 0) {\n                    await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hincrby(redisKey, \"failed\", -1);\n                }\n            } catch (e) {\n                console.warn(\"Failed to update redis counters during retryContact\", e);\n            }\n            // Also decrement processed so totals align (we are un-finalizing a contact)\n            try {\n                const currentProcessed = await safeGetMetaInt(redisKey, \"processed\");\n                if (currentProcessed > 0) {\n                    await _lib_redis__WEBPACK_IMPORTED_MODULE_1__.redis.hincrby(redisKey, \"processed\", -1);\n                }\n            } catch (e) {\n                console.warn(\"Failed to update processed counter during retryContact\", e);\n            }\n            // Publish contact update\n            try {\n                const cidStr = contactObjId.toString ? contactObjId.toString() : String(contactObjId);\n                await safePublish(`campaign:${id}:contact_update`, {\n                    contactId: cidStr,\n                    status: \"pending\",\n                    attempts: (doc.attempts || 0) + 1,\n                    bgAttempts: 0\n                });\n            } catch (_) {}\n            await safePublish(\"campaign:new\", {\n                id,\n                action: \"retryContact\",\n                contactId\n            });\n            return res.status(200).json({\n                ok: true,\n                retried: 1,\n                contactId\n            });\n        }\n        // Should not reach here\n        return res.status(400).json({\n            error: \"Unsupported action\"\n        });\n    } catch (err) {\n        console.error(\"Campaign control error\", err);\n        return res.status(500).json({\n            error: \"Internal server error\"\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9wYWdlcy9hcGkvY2FtcGFpZ24vW2lkXS9jb250cm9sLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxxQ0FBcUM7QUFFYTtBQUNKO0FBQ2Y7QUFDSTtBQUVuQyxNQUFNSSxRQUFRLElBQUlGLHlDQUFLQSxDQUFDLGFBQWE7SUFBRUcsWUFBWUosNkNBQUtBO0FBQUM7QUFFekQsOENBQThDO0FBQzlDLE1BQU1LLGVBQWVDLE9BQU9DLFFBQVFDLEdBQUcsQ0FBQ0gsWUFBWSxJQUFJO0FBQ3hELGdEQUFnRDtBQUNoRCxNQUFNSSxvQkFBb0JILE9BQU9DLFFBQVFDLEdBQUcsQ0FBQ0MsaUJBQWlCLElBQUk7QUFDbEUsc0VBQXNFO0FBQ3RFLE1BQU1DLHVCQUF1QkosT0FBT0MsUUFBUUMsR0FBRyxDQUFDRSxvQkFBb0IsSUFBSTtBQUN4RSxxRkFBcUY7QUFDckYsTUFBTUMsbUJBQW1CTCxPQUFPQyxRQUFRQyxHQUFHLENBQUNHLGdCQUFnQixJQUFJO0FBY2hFLGVBQWVDLFNBQVNDLEdBQVcsRUFBRUMsR0FBMkI7SUFDOUQsSUFBSTtRQUNGLE1BQU1kLDZDQUFLQSxDQUFDZSxJQUFJLENBQUNGLEtBQUtDO0lBQ3hCLEVBQUUsT0FBT0UsS0FBSztRQUNaQyxRQUFRQyxJQUFJLENBQUMsd0NBQXdDRjtJQUN2RDtBQUNGO0FBRUEsZUFBZUcsWUFBWUMsT0FBZSxFQUFFQyxPQUFZO0lBQ3RELElBQUk7UUFDRixNQUFNckIsNkNBQUtBLENBQUNzQixPQUFPLENBQUNGLFNBQVNHLEtBQUtDLFNBQVMsQ0FBQ0g7SUFDOUMsRUFBRSxPQUFPTCxLQUFLO1FBQ1pDLFFBQVFDLElBQUksQ0FBQyx3QkFBd0JGO0lBQ3ZDO0FBQ0Y7QUFFQSxvRUFBb0U7QUFDcEUsZUFBZVMsNEJBQTRCQyxVQUFrQjtJQUMzRCxJQUFJO1FBQ0Ysa0NBQWtDO1FBQ2xDLE1BQU1DLE9BQU8sTUFBTXhCLE1BQU15QixPQUFPLENBQUM7WUFBQztZQUFXO1lBQVc7WUFBVTtTQUFTLEVBQUUs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UThELEtBQUssQ0FBQywwQkFBMEIvRDtRQUN4QyxPQUFPMkQsSUFBSUUsTUFBTSxDQUFDLEtBQUtDLElBQUksQ0FBQztZQUFFQyxPQUFPO1FBQXdCO0lBQy9EO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJrZXRpbmctbXZwLy4vcGFnZXMvYXBpL2NhbXBhaWduL1tpZF0vY29udHJvbC50cz82NzE2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHBhZ2VzL2FwaS9jYW1wYWlnbi9baWRdL2NvbnRyb2wudHNcclxuaW1wb3J0IHR5cGUgeyBOZXh0QXBpUmVxdWVzdCwgTmV4dEFwaVJlc3BvbnNlIH0gZnJvbSAnbmV4dCc7XHJcbmltcG9ydCBjbGllbnRQcm9taXNlIGZyb20gJy4uLy4uLy4uLy4uL2xpYi9tb25nbyc7XHJcbmltcG9ydCB7IHJlZGlzIH0gZnJvbSAnLi4vLi4vLi4vLi4vbGliL3JlZGlzJztcclxuaW1wb3J0IHsgUXVldWUgfSBmcm9tICdidWxsbXEnO1xyXG5pbXBvcnQgeyBPYmplY3RJZCB9IGZyb20gJ21vbmdvZGInO1xyXG5cclxuY29uc3QgcXVldWUgPSBuZXcgUXVldWUoJ2NhbXBhaWducycsIHsgY29ubmVjdGlvbjogcmVkaXMgfSk7XHJcblxyXG4vLyBrZWVwIHBhcml0eSB3aXRoIHdvcmtlcjsgYWxsb3cgZW52IG92ZXJyaWRlXHJcbmNvbnN0IE1BWF9BVFRFTVBUUyA9IE51bWJlcihwcm9jZXNzLmVudi5NQVhfQVRURU1QVFMgfHwgMyk7XHJcbi8vIHNlcnZlci1zaWRlIGNhcCBmb3IgYmF0Y2ggcmV0cmllcyBwZXIgcmVxdWVzdFxyXG5jb25zdCBCQVRDSF9SRVRSWV9MSU1JVCA9IE51bWJlcihwcm9jZXNzLmVudi5CQVRDSF9SRVRSWV9MSU1JVCB8fCA1MDAwKTtcclxuLy8gd2hlbiByZXN1bWluZywgbGltaXQgaG93IG1hbnkgcGVuZGluZyBqb2JzIHdlJ2xsIHRyeSB0byAocmUpZW5xdWV1ZVxyXG5jb25zdCBSRVNVTUVfRU5RVUVVRV9MSU1JVCA9IE51bWJlcihwcm9jZXNzLmVudi5SRVNVTUVfRU5RVUVVRV9MSU1JVCB8fCA1MDAwKTtcclxuLy8gaG93IGxvbmcgYmVmb3JlIGEgJ3NlbmRpbmcnIHJvdyBpcyBjb25zaWRlcmVkIHN0YWxlIGFuZCBlbGlnaWJsZSBmb3IgcmVjb3ZlcnkgKG1zKVxyXG5jb25zdCBTVEFMRV9TRU5ESU5HX01TID0gTnVtYmVyKHByb2Nlc3MuZW52LlNUQUxFX1NFTkRJTkdfTVMgfHwgOTBfMDAwKTtcclxuXHJcbnR5cGUgQWN0aW9uID1cclxuICB8ICdwYXVzZSdcclxuICB8ICdyZXN1bWUnXHJcbiAgfCAnY2FuY2VsJ1xyXG4gIHwgJ2RlbGV0ZSdcclxuICB8ICdyZXRyeUZhaWxlZCdcclxuICB8ICdyZXRyeUNvbnRhY3QnXHJcbiAgfCAncmVjb25jaWxlJ1xyXG4gIHwgJ292ZXJyaWRlQ3JlYXRlJ1xyXG4gIHwgJ292ZXJyaWRlRGVsZXRlJ1xyXG4gIHwgJ292ZXJyaWRlTGlzdCc7XHJcblxyXG5hc3luYyBmdW5jdGlvbiBzYWZlSFNldChrZXk6IHN0cmluZywgb2JqOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KSB7XHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IHJlZGlzLmhzZXQoa2V5LCBvYmopO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgY29uc29sZS53YXJuKCdSZWRpcyB1bmF2YWlsYWJsZSB3aGlsZSBzZXR0aW5nIG1ldGEnLCBlcnIpO1xyXG4gIH1cclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gc2FmZVB1Ymxpc2goY2hhbm5lbDogc3RyaW5nLCBwYXlsb2FkOiBhbnkpIHtcclxuICB0cnkge1xyXG4gICAgYXdhaXQgcmVkaXMucHVibGlzaChjaGFubmVsLCBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ1JlZGlzIHB1Ymxpc2ggZmFpbGVkJywgZXJyKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIFJlbW92ZSB3YWl0aW5nL2RlbGF5ZWQvYWN0aXZlIGpvYnMgZm9yIGEgY2FtcGFpZ25JZCAoYmVzdC1lZmZvcnQpXHJcbmFzeW5jIGZ1bmN0aW9uIHJlbW92ZVF1ZXVlZEpvYnNGb3JDYW1wYWlnbihjYW1wYWlnbklkOiBzdHJpbmcpIHtcclxuICB0cnkge1xyXG4gICAgLy8gZ2V0IHdhaXRpbmcvZGVsYXllZC9hY3RpdmUgam9ic1xyXG4gICAgY29uc3Qgam9icyA9IGF3YWl0IHF1ZXVlLmdldEpvYnMoWyd3YWl0aW5nJywgJ2RlbGF5ZWQnLCAnYWN0aXZlJywgJ3BhdXNlZCddLCAwLCAtMSk7XHJcblxyXG4gICAgY29uc3QgbWF0Y2hlZCA9IGpvYnMuZmlsdGVyKChqKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIGouZGF0YT8uY2FtcGFpZ25JZCA9PT0gY2FtcGFpZ25JZDtcclxuICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IGogb2YgbWF0Y2hlZCkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIGlmIHRoZSBqb2IgaXMgYWN0aXZlLCByZW1vdmUgbWF5IGZhaWwgLSBzdGlsbCB0cnlcclxuICAgICAgICBhd2FpdCBqLnJlbW92ZSgpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gYmVzdC1lZmZvcnQg4oCUIGlnbm9yZVxyXG4gICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIHJlbW92ZSBqb2IgJHtqLmlkfWAsIGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWF0Y2hlZC5sZW5ndGg7XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBlbnVtZXJhdGUvcmVtb3ZlIGpvYnMgZm9yIGNhbXBhaWduJywgZXJyKTtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxufVxyXG5cclxuLy8gUmVtb3ZlIHF1ZXVlZCBqb2JzIGZvciBhIHNwZWNpZmljIGNvbnRhY3Qgd2l0aGluIGEgY2FtcGFpZ24gKGJlc3QtZWZmb3J0KVxyXG5hc3luYyBmdW5jdGlvbiByZW1vdmVRdWV1ZWRKb2JzRm9yQ2FtcGFpZ25Db250YWN0KGNhbXBhaWduSWQ6IHN0cmluZywgY29udGFjdElkOiBzdHJpbmcpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgam9icyA9IGF3YWl0IHF1ZXVlLmdldEpvYnMoWyd3YWl0aW5nJywgJ2RlbGF5ZWQnLCAnYWN0aXZlJywgJ3BhdXNlZCddLCAwLCAtMSk7XHJcbiAgICBjb25zdCBtYXRjaGVkID0gam9icy5maWx0ZXIoKGopID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gai5kYXRhPy5jYW1wYWlnbklkID09PSBjYW1wYWlnbklkICYmIFN0cmluZyhqLmRhdGE/LmNvbnRhY3RJZCkgPT09IFN0cmluZyhjb250YWN0SWQpO1xyXG4gICAgICB9IGNhdGNoIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGZvciAoY29uc3QgaiBvZiBtYXRjaGVkKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgai5yZW1vdmUoKTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIHJlbW92ZSBqb2IgJHtqLmlkfSBmb3IgY29udGFjdCAke2NvbnRhY3RJZH1gLCBlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1hdGNoZWQubGVuZ3RoO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGVudW1lcmF0ZS9yZW1vdmUgam9icyBmb3IgY2FtcGFpZ24gY29udGFjdCcsIGUpO1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBzYWZlIHJlYWQgb2YgcmVkaXMgbWV0YSBpbnRlZ2VyIGZpZWxkXHJcbmFzeW5jIGZ1bmN0aW9uIHNhZmVHZXRNZXRhSW50KHJlZGlzS2V5OiBzdHJpbmcsIGZpZWxkOiBzdHJpbmcpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgdiA9IGF3YWl0IHJlZGlzLmhnZXQocmVkaXNLZXksIGZpZWxkKTtcclxuICAgIHJldHVybiBOdW1iZXIodiB8fCAwKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbnN1cmUgdGhlcmUgaXMgYSB1c2FibGUgYGNhbXBhaWduOntpZH06ZGVmaW5pdGlvbmAgaW4gUmVkaXMuXHJcbiAqIElmIG1pc3NpbmcsIGF0dGVtcHQgdG8gY29uc3RydWN0IG9uZSBmcm9tIHRoZSBNb25nbyBjYW1wYWlnbiBkb2N1bWVudC5cclxuICogUmV0dXJucyB0cnVlIGlmIGRlZmluaXRpb24gZXhpc3RzIG9yIHdhcyB3cml0dGVuIHN1Y2Nlc3NmdWxseS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGVuc3VyZUNhbXBhaWduRGVmaW5pdGlvbihpZDogc3RyaW5nLCBjYW1wYWlnbkRvYzogYW55KTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgY29uc3Qga2V5ID0gYGNhbXBhaWduOiR7aWR9OmRlZmluaXRpb25gO1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBleGlzdGluZyA9IGF3YWl0IHJlZGlzLmdldChrZXkpO1xyXG4gICAgaWYgKGV4aXN0aW5nKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAvLyBBdHRlbXB0IHRvIGJ1aWxkIGEgbWluaW1hbCBjb21wYXRpYmxlIGRlZmluaXRpb25cclxuICAgIC8vIFdvcmtlciBleHBlY3RzIHsgaW5pdGlhbDogeyBzdWJqZWN0LCBib2R5IH0sIGZvbGxvd1VwczogWy4uLl0gfVxyXG4gICAgbGV0IGJ1aWx0OiBhbnkgPSBudWxsO1xyXG5cclxuICAgIC8vIFByZWZlciBleHBsaWNpdCBzaGFwZXMgY29tbW9ubHkgdXNlZFxyXG4gICAgaWYgKGNhbXBhaWduRG9jPy5kZWZpbml0aW9uICYmIHR5cGVvZiBjYW1wYWlnbkRvYy5kZWZpbml0aW9uID09PSAnb2JqZWN0Jykge1xyXG4gICAgICBidWlsdCA9IGNhbXBhaWduRG9jLmRlZmluaXRpb247XHJcbiAgICB9IGVsc2UgaWYgKGNhbXBhaWduRG9jPy5pbml0aWFsICYmIHR5cGVvZiBjYW1wYWlnbkRvYy5pbml0aWFsID09PSAnb2JqZWN0Jykge1xyXG4gICAgICBidWlsdCA9IHsgaW5pdGlhbDogY2FtcGFpZ25Eb2MuaW5pdGlhbCwgZm9sbG93VXBzOiBjYW1wYWlnbkRvYy5mb2xsb3dVcHMgfHwgW10gfTtcclxuICAgIH0gZWxzZSBpZiAoY2FtcGFpZ25Eb2M/LnRlbXBsYXRlICYmIHR5cGVvZiBjYW1wYWlnbkRvYy50ZW1wbGF0ZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgYnVpbHQgPSB7IGluaXRpYWw6IHsgc3ViamVjdDogY2FtcGFpZ25Eb2MudGVtcGxhdGUuc3ViamVjdCB8fCBjYW1wYWlnbkRvYy5uYW1lLCBib2R5OiBjYW1wYWlnbkRvYy50ZW1wbGF0ZS5ib2R5IHx8IGNhbXBhaWduRG9jLmNvbnRlbnQgfHwgJycgfSwgZm9sbG93VXBzOiBjYW1wYWlnbkRvYy50ZW1wbGF0ZS5mb2xsb3dVcHMgfHwgY2FtcGFpZ25Eb2MuZm9sbG93VXBzIHx8IFtdIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBmYWxsYmFjazogdHJ5IHRvIGdsZWFuIHN1YmplY3QvYm9keSBmcm9tIGNvbW1vbiBmaWVsZHNcclxuICAgICAgY29uc3Qgc3ViamVjdCA9IGNhbXBhaWduRG9jPy5zdWJqZWN0IHx8IGNhbXBhaWduRG9jPy50aXRsZSB8fCBjYW1wYWlnbkRvYz8ubmFtZSB8fCBgQ2FtcGFpZ24gJHtpZH1gO1xyXG4gICAgICBjb25zdCBib2R5ID0gY2FtcGFpZ25Eb2M/LmJvZHkgfHwgY2FtcGFpZ25Eb2M/LmNvbnRlbnQgfHwgY2FtcGFpZ25Eb2M/Lmh0bWwgfHwgJyc7XHJcbiAgICAgIGNvbnN0IGZvbGxvd1VwcyA9IGNhbXBhaWduRG9jPy5mb2xsb3dVcHMgfHwgY2FtcGFpZ25Eb2M/LnN0ZXBzIHx8IFtdO1xyXG4gICAgICBidWlsdCA9IHsgaW5pdGlhbDogeyBzdWJqZWN0LCBib2R5IH0sIGZvbGxvd1VwcyB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIGJ1aWx0IGRvZXNuJ3QgbG9vayByaWdodCAobm8gaW5pdGlhbCBzdWJqZWN0L2JvZHkpLCBmYWlsIHNhZmVcclxuICAgIGlmICghYnVpbHQgfHwgIWJ1aWx0LmluaXRpYWwgfHwgKGJ1aWx0LmluaXRpYWwuc3ViamVjdCA9PSBudWxsICYmIGJ1aWx0LmluaXRpYWwuYm9keSA9PSBudWxsKSkge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byBjb25zdHJ1Y3QgY2FtcGFpZ24gZGVmaW5pdGlvbiBmcm9tIGNhbXBhaWduIGRvY3VtZW50JywgeyBjYW1wYWlnbklkOiBpZCwgc2FtcGxlOiBjYW1wYWlnbkRvYyA/IE9iamVjdC5rZXlzKGNhbXBhaWduRG9jKS5zbGljZSgwLCA4KSA6IG51bGwgfSk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQZXJzaXN0IGludG8gUmVkaXMgKG5vIGV4cGlyeSkgc28gd29ya2VyIGNhbiByZWFkIGl0XHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCByZWRpcy5zZXQoa2V5LCBKU09OLnN0cmluZ2lmeShidWlsdCkpO1xyXG4gICAgICBjb25zb2xlLmxvZyhgV3JvdGUgZmFsbGJhY2sgY2FtcGFpZ24gZGVmaW5pdGlvbiBpbnRvIHJlZGlzIGZvciAke2lkfWApO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gd3JpdGUgY2FtcGFpZ24gZGVmaW5pdGlvbiB0byByZWRpcycsIGUpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgY29uc29sZS53YXJuKCdFcnJvciBjaGVja2luZy93cml0aW5nIGNhbXBhaWduIGRlZmluaXRpb24gaW4gcmVkaXMnLCBlKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYSBzZXQgb2YgY29udGFjdElkIHN0cmluZ3MgZm9yIGpvYnMgY3VycmVudGx5IGVucXVldWVkIGZvciB0aGlzIGNhbXBhaWduLlxyXG4gKiBVc2VkIHRvIGF2b2lkIGVucXVldWluZyBkdXBsaWNhdGVzIHdoZW4gcmVzdW1pbmcuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBnZXRRdWV1ZWRDb250YWN0SWRzRm9yQ2FtcGFpZ24oY2FtcGFpZ25JZDogc3RyaW5nKTogUHJvbWlzZTxTZXQ8c3RyaW5nPj4ge1xyXG4gIGNvbnN0IHNldCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBqb2JzID0gYXdhaXQgcXVldWUuZ2V0Sm9icyhbJ3dhaXRpbmcnLCAnZGVsYXllZCcsICdhY3RpdmUnLCAncGF1c2VkJ10sIDAsIC0xKTtcclxuICAgIGZvciAoY29uc3QgaiBvZiBqb2JzKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKGouZGF0YT8uY2FtcGFpZ25JZCA9PT0gY2FtcGFpZ25JZCAmJiBqLmRhdGE/LmNvbnRhY3RJZCkge1xyXG4gICAgICAgICAgc2V0LmFkZChTdHJpbmcoai5kYXRhLmNvbnRhY3RJZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgLy8gaWdub3JlIG1hbGZvcm1lZCBqb2JzXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBsaXN0IHF1ZXVlZCBqb2JzIGZvciBjYW1wYWlnbiB3aGVuIGNoZWNraW5nIGR1cGxpY2F0ZXMnLCBlKTtcclxuICB9XHJcbiAgcmV0dXJuIHNldDtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJ5UGFyc2VPYmplY3RJZChzOiBhbnkpIHtcclxuICBpZiAoIXMpIHJldHVybiBudWxsO1xyXG4gIGlmICh0eXBlb2YgcyA9PT0gJ29iamVjdCcgJiYgcyBpbnN0YW5jZW9mIE9iamVjdElkKSByZXR1cm4gcztcclxuICBpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnICYmIC9eWzAtOWEtZkEtRl17MjR9JC8udGVzdChzKSkge1xyXG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBPYmplY3RJZChzKTsgfSBjYXRjaCB7IHJldHVybiBudWxsOyB9XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKFxyXG4gIHJlcTogTmV4dEFwaVJlcXVlc3QsXHJcbiAgcmVzOiBOZXh0QXBpUmVzcG9uc2VcclxuKSB7XHJcbiAgaWYgKHJlcS5tZXRob2QgIT09ICdQT1NUJykge1xyXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA1KS5qc29uKHsgZXJyb3I6ICdNZXRob2Qgbm90IGFsbG93ZWQnIH0pO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgeyBpZCB9ID0gcmVxLnF1ZXJ5O1xyXG4gIGlmICghaWQgfHwgdHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgZXJyb3I6ICdJbnZhbGlkIGNhbXBhaWduIGlkJyB9KTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHsgYWN0aW9uLCBjb25maXJtLCBjb250YWN0SWQsIGVtYWlsLCByZWFzb24sIGJ5IH0gPSByZXEuYm9keSBhcyB7XHJcbiAgICBhY3Rpb24/OiBBY3Rpb247XHJcbiAgICBjb25maXJtPzogYm9vbGVhbjtcclxuICAgIGNvbnRhY3RJZD86IHN0cmluZztcclxuICAgIGVtYWlsPzogc3RyaW5nO1xyXG4gICAgcmVhc29uPzogc3RyaW5nO1xyXG4gICAgYnk/OiBzdHJpbmc7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgYWxsb3dlZEFjdGlvbnMgPSBbJ3BhdXNlJywgJ3Jlc3VtZScsICdjYW5jZWwnLCAnZGVsZXRlJywgJ3JldHJ5RmFpbGVkJywgJ3JldHJ5Q29udGFjdCcsICdyZWNvbmNpbGUnLCAnb3ZlcnJpZGVDcmVhdGUnLCAnb3ZlcnJpZGVEZWxldGUnLCAnb3ZlcnJpZGVMaXN0J107XHJcbiAgaWYgKCFhY3Rpb24gfHwgIWFsbG93ZWRBY3Rpb25zLmluY2x1ZGVzKGFjdGlvbikpIHtcclxuICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IGVycm9yOiAnSW52YWxpZCBhY3Rpb24nIH0pO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgY2xpZW50ID0gYXdhaXQgY2xpZW50UHJvbWlzZTtcclxuICBjb25zdCBkYiA9IGNsaWVudC5kYignUGxhdGZvcm1EYXRhJyk7XHJcbiAgbGV0IGNhbXBhaWduT2JqZWN0SWQ6IE9iamVjdElkIHwgbnVsbCA9IG51bGw7XHJcbiAgdHJ5IHtcclxuICAgIGNhbXBhaWduT2JqZWN0SWQgPSBuZXcgT2JqZWN0SWQoaWQpO1xyXG4gIH0gY2F0Y2gge1xyXG4gICAgLy8gaWYgaWQgaXNuJ3QgYSB2YWxpZCBPYmplY3RJZCwga2VlcCBudWxsIGFuZCB1c2Ugc3RyaW5nIG1hdGNoIGZhbGxiYWNrXHJcbiAgICBjYW1wYWlnbk9iamVjdElkID0gbnVsbDtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICAvLyBSZWxvYWQgY2FtcGFpZ24gZnJvbSBNb25nbyAoYXV0aG9yaXRhdGl2ZSkgdW5sZXNzIGFjdGlvbiBpcyBvdmVycmlkZUxpc3QgKGxpc3Rpbmcgb3ZlcnJpZGVzIGNhbiBzdGlsbCBwcm9jZWVkKVxyXG4gICAgY29uc3QgY2FtcGFpZ24gPSBjYW1wYWlnbk9iamVjdElkID8gYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25zJykuZmluZE9uZSh7IF9pZDogY2FtcGFpZ25PYmplY3RJZCB9KSA6IGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWducycpLmZpbmRPbmUoeyBfaWQ6IGlkIH0pO1xyXG5cclxuICAgIGlmICghY2FtcGFpZ24gJiYgYWN0aW9uICE9PSAnb3ZlcnJpZGVMaXN0Jykge1xyXG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDQpLmpzb24oeyBlcnJvcjogJ0NhbXBhaWduIG5vdCBmb3VuZCcgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTGlnaHR3ZWlnaHQgaGVscGVyc1xyXG4gICAgY29uc3QgcmVkaXNLZXkgPSBgY2FtcGFpZ246JHtpZH06bWV0YWA7XHJcblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBNYW51YWwgb3ZlcnJpZGUgYWN0aW9uc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBDcmVhdGUgYSBtYW51YWwgb3ZlcnJpZGU6IHBlcnNpc3QgZG9jLCBtYXJrIGxlZGdlciByb3cocyksIHJlbW92ZSBxdWV1ZWQgam9icyBmb3IgdGhhdCBjb250YWN0XHJcbiAgICBpZiAoYWN0aW9uID09PSAnb3ZlcnJpZGVDcmVhdGUnKSB7XHJcbiAgICAgIGlmICghY29udGFjdElkICYmICFlbWFpbCkge1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IGVycm9yOiAnY29udGFjdElkIG9yIGVtYWlsIHJlcXVpcmVkIGZvciBvdmVycmlkZUNyZWF0ZScgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcclxuICAgICAgY29uc3QgY2FtcGFpZ25JZFN0b3JlID0gY2FtcGFpZ25PYmplY3RJZCA/PyBpZDtcclxuXHJcbiAgICAgIGNvbnN0IGluc2VydERvYzogYW55ID0ge1xyXG4gICAgICAgIGNhbXBhaWduSWQ6IGNhbXBhaWduSWRTdG9yZSxcclxuICAgICAgICBjb250YWN0SWQ6IGNvbnRhY3RJZCA/PyBudWxsLFxyXG4gICAgICAgIGVtYWlsOiBlbWFpbCA/PyBudWxsLFxyXG4gICAgICAgIHJlYXNvbjogcmVhc29uID8/ICdtYW51YWxfb3ZlcnJpZGUnLFxyXG4gICAgICAgIGJ5OiBieSA/PyBudWxsLFxyXG4gICAgICAgIGF0OiBub3csXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBQZXJzaXN0IG92ZXJyaWRlIGRvY1xyXG4gICAgICBjb25zdCBpbnNlcnRSZXMgPSBhd2FpdCBkYi5jb2xsZWN0aW9uKCdjYW1wYWlnbl9vdmVycmlkZXMnKS5pbnNlcnRPbmUoaW5zZXJ0RG9jKTtcclxuXHJcbiAgICAgIC8vIEJ1aWxkIGNvbnRhY3QgZmlsdGVycyAoc3VwcG9ydCBvYmplY3RJZC9zdHJpbmcvZW1haWwvX2lkKVxyXG4gICAgICBjb25zdCBjb250YWN0RmlsdGVyczogYW55W10gPSBbXTtcclxuICAgICAgaWYgKGNvbnRhY3RJZCkge1xyXG4gICAgICAgIGNvbnN0IG1heWJlT2JqID0gdHJ5UGFyc2VPYmplY3RJZChjb250YWN0SWQpO1xyXG4gICAgICAgIGlmIChtYXliZU9iaikgY29udGFjdEZpbHRlcnMucHVzaCh7IGNvbnRhY3RJZDogbWF5YmVPYmogfSk7XHJcbiAgICAgICAgY29udGFjdEZpbHRlcnMucHVzaCh7IGNvbnRhY3RJZDogU3RyaW5nKGNvbnRhY3RJZCkgfSk7XHJcbiAgICAgICAgLy8gc3VwcG9ydCBsZWRnZXIgX2lkIGlmIHByb3ZpZGVkXHJcbiAgICAgICAgaWYgKC9eWzAtOWEtZkEtRl17MjR9JC8udGVzdChTdHJpbmcoY29udGFjdElkKSkpIHtcclxuICAgICAgICAgIHRyeSB7IGNvbnRhY3RGaWx0ZXJzLnB1c2goeyBfaWQ6IG5ldyBPYmplY3RJZChTdHJpbmcoY29udGFjdElkKSkgfSk7IH0gY2F0Y2gge31cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGVtYWlsKSB7XHJcbiAgICAgICAgY29udGFjdEZpbHRlcnMucHVzaCh7IGVtYWlsOiBTdHJpbmcoZW1haWwpIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY29udGFjdEZpbHRlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIC8vIE1hcmsgbWF0Y2hpbmcgY2FtcGFpZ25fY29udGFjdHMgcm93cyBhcyBtYW51YWxseSBvdmVycmlkZGVuXHJcbiAgICAgICAgY29uc3QgdXBkYXRlRmlsdGVyOiBhbnkgPSBjYW1wYWlnbk9iamVjdElkID8geyAkYW5kOiBbeyAkb3I6IFt7IGNhbXBhaWduSWQ6IGNhbXBhaWduT2JqZWN0SWQgfSwgeyBjYW1wYWlnbklkOiBpZCB9XSB9LCB7ICRvcjogY29udGFjdEZpbHRlcnMgfV0gfSA6IHsgJGFuZDogW3sgY2FtcGFpZ25JZDogaWQgfSwgeyAkb3I6IGNvbnRhY3RGaWx0ZXJzIH1dIH07XHJcbiAgICAgICAgYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25fY29udGFjdHMnKS51cGRhdGVNYW55KFxyXG4gICAgICAgICAgdXBkYXRlRmlsdGVyLFxyXG4gICAgICAgICAgeyAkc2V0OiB7IG1hbnVhbGx5T3ZlcnJpZGRlbjogdHJ1ZSwgc3RhdHVzOiAnb3ZlcnJpZGRlbicsIG92ZXJyaWRlQXQ6IG5vdywgb3ZlcnJpZGVSZWFzb246IGluc2VydERvYy5yZWFzb24sIG92ZXJyaWRlQnk6IGluc2VydERvYy5ieSB9IH1cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmUgcXVldWVkIGpvYnMgZm9yIHRoYXQgY29udGFjdCAoYmVzdC1lZmZvcnQpXHJcbiAgICAgIGxldCByZW1vdmVkSm9icyA9IDA7XHJcbiAgICAgIGlmIChjb250YWN0SWQpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgcmVtb3ZlZEpvYnMgPSBhd2FpdCByZW1vdmVRdWV1ZWRKb2JzRm9yQ2FtcGFpZ25Db250YWN0KGlkLCBjb250YWN0SWQpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHJlbW92ZSBxdWV1ZWQgam9icyBmb3Igb3ZlcnJpZGRlbiBjb250YWN0JywgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBQdWJsaXNoIGNvbnRhY3QgdXBkYXRlIGFuZCBjYW1wYWlnbi1sZXZlbCBldmVudFxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmIChjb250YWN0SWQpIHtcclxuICAgICAgICAgIGF3YWl0IHNhZmVQdWJsaXNoKGBjYW1wYWlnbjoke2lkfTpjb250YWN0X3VwZGF0ZWAsIHsgY29udGFjdElkOiBTdHJpbmcoY29udGFjdElkKSwgc3RhdHVzOiAnb3ZlcnJpZGRlbicsIG1hbnVhbGx5T3ZlcnJpZGRlbjogdHJ1ZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKF8pIHsgfVxyXG5cclxuICAgICAgYXdhaXQgc2FmZVB1Ymxpc2goJ2NhbXBhaWduOm5ldycsIHsgaWQsIGFjdGlvbjogJ292ZXJyaWRlQ3JlYXRlJywgb3ZlcnJpZGVJZDogaW5zZXJ0UmVzLmluc2VydGVkSWQ/LnRvU3RyaW5nPy4oKSwgY29udGFjdElkOiBjb250YWN0SWQgPz8gbnVsbCwgZW1haWw6IGVtYWlsID8/IG51bGwsIHJlbW92ZWRKb2JzIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHsgb2s6IHRydWUsIG92ZXJyaWRlOiB7IC4uLmluc2VydERvYywgX2lkOiBpbnNlcnRSZXMuaW5zZXJ0ZWRJZCB9LCByZW1vdmVkSm9icyB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZWxldGUvdW5kbyBvdmVycmlkZTogcmVtb3ZlIG92ZXJyaWRlIGRvY3MsIHVuc2V0IGxlZGdlciBmbGFnIGFuZCBvcHRpb25hbGx5IHJlc3RvcmUgc3RhdHVzXHJcbiAgICBpZiAoYWN0aW9uID09PSAnb3ZlcnJpZGVEZWxldGUnKSB7XHJcbiAgICAgIGlmICghY29udGFjdElkICYmICFlbWFpbCkge1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IGVycm9yOiAnY29udGFjdElkIG9yIGVtYWlsIHJlcXVpcmVkIGZvciBvdmVycmlkZURlbGV0ZScgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGNhbXBhaWduSWRTdG9yZSA9IGNhbXBhaWduT2JqZWN0SWQgPz8gaWQ7XHJcbiAgICAgIGNvbnN0IHF1ZXJ5OiBhbnkgPSB7IGNhbXBhaWduSWQ6IGNhbXBhaWduSWRTdG9yZSwgJG9yOiBbXSBhcyBhbnlbXSB9O1xyXG5cclxuICAgICAgaWYgKGNvbnRhY3RJZCkge1xyXG4gICAgICAgIHF1ZXJ5LiRvci5wdXNoKHsgY29udGFjdElkOiBjb250YWN0SWQgfSk7XHJcbiAgICAgICAgY29uc3QgbWF5YmVPYmogPSB0cnlQYXJzZU9iamVjdElkKGNvbnRhY3RJZCk7XHJcbiAgICAgICAgaWYgKG1heWJlT2JqKSBxdWVyeS4kb3IucHVzaCh7IGNvbnRhY3RJZDogbWF5YmVPYmogfSk7XHJcbiAgICAgICAgaWYgKC9eWzAtOWEtZkEtRl17MjR9JC8udGVzdChTdHJpbmcoY29udGFjdElkKSkpIHtcclxuICAgICAgICAgIHRyeSB7IHF1ZXJ5LiRvci5wdXNoKHsgX2lkOiBuZXcgT2JqZWN0SWQoU3RyaW5nKGNvbnRhY3RJZCkpIH0pOyB9IGNhdGNoIHt9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChlbWFpbCkgcXVlcnkuJG9yLnB1c2goeyBlbWFpbDogU3RyaW5nKGVtYWlsKSB9KTtcclxuXHJcbiAgICAgIGlmIChxdWVyeS4kb3IubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgZXJyb3I6ICdubyB2YWxpZCBpZGVudGlmaWVyIHByb3ZpZGVkJyB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZGVsUmVzID0gYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25fb3ZlcnJpZGVzJykuZGVsZXRlTWFueShxdWVyeSk7XHJcblxyXG4gICAgICAvLyBVbnNldCBtYW51YWxseU92ZXJyaWRkZW4gZmxhZyBvbiBsZWRnZXIgcm93cyBhbmQgY2xlYXIgb3ZlcnJpZGUgbWV0YWRhdGFcclxuICAgICAgY29uc3QgY29udGFjdEZpbHRlcnM6IGFueVtdID0gW107XHJcbiAgICAgIGlmIChjb250YWN0SWQpIHtcclxuICAgICAgICBjb25zdCBtYXliZU9iaiA9IHRyeVBhcnNlT2JqZWN0SWQoY29udGFjdElkKTtcclxuICAgICAgICBpZiAobWF5YmVPYmopIGNvbnRhY3RGaWx0ZXJzLnB1c2goeyBjb250YWN0SWQ6IG1heWJlT2JqIH0pO1xyXG4gICAgICAgIGNvbnRhY3RGaWx0ZXJzLnB1c2goeyBjb250YWN0SWQ6IFN0cmluZyhjb250YWN0SWQpIH0pO1xyXG4gICAgICAgIGlmICgvXlswLTlhLWZBLUZdezI0fSQvLnRlc3QoU3RyaW5nKGNvbnRhY3RJZCkpKSB7XHJcbiAgICAgICAgICB0cnkgeyBjb250YWN0RmlsdGVycy5wdXNoKHsgX2lkOiBuZXcgT2JqZWN0SWQoU3RyaW5nKGNvbnRhY3RJZCkpIH0pOyB9IGNhdGNoIHt9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChlbWFpbCkgY29udGFjdEZpbHRlcnMucHVzaCh7IGVtYWlsOiBTdHJpbmcoZW1haWwpIH0pO1xyXG5cclxuICAgICAgaWYgKGNvbnRhY3RGaWx0ZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zdCB1cGRhdGVGaWx0ZXI6IGFueSA9IGNhbXBhaWduT2JqZWN0SWQgPyB7ICRhbmQ6IFt7ICRvcjogW3sgY2FtcGFpZ25JZDogY2FtcGFpZ25PYmplY3RJZCB9LCB7IGNhbXBhaWduSWQ6IGlkIH1dIH0sIHsgJG9yOiBjb250YWN0RmlsdGVycyB9XSB9IDogeyAkYW5kOiBbeyBjYW1wYWlnbklkOiBpZCB9LCB7ICRvcjogY29udGFjdEZpbHRlcnMgfV0gfTtcclxuXHJcbiAgICAgICAgLy8gVW5zZXQgZmxhZ3MgYW5kIG1ldGFkYXRhXHJcbiAgICAgICAgYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25fY29udGFjdHMnKS51cGRhdGVNYW55KFxyXG4gICAgICAgICAgdXBkYXRlRmlsdGVyLFxyXG4gICAgICAgICAgeyAkc2V0OiB7IG1hbnVhbGx5T3ZlcnJpZGRlbjogZmFsc2UgfSwgJHVuc2V0OiB7IG92ZXJyaWRlQXQ6IFwiXCIsIG92ZXJyaWRlUmVhc29uOiBcIlwiLCBvdmVycmlkZUJ5OiBcIlwiIH0gfSBhcyBhbnlcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBJZiBhIGxlZGdlciByb3cgY3VycmVudGx5IGhhcyBzdGF0dXMgJ292ZXJyaWRkZW4nIHJlc3RvcmUgaXQgdG8gJ3BlbmRpbmcnIHNvIGNhbXBhaWduIGNvbnRpbnVlcyBmb3IgdGhhdCBjb250YWN0LlxyXG4gICAgICAgIGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWduX2NvbnRhY3RzJykudXBkYXRlTWFueShcclxuICAgICAgICAgIHsgJGFuZDogWyB1cGRhdGVGaWx0ZXIsIHsgc3RhdHVzOiAnb3ZlcnJpZGRlbicgfSBdIH0sXHJcbiAgICAgICAgICB7ICRzZXQ6IHsgc3RhdHVzOiAncGVuZGluZycsIGxhc3RFcnJvcjogbnVsbCwgYmdBdHRlbXB0czogMCB9IH1cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBQdWJsaXNoIGNhbXBhaWduIGV2ZW50IHNvIFVJIHJlZnJlc2hlc1xyXG4gICAgICBhd2FpdCBzYWZlUHVibGlzaCgnY2FtcGFpZ246bmV3JywgeyBpZCwgYWN0aW9uOiAnb3ZlcnJpZGVEZWxldGUnLCByZW1vdmVkOiBkZWxSZXMuZGVsZXRlZENvdW50IHx8IDAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oeyBvazogdHJ1ZSwgcmVtb3ZlZDogZGVsUmVzLmRlbGV0ZWRDb3VudCA/PyAwIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIExpc3Qgb3ZlcnJpZGVzIGZvciBhIGNhbXBhaWduXHJcbiAgICBpZiAoYWN0aW9uID09PSAnb3ZlcnJpZGVMaXN0Jykge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGNhbXBhaWduSWRTdG9yZSA9IGNhbXBhaWduT2JqZWN0SWQgPz8gaWQ7XHJcbiAgICAgICAgY29uc3QgaXRlbXMgPSBhd2FpdCBkYi5jb2xsZWN0aW9uKCdjYW1wYWlnbl9vdmVycmlkZXMnKS5maW5kKHsgY2FtcGFpZ25JZDogY2FtcGFpZ25JZFN0b3JlIH0pLnNvcnQoeyBhdDogLTEgfSkudG9BcnJheSgpO1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7IG9rOiB0cnVlLCBpdGVtcyB9KTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsaXN0IG92ZXJyaWRlcycsIGUpO1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7IGVycm9yOiAnb3ZlcnJpZGVzLWxpc3QtZmFpbGVkJyB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gRXhpc3RpbmcgYWN0aW9ucyAodW5jaGFuZ2VkKVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgLy8gQUNUSU9OOiBQYXVzZVxyXG4gICAgaWYgKGFjdGlvbiA9PT0gJ3BhdXNlJykge1xyXG4gICAgICBpZiAoY2FtcGFpZ24uc3RhdHVzID09PSAncGF1c2VkJykge1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7IG9rOiB0cnVlLCBtZXNzYWdlOiAnQWxyZWFkeSBwYXVzZWQnIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWducycpLnVwZGF0ZU9uZShcclxuICAgICAgICB7IF9pZDogY2FtcGFpZ25PYmplY3RJZCB9LFxyXG4gICAgICAgIHsgJHNldDogeyBzdGF0dXM6ICdwYXVzZWQnIH0gfVxyXG4gICAgICApO1xyXG4gICAgICBhd2FpdCBzYWZlSFNldChyZWRpc0tleSwgeyBzdGF0dXM6ICdwYXVzZWQnIH0pO1xyXG4gICAgICAvLyBwdWJsaXNoIGNhbXBhaWduLWxldmVsIGV2ZW50IHNvIFVJIGRpc2FibGVzIHJldHJ5IGJ1dHRvbnMgYW5kIHVwZGF0ZXMgc3RhdGVcclxuICAgICAgYXdhaXQgc2FmZVB1Ymxpc2goJ2NhbXBhaWduOm5ldycsIHsgaWQsIHN0YXR1czogJ3BhdXNlZCcgfSk7XHJcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7IG9rOiB0cnVlLCBhY3Rpb246ICdwYXVzZWQnIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFDVElPTjogUmVzdW1lXHJcbiAgICBpZiAoYWN0aW9uID09PSAncmVzdW1lJykge1xyXG4gICAgICBpZiAoY2FtcGFpZ24uc3RhdHVzID09PSAncnVubmluZycpIHtcclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oeyBvazogdHJ1ZSwgbWVzc2FnZTogJ0FscmVhZHkgcnVubmluZycgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHNldCBydW5uaW5nIGluIERCICsgcmVkaXNcclxuICAgICAgYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25zJykudXBkYXRlT25lKFxyXG4gICAgICAgIHsgX2lkOiBjYW1wYWlnbk9iamVjdElkIH0sXHJcbiAgICAgICAgeyAkc2V0OiB7IHN0YXR1czogJ3J1bm5pbmcnIH0gfVxyXG4gICAgICApO1xyXG4gICAgICBhd2FpdCBzYWZlSFNldChyZWRpc0tleSwgeyBzdGF0dXM6ICdydW5uaW5nJyB9KTtcclxuICAgICAgYXdhaXQgc2FmZVB1Ymxpc2goJ2NhbXBhaWduOm5ldycsIHsgaWQsIHN0YXR1czogJ3J1bm5pbmcnIH0pO1xyXG5cclxuICAgICAgLy8gUmUtZW5xdWV1ZSBwZW5kaW5nIGNvbnRhY3RzIHRoYXQgY3VycmVudGx5IGhhdmUgbm8gcXVldWVkIGpvYiBmb3IgdGhpcyBjYW1wYWlnbi5cclxuICAgICAgLy8gVGhpcyBhZGRyZXNzZXMgY2FzZXMgd2hlcmUgam9icyB3ZXJlIHJlbW92ZWQgb3Igbm90IGVucXVldWVkIHdoaWxlIHRoZSBjYW1wYWlnbiB3YXMgcGF1c2VkLFxyXG4gICAgICAvLyBlbnN1cmluZyBwZW5kaW5nIHJvd3MgYWN0dWFsbHkgZ2V0IHByb2Nlc3NlZCBhZ2FpbiBhZnRlciByZXN1bWUuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcXVldWVkU2V0ID0gYXdhaXQgZ2V0UXVldWVkQ29udGFjdElkc0ZvckNhbXBhaWduKGlkKTtcclxuXHJcbiAgICAgICAgLy8gZmV0Y2ggcGVuZGluZyBkb2NzIChsaW1pdCB0byBhIHNhbmUgY2FwKVxyXG4gICAgICAgIGNvbnN0IHBlbmRpbmdDdXJzb3IgPSBkYi5jb2xsZWN0aW9uKCdjYW1wYWlnbl9jb250YWN0cycpLmZpbmQoXHJcbiAgICAgICAgICB7IGNhbXBhaWduSWQ6IGNhbXBhaWduT2JqZWN0SWQsIHN0YXR1czogJ3BlbmRpbmcnIH0sXHJcbiAgICAgICAgICB7IHByb2plY3Rpb246IHsgX2lkOiAxLCBjb250YWN0SWQ6IDEsIHN0ZXA6IDEgfSB9XHJcbiAgICAgICAgKS5saW1pdChSRVNVTUVfRU5RVUVVRV9MSU1JVCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHBlbmRpbmc6IGFueVtdID0gYXdhaXQgcGVuZGluZ0N1cnNvci50b0FycmF5KCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGVucXVldWVQcm9taXNlczogUHJvbWlzZTxhbnk+W10gPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGQgb2YgcGVuZGluZykge1xyXG4gICAgICAgICAgY29uc3QgY2lkID0gZC5jb250YWN0SWQgPyAoZC5jb250YWN0SWQudG9TdHJpbmcgPyBkLmNvbnRhY3RJZC50b1N0cmluZygpIDogU3RyaW5nKGQuY29udGFjdElkKSkgOiAoZC5faWQudG9TdHJpbmcgPyBkLl9pZC50b1N0cmluZygpIDogU3RyaW5nKGQuX2lkKSk7XHJcbiAgICAgICAgICBpZiAocXVldWVkU2V0LmhhcyhjaWQpKSBjb250aW51ZTsgLy8gYWxyZWFkeSBxdWV1ZWRcclxuXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBlbnF1ZXVlUHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICBxdWV1ZS5hZGQoXHJcbiAgICAgICAgICAgICAgICBkLnN0ZXAgPyAnZm9sbG93dXAnIDogJ2luaXRpYWwnLFxyXG4gICAgICAgICAgICAgICAgeyBjYW1wYWlnbklkOiBpZCwgY29udGFjdElkOiBjaWQsIHN0ZXA6IGQuc3RlcCB9LFxyXG4gICAgICAgICAgICAgICAgeyByZW1vdmVPbkNvbXBsZXRlOiB0cnVlLCByZW1vdmVPbkZhaWw6IHRydWUsIGF0dGVtcHRzOiBNQVhfQVRURU1QVFMsIGJhY2tvZmY6IHsgdHlwZTogJ2V4cG9uZW50aWFsJywgZGVsYXk6IDYwXzAwMCB9IH1cclxuICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGVucXVldWUgcGVuZGluZyBjb250YWN0IG9uIHJlc3VtZScsIGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYXR0ZW1wdCB0byBlbnF1ZXVlIGluIHBhcmFsbGVsIChiZXN0LWVmZm9ydClcclxuICAgICAgICBpZiAoZW5xdWV1ZVByb21pc2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChlbnF1ZXVlUHJvbWlzZXMpO1xyXG4gICAgICAgICAgLy8gbm90aWZ5IFVJIHRoYXQgY29udGFjdHMgaGF2ZSBiZWVuIHJlLXF1ZXVlZCAoY291bnRzIHVuY2hhbmdlZCwgYnV0IFVJIG1heSB3YW50IHRvIHJlZnJlc2gpXHJcbiAgICAgICAgICBhd2FpdCBzYWZlUHVibGlzaCgnY2FtcGFpZ246bmV3JywgeyBpZCwgYWN0aW9uOiAncmVzdW1lX3JlcXVldWVkJywgcmVxdWV1ZWQ6IGVucXVldWVQcm9taXNlcy5sZW5ndGggfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcmUtZW5xdWV1ZSBwZW5kaW5nIGNvbnRhY3RzIG9uIHJlc3VtZScsIGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZWNvdmVyIHN0YWxlICdzZW5kaW5nJyBsZWRnZXIgcm93cyB0aGF0IG1heSBoYXZlIGJlZW4gbGVmdCBpbiAnc2VuZGluZycgYnkgYSBjcmFzaGVkIHdvcmtlciBvciBraWxsZWQgcHJvY2Vzcy5cclxuICAgICAgLy8gQ3JpdGVyaWE6IHN0YXR1cyA9PT0gJ3NlbmRpbmcnIEFORCBsYXN0QXR0ZW1wdEF0IG9sZGVyIHRoYW4gU1RBTEVfU0VORElOR19NUyBBTkQgYmdBdHRlbXB0cyA8IE1BWF9BVFRFTVBUU1xyXG4gICAgICAvLyBXZSdsbCBzZXQgdGhlbSBiYWNrIHRvICdwZW5kaW5nJywgcmVzZXQgYmdBdHRlbXB0cyB0byAwIChzbyBiYWNrZ3JvdW5kIGN5Y2xlIHJlc3RhcnRzKSwgYW5kIGVucXVldWUgam9icy5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBjdXRvZmYgPSBuZXcgRGF0ZShEYXRlLm5vdygpIC0gU1RBTEVfU0VORElOR19NUyk7XHJcbiAgICAgICAgY29uc3Qgc3RhbGVDdXJzb3IgPSBkYi5jb2xsZWN0aW9uKCdjYW1wYWlnbl9jb250YWN0cycpLmZpbmQoXHJcbiAgICAgICAgICB7IGNhbXBhaWduSWQ6IGNhbXBhaWduT2JqZWN0SWQsIHN0YXR1czogJ3NlbmRpbmcnLCBsYXN0QXR0ZW1wdEF0OiB7ICRsdDogY3V0b2ZmIH0gfSxcclxuICAgICAgICAgIHsgcHJvamVjdGlvbjogeyBfaWQ6IDEsIGNvbnRhY3RJZDogMSwgc3RlcDogMSwgYmdBdHRlbXB0czogMSB9IH1cclxuICAgICAgICApLmxpbWl0KFJFU1VNRV9FTlFVRVVFX0xJTUlUKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc3RhbGVEb2NzID0gYXdhaXQgc3RhbGVDdXJzb3IudG9BcnJheSgpO1xyXG4gICAgICAgIGlmIChzdGFsZURvY3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgY29uc3QgaWRzID0gc3RhbGVEb2NzLm1hcChkID0+IGQuX2lkKTtcclxuICAgICAgICAgIC8vIFJlc2V0IHRvIHBlbmRpbmcgYW5kIGNsZWFyIGxhc3RFcnJvciwgcmVzZXQgYmdBdHRlbXB0cyBzbyBiYWNrZ3JvdW5kIHJldHJpZXMgc3RhcnQgZnJlc2hcclxuICAgICAgICAgIGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWduX2NvbnRhY3RzJykudXBkYXRlTWFueShcclxuICAgICAgICAgICAgeyBfaWQ6IHsgJGluOiBpZHMgfSB9LFxyXG4gICAgICAgICAgICB7ICRzZXQ6IHsgc3RhdHVzOiAncGVuZGluZycsIGxhc3RFcnJvcjogbnVsbCwgYmdBdHRlbXB0czogMCB9IH1cclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgLy8gRW5xdWV1ZSBlYWNoIHN0YWxlIGRvYyBpZiBub3QgYWxyZWFkeSBxdWV1ZWRcclxuICAgICAgICAgIGNvbnN0IHF1ZXVlZFNldDIgPSBhd2FpdCBnZXRRdWV1ZWRDb250YWN0SWRzRm9yQ2FtcGFpZ24oaWQpO1xyXG4gICAgICAgICAgY29uc3QgcmVxdWV1ZVByb21pc2VzOiBQcm9taXNlPGFueT5bXSA9IFtdO1xyXG4gICAgICAgICAgZm9yIChjb25zdCBkIG9mIHN0YWxlRG9jcykge1xyXG4gICAgICAgICAgICBjb25zdCBjaWQgPSBkLmNvbnRhY3RJZCA/IChkLmNvbnRhY3RJZC50b1N0cmluZyA/IGQuY29udGFjdElkLnRvU3RyaW5nKCkgOiBTdHJpbmcoZC5jb250YWN0SWQpKSA6IChkLl9pZC50b1N0cmluZyA/IGQuX2lkLnRvU3RyaW5nKCkgOiBTdHJpbmcoZC5faWQpKTtcclxuICAgICAgICAgICAgaWYgKHF1ZXVlZFNldDIuaGFzKGNpZCkpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIHJlcXVldWVQcm9taXNlcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgcXVldWUuYWRkKFxyXG4gICAgICAgICAgICAgICAgICBkLnN0ZXAgPyAnZm9sbG93dXAnIDogJ2luaXRpYWwnLFxyXG4gICAgICAgICAgICAgICAgICB7IGNhbXBhaWduSWQ6IGlkLCBjb250YWN0SWQ6IGNpZCwgc3RlcDogZC5zdGVwIH0sXHJcbiAgICAgICAgICAgICAgICAgIHsgcmVtb3ZlT25Db21wbGV0ZTogdHJ1ZSwgcmVtb3ZlT25GYWlsOiB0cnVlLCBhdHRlbXB0czogTUFYX0FUVEVNUFRTLCBiYWNrb2ZmOiB7IHR5cGU6ICdleHBvbmVudGlhbCcsIGRlbGF5OiA2MF8wMDAgfSB9XHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGVucXVldWUgc3RhbGUgc2VuZGluZyBjb250YWN0IG9uIHJlc3VtZScsIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHB1Ymxpc2ggY29udGFjdC1sZXZlbCB1cGRhdGUgaGludCBzbyBVSSByZWZsZWN0cyBpdCdzIG5vdyBwZW5kaW5nXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgc2FmZVB1Ymxpc2goYGNhbXBhaWduOiR7aWR9OmNvbnRhY3RfdXBkYXRlYCwgeyBjb250YWN0SWQ6IGNpZCwgc3RhdHVzOiAncGVuZGluZycsIGJnQXR0ZW1wdHM6IDAsIGF0dGVtcHRzOiB1bmRlZmluZWQgfSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHt9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHJlcXVldWVQcm9taXNlcy5sZW5ndGggPiAwKSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQocmVxdWV1ZVByb21pc2VzKTtcclxuICAgICAgICAgIGF3YWl0IHNhZmVQdWJsaXNoKCdjYW1wYWlnbjpuZXcnLCB7IGlkLCBhY3Rpb246ICdyZXN1bWVfcmVjb3ZlcmVkX3NlbmRpbmcnLCByZWNvdmVyZWQ6IHN0YWxlRG9jcy5sZW5ndGggfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcmVjb3ZlciBzdGFsZSBzZW5kaW5nIHJvd3Mgb24gcmVzdW1lJywgZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7IG9rOiB0cnVlLCBhY3Rpb246ICdyZXN1bWVkJyB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBQ1RJT046IFJlY29uY2lsZSAobGlnaHR3ZWlnaHQsIHNpbmdsZS1yZXF1ZXN0IHJlY29uY2lsaWF0aW9uKVxyXG4gICAgaWYgKGFjdGlvbiA9PT0gJ3JlY29uY2lsZScpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyAxKSBSZWNvdmVyIHN0YWxlICdzZW5kaW5nJyByb3dzIC0+IHBlbmRpbmdcclxuICAgICAgICBjb25zdCBjdXRvZmYgPSBuZXcgRGF0ZShEYXRlLm5vdygpIC0gU1RBTEVfU0VORElOR19NUyk7XHJcbiAgICAgICAgY29uc3Qgc3RhbGVTZW5kaW5nID0gYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25fY29udGFjdHMnKS5maW5kKHtcclxuICAgICAgICAgIGNhbXBhaWduSWQ6IGNhbXBhaWduT2JqZWN0SWQsXHJcbiAgICAgICAgICBzdGF0dXM6ICdzZW5kaW5nJyxcclxuICAgICAgICAgIGxhc3RBdHRlbXB0QXQ6IHsgJGx0OiBjdXRvZmYgfSxcclxuICAgICAgICB9KS5wcm9qZWN0KHsgX2lkOiAxLCBjb250YWN0SWQ6IDEsIHN0ZXA6IDEgfSkubGltaXQoUkVTVU1FX0VOUVVFVUVfTElNSVQpLnRvQXJyYXkoKTtcclxuXHJcbiAgICAgICAgaWYgKHN0YWxlU2VuZGluZy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBjb25zdCBpZHMgPSBzdGFsZVNlbmRpbmcubWFwKGQgPT4gZC5faWQpO1xyXG4gICAgICAgICAgYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25fY29udGFjdHMnKS51cGRhdGVNYW55KFxyXG4gICAgICAgICAgICB7IF9pZDogeyAkaW46IGlkcyB9IH0sXHJcbiAgICAgICAgICAgIHsgJHNldDogeyBzdGF0dXM6ICdwZW5kaW5nJywgbGFzdEVycm9yOiBudWxsLCBiZ0F0dGVtcHRzOiAwIH0gfVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDIpIEVucXVldWUgcGVuZGluZyBkb2NzIHRoYXQgZG8gbm90IGN1cnJlbnRseSBoYXZlIGEgam9iXHJcbiAgICAgICAgY29uc3QgcXVldWVkU2V0ID0gYXdhaXQgZ2V0UXVldWVkQ29udGFjdElkc0ZvckNhbXBhaWduKGlkKTtcclxuICAgICAgICBjb25zdCBwZW5kaW5nQ3Vyc29yID0gZGIuY29sbGVjdGlvbignY2FtcGFpZ25fY29udGFjdHMnKS5maW5kKFxyXG4gICAgICAgICAgeyBjYW1wYWlnbklkOiBjYW1wYWlnbk9iamVjdElkLCBzdGF0dXM6ICdwZW5kaW5nJyB9LFxyXG4gICAgICAgICAgeyBwcm9qZWN0aW9uOiB7IF9pZDogMSwgY29udGFjdElkOiAxLCBzdGVwOiAxIH0gfVxyXG4gICAgICAgICkubGltaXQoUkVTVU1FX0VOUVVFVUVfTElNSVQpO1xyXG4gICAgICAgIGNvbnN0IHBlbmRpbmdSb3dzID0gYXdhaXQgcGVuZGluZ0N1cnNvci50b0FycmF5KCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGVucXVldWVQcm9taXNlczogUHJvbWlzZTxhbnk+W10gPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGQgb2YgcGVuZGluZ1Jvd3MpIHtcclxuICAgICAgICAgIGNvbnN0IGNpZCA9IGQuY29udGFjdElkID8gKGQuY29udGFjdElkLnRvU3RyaW5nID8gZC5jb250YWN0SWQudG9TdHJpbmcoKSA6IFN0cmluZyhkLmNvbnRhY3RJZCkpIDogKGQuX2lkLnRvU3RyaW5nID8gZC5faWQudG9TdHJpbmcoKSA6IFN0cmluZyhkLl9pZCkpO1xyXG4gICAgICAgICAgaWYgKHF1ZXVlZFNldC5oYXMoY2lkKSkgY29udGludWU7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBlbnF1ZXVlUHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICBxdWV1ZS5hZGQoXHJcbiAgICAgICAgICAgICAgICBkLnN0ZXAgPyAnZm9sbG93dXAnIDogJ2luaXRpYWwnLFxyXG4gICAgICAgICAgICAgICAgeyBjYW1wYWlnbklkOiBpZCwgY29udGFjdElkOiBjaWQsIHN0ZXA6IGQuc3RlcCB9LFxyXG4gICAgICAgICAgICAgICAgeyByZW1vdmVPbkNvbXBsZXRlOiB0cnVlLCByZW1vdmVPbkZhaWw6IHRydWUsIGF0dGVtcHRzOiBNQVhfQVRURU1QVFMsIGJhY2tvZmY6IHsgdHlwZTogJ2V4cG9uZW50aWFsJywgZGVsYXk6IDYwXzAwMCB9IH1cclxuICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignUmVjb25jaWxlOiBmYWlsZWQgdG8gZW5xdWV1ZScsIGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5xdWV1ZVByb21pc2VzLmxlbmd0aCkgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKGVucXVldWVQcm9taXNlcyk7XHJcblxyXG4gICAgICAgIC8vIDMpIFJlY2FsY3VsYXRlIHRvdGFscyBmcm9tIERCIChhdXRob3JpdGF0aXZlKVxyXG4gICAgICAgIGNvbnN0IGFnZyA9IGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWduX2NvbnRhY3RzJykuYWdncmVnYXRlKFtcclxuICAgICAgICAgIHsgJG1hdGNoOiB7IGNhbXBhaWduSWQ6IGNhbXBhaWduT2JqZWN0SWQgfSB9LFxyXG4gICAgICAgICAgeyAkZ3JvdXA6IHsgX2lkOiAnJHN0YXR1cycsIGNvdW50OiB7ICRzdW06IDEgfSB9IH1cclxuICAgICAgICBdKS50b0FycmF5KCk7XHJcblxyXG4gICAgICAgIGxldCBwZW5kaW5nID0gMCwgc2VudCA9IDAsIGZhaWxlZCA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCByIG9mIGFnZykge1xyXG4gICAgICAgICAgaWYgKHIuX2lkID09PSAncGVuZGluZycpIHBlbmRpbmcgPSByLmNvdW50O1xyXG4gICAgICAgICAgZWxzZSBpZiAoci5faWQgPT09ICdzZW50Jykgc2VudCA9IHIuY291bnQ7XHJcbiAgICAgICAgICBlbHNlIGlmIChyLl9pZCA9PT0gJ2ZhaWxlZCcpIGZhaWxlZCA9IHIuY291bnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IHNlbnQgKyBmYWlsZWQ7XHJcbiAgICAgICAgY29uc3QgaW50ZW5kZWQgPSBjYW1wYWlnbi50b3RhbHM/LmludGVuZGVkID8/IChhd2FpdCBkYi5jb2xsZWN0aW9uKCdjYW1wYWlnbl9jb250YWN0cycpLmNvdW50RG9jdW1lbnRzKHsgY2FtcGFpZ25JZDogY2FtcGFpZ25PYmplY3RJZCB9KSk7XHJcblxyXG4gICAgICAgIC8vIFdyaXRlIGJhY2sgYXV0aG9yaXRhdGl2ZSB0b3RhbHMgdG8gREJcclxuICAgICAgICBhd2FpdCBkYi5jb2xsZWN0aW9uKCdjYW1wYWlnbnMnKS51cGRhdGVPbmUoXHJcbiAgICAgICAgICB7IF9pZDogY2FtcGFpZ25PYmplY3RJZCB9LFxyXG4gICAgICAgICAgeyAkc2V0OiB7ICd0b3RhbHMucHJvY2Vzc2VkJzogcHJvY2Vzc2VkLCAndG90YWxzLnNlbnQnOiBzZW50LCAndG90YWxzLmZhaWxlZCc6IGZhaWxlZCB9IH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBCZXN0LWVmZm9ydCB3cml0ZSB0byBSZWRpcyBtZXRhXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGF3YWl0IHJlZGlzLmhzZXQocmVkaXNLZXksIHsgcHJvY2Vzc2VkOiBTdHJpbmcocHJvY2Vzc2VkKSwgc2VudDogU3RyaW5nKHNlbnQpLCBmYWlsZWQ6IFN0cmluZyhmYWlsZWQpLCB0b3RhbDogU3RyaW5nKGludGVuZGVkKSB9KTtcclxuICAgICAgICB9IGNhdGNoIChfKSB7fVxyXG5cclxuICAgICAgICAvLyA0KSBEZWNpZGUgY2Fub25pY2FsIGNhbXBhaWduIHN0YXR1c1xyXG4gICAgICAgIGxldCBuZXdTdGF0dXMgPSBjYW1wYWlnbi5zdGF0dXM7XHJcbiAgICAgICAgaWYgKHByb2Nlc3NlZCA+PSBpbnRlbmRlZCkge1xyXG4gICAgICAgICAgaWYgKGZhaWxlZCA+IDApIG5ld1N0YXR1cyA9ICdjb21wbGV0ZWRfd2l0aF9mYWlsdXJlcyc7XHJcbiAgICAgICAgICBlbHNlIG5ld1N0YXR1cyA9ICdjb21wbGV0ZWQnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuZXdTdGF0dXMgPSAncnVubmluZyc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBwZXJzaXN0IHN0YXR1cyBpZiBjaGFuZ2VkXHJcbiAgICAgICAgaWYgKG5ld1N0YXR1cyAhPT0gY2FtcGFpZ24uc3RhdHVzKSB7XHJcbiAgICAgICAgICBhd2FpdCBkYi5jb2xsZWN0aW9uKCdjYW1wYWlnbnMnKS51cGRhdGVPbmUoeyBfaWQ6IGNhbXBhaWduT2JqZWN0SWQgfSwgeyAkc2V0OiB7IHN0YXR1czogbmV3U3RhdHVzLCBjb21wbGV0ZWRBdDogKG5ld1N0YXR1cy5zdGFydHNXaXRoKCdjb21wbGV0ZWQnKSA/IG5ldyBEYXRlKCkgOiBudWxsKSB9IH0gYXMgYW55KTtcclxuICAgICAgICAgIGF3YWl0IHNhZmVIU2V0KHJlZGlzS2V5LCB7IHN0YXR1czogbmV3U3RhdHVzIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXdhaXQgc2FmZVB1Ymxpc2goJ2NhbXBhaWduOm5ldycsIHsgaWQsIGFjdGlvbjogJ3JlY29uY2lsZScsIHJlcXVldWVkOiBlbnF1ZXVlUHJvbWlzZXMubGVuZ3RoLCByZWNvdmVyZWQ6IHN0YWxlU2VuZGluZy5sZW5ndGgsIHN0YXR1czogbmV3U3RhdHVzIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oeyBvazogdHJ1ZSwgcmVxdWV1ZWQ6IGVucXVldWVQcm9taXNlcy5sZW5ndGgsIHJlY292ZXJlZDogc3RhbGVTZW5kaW5nLmxlbmd0aCwgc3RhdHVzOiBuZXdTdGF0dXMgfSk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdSZWNvbmNpbGUgZmFpbGVkJywgZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgZXJyb3I6ICdyZWNvbmNpbGUtZmFpbGVkJyB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEFDVElPTjogQ2FuY2VsXHJcbiAgICBpZiAoYWN0aW9uID09PSAnY2FuY2VsJykge1xyXG4gICAgICBpZiAoY2FtcGFpZ24uc3RhdHVzID09PSAnY2FuY2VsbGVkJykge1xyXG4gICAgICAgIHJldHVybiByZXNcclxuICAgICAgICAgIC5zdGF0dXMoMjAwKVxyXG4gICAgICAgICAgLmpzb24oeyBvazogdHJ1ZSwgbWVzc2FnZTogJ0FscmVhZHkgY2FuY2VsbGVkJyB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gMSkgTWFyayBjYW1wYWlnbiBjYW5jZWxsZWQgYW5kIGNvbXBsZXRlZEF0XHJcbiAgICAgIGNvbnN0IGNvbXBsZXRlZEF0ID0gbmV3IERhdGUoKTtcclxuICAgICAgYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25zJykudXBkYXRlT25lKFxyXG4gICAgICAgIHsgX2lkOiBjYW1wYWlnbk9iamVjdElkIH0sXHJcbiAgICAgICAgeyAkc2V0OiB7IHN0YXR1czogJ2NhbmNlbGxlZCcsIGNvbXBsZXRlZEF0IH0gfVxyXG4gICAgICApO1xyXG4gICAgICBhd2FpdCBzYWZlSFNldChyZWRpc0tleSwgeyBzdGF0dXM6ICdjYW5jZWxsZWQnIH0pO1xyXG5cclxuICAgICAgLy8gMikgRmluZCBhbmQgYXRvbWljYWxseSBtYXJrIHBlbmRpbmcgbGVkZ2VyIHJvd3MgYXMgZmFpbGVkIChzaW5nbGUgdXBkYXRlTWFueSlcclxuICAgICAgY29uc3QgZmlsdGVyID0geyBjYW1wYWlnbklkOiBjYW1wYWlnbk9iamVjdElkLCBzdGF0dXM6ICdwZW5kaW5nJyB9O1xyXG4gICAgICBjb25zdCB1cGRhdGUgPSB7XHJcbiAgICAgICAgJHNldDoge1xyXG4gICAgICAgICAgc3RhdHVzOiAnZmFpbGVkJyxcclxuICAgICAgICAgIGxhc3RFcnJvcjogJ2NhbmNlbGxlZCcsXHJcbiAgICAgICAgICBsYXN0QXR0ZW1wdEF0OiBjb21wbGV0ZWRBdCxcclxuICAgICAgICB9LFxyXG4gICAgICAgICRpbmM6IHsgYXR0ZW1wdHM6IDEgfSxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGNvbnN0IHVwZGF0ZVJlc3VsdCA9IGF3YWl0IGRiXHJcbiAgICAgICAgLmNvbGxlY3Rpb24oJ2NhbXBhaWduX2NvbnRhY3RzJylcclxuICAgICAgICAudXBkYXRlTWFueShmaWx0ZXIsIHVwZGF0ZSk7XHJcblxyXG4gICAgICBjb25zdCBjYW5jZWxsZWRDb3VudCA9IHVwZGF0ZVJlc3VsdC5tb2RpZmllZENvdW50ID8/IDA7XHJcblxyXG4gICAgICAvLyAzKSBVcGRhdGUgUmVkaXMgY291bnRlcnMgKGJlc3QtZWZmb3J0KVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmIChjYW5jZWxsZWRDb3VudCA+IDApIHtcclxuICAgICAgICAgIGF3YWl0IHJlZGlzLmhpbmNyYnkocmVkaXNLZXksICdwcm9jZXNzZWQnLCBjYW5jZWxsZWRDb3VudCk7XHJcbiAgICAgICAgICBhd2FpdCByZWRpcy5oaW5jcmJ5KHJlZGlzS2V5LCAnZmFpbGVkJywgY2FuY2VsbGVkQ291bnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHVwZGF0ZSByZWRpcyBjb3VudGVycyBkdXJpbmcgY2FuY2VsJywgZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIDQpIFBlcnNpc3QgdG90YWxzIHNuYXBzaG90IHRvIGNhbXBhaWducy50b3RhbHMgKHJlYWQgcmVkaXMgaWYgYXZhaWxhYmxlLCBmYWxsYmFjayB0byBkYilcclxuICAgICAgbGV0IG1ldGEgPSB7fTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBtZXRhID0gKGF3YWl0IHJlZGlzLmhnZXRhbGwocmVkaXNLZXkpKSB8fCB7fTtcclxuICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgbWV0YSA9IHt9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb21wdXRlIHRvdGFscyBmaW5hbCB2YWx1ZXMgY29tYmluaW5nIHBlcnNpc3RlZCB0b3RhbHMgYW5kIG91ciBjYW5jZWxsZWRDb3VudCBhcyBmYWxsYmFja1xyXG4gICAgICBjb25zdCBwcm9jZXNzZWROb3cgPSBOdW1iZXIobWV0YVsncHJvY2Vzc2VkJ10gPz8gKGNhbXBhaWduLnRvdGFscz8ucHJvY2Vzc2VkID8/IDApICsgY2FuY2VsbGVkQ291bnQpO1xyXG4gICAgICBjb25zdCBzZW50Tm93ID0gTnVtYmVyKG1ldGFbJ3NlbnQnXSA/PyAoY2FtcGFpZ24udG90YWxzPy5zZW50ID8/IDApKTtcclxuICAgICAgY29uc3QgZmFpbGVkTm93ID0gTnVtYmVyKG1ldGFbJ2ZhaWxlZCddID8/IChjYW1wYWlnbi50b3RhbHM/LmZhaWxlZCA/PyAwKSArIGNhbmNlbGxlZENvdW50KTtcclxuXHJcbiAgICAgIGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWducycpLnVwZGF0ZU9uZShcclxuICAgICAgICB7IF9pZDogY2FtcGFpZ25PYmplY3RJZCB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICRzZXQ6IHtcclxuICAgICAgICAgICAgJ3RvdGFscy5wcm9jZXNzZWQnOiBwcm9jZXNzZWROb3csXHJcbiAgICAgICAgICAgICd0b3RhbHMuc2VudCc6IHNlbnROb3csXHJcbiAgICAgICAgICAgICd0b3RhbHMuZmFpbGVkJzogZmFpbGVkTm93LFxyXG4gICAgICAgICAgICBjb21wbGV0ZWRBdCxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gNSkgUmVtb3ZlIHF1ZXVlZCBqb2JzIGZvciB0aGlzIGNhbXBhaWduIChiZXN0LWVmZm9ydClcclxuICAgICAgY29uc3QgcmVtb3ZlZEpvYnMgPSBhd2FpdCByZW1vdmVRdWV1ZWRKb2JzRm9yQ2FtcGFpZ24oaWQpO1xyXG5cclxuICAgICAgLy8gNikgUHVibGlzaCBldmVudFxyXG4gICAgICBhd2FpdCBzYWZlUHVibGlzaCgnY2FtcGFpZ246bmV3JywgeyBpZCwgc3RhdHVzOiAnY2FuY2VsbGVkJywgY2FuY2VsbGVkQ291bnQsIHJlbW92ZWRKb2JzIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHtcclxuICAgICAgICBvazogdHJ1ZSxcclxuICAgICAgICBhY3Rpb246ICdjYW5jZWxsZWQnLFxyXG4gICAgICAgIGNhbmNlbGxlZENvdW50LFxyXG4gICAgICAgIHJlbW92ZWRKb2JzLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBQ1RJT046IERlbGV0ZVxyXG4gICAgaWYgKGFjdGlvbiA9PT0gJ2RlbGV0ZScpIHtcclxuICAgICAgLy8gUmVxdWlyZSBleHBsaWNpdCBjb25maXJtYXRpb24g4oCUIHNhZmVndWFyZHMgaW4gVUkgbXVzdCBzZXQgY29uZmlybT10cnVlXHJcbiAgICAgIGlmIChjb25maXJtICE9PSB0cnVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc1xyXG4gICAgICAgICAgLnN0YXR1cyg0MDApXHJcbiAgICAgICAgICAuanNvbih7IGVycm9yOiAnRGVsZXRpb24gcmVxdWlyZXMgY29uZmlybT10cnVlIGluIHJlcXVlc3QgYm9keScgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFByZXZlbnQgYWNjaWRlbnRhbCBkZWxldGlvbiB3aGlsZSBydW5uaW5nXHJcbiAgICAgIGlmIChjYW1wYWlnbi5zdGF0dXMgPT09ICdydW5uaW5nJykge1xyXG4gICAgICAgIHJldHVybiByZXNcclxuICAgICAgICAgIC5zdGF0dXMoNDAwKVxyXG4gICAgICAgICAgLmpzb24oeyBlcnJvcjogJ0NhbmNlbCB0aGUgY2FtcGFpZ24gYmVmb3JlIGRlbGV0aW9uJyB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIHF1ZXVlZCBqb2JzIChiZXN0LWVmZm9ydClcclxuICAgICAgY29uc3QgcmVtb3ZlZEpvYnMgPSBhd2FpdCByZW1vdmVRdWV1ZWRKb2JzRm9yQ2FtcGFpZ24oaWQpO1xyXG5cclxuICAgICAgLy8gRGVsZXRlIFJlZGlzIGtleXMgKGJlc3QtZWZmb3J0KVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IHJlZGlzLmRlbChgY2FtcGFpZ246JHtpZH06bWV0YWApO1xyXG4gICAgICAgIGF3YWl0IHJlZGlzLmRlbChgY2FtcGFpZ246JHtpZH06ZGVmaW5pdGlvbmApO1xyXG4gICAgICAgIGF3YWl0IHJlZGlzLnNyZW0oJ2NhbXBhaWduOmFsbCcsIGlkKTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignUmVkaXMgY2xlYW51cCBvbiBkZWxldGUgZmFpbGVkJywgZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERlbGV0ZSBNb25nbyBkb2NzXHJcbiAgICAgIGNvbnN0IFtjYW1wYWlnbkRlbCwgbGVkZ2VyRGVsXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICBkYi5jb2xsZWN0aW9uKCdjYW1wYWlnbnMnKS5kZWxldGVPbmUoeyBfaWQ6IGNhbXBhaWduT2JqZWN0SWQgfSksXHJcbiAgICAgICAgZGIuY29sbGVjdGlvbignY2FtcGFpZ25fY29udGFjdHMnKS5kZWxldGVNYW55KHsgY2FtcGFpZ25JZDogY2FtcGFpZ25PYmplY3RJZCB9KSxcclxuICAgICAgXSk7XHJcblxyXG4gICAgICBhd2FpdCBzYWZlUHVibGlzaCgnY2FtcGFpZ246bmV3JywgeyBpZCwgc3RhdHVzOiAnZGVsZXRlZCcgfSk7XHJcblxyXG4gICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oe1xyXG4gICAgICAgIG9rOiB0cnVlLFxyXG4gICAgICAgIGFjdGlvbjogJ2RlbGV0ZWQnLFxyXG4gICAgICAgIGNhbXBhaWduRGVsZXRlZDogY2FtcGFpZ25EZWwuZGVsZXRlZENvdW50ID8/IDAsXHJcbiAgICAgICAgbGVkZ2VyRGVsZXRlZDogbGVkZ2VyRGVsLmRlbGV0ZWRDb3VudCA/PyAwLFxyXG4gICAgICAgIHJlbW92ZWRKb2JzLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBQ1RJT046IFJldHJ5IGFsbCBmYWlsZWQgY29udGFjdHMgdGhhdCBhcmUgYmVsb3cgTUFYX0FUVEVNUFRTXHJcbiAgICBpZiAoYWN0aW9uID09PSAncmV0cnlGYWlsZWQnKSB7XHJcbiAgICAgIC8vIERpc2FsbG93IHJldHJ5aW5nIGlmIGNhbXBhaWduIGlzIGNhbmNlbGxlZC9kZWxldGVkL3BhdXNlZFxyXG4gICAgICBpZiAoY2FtcGFpZ24uc3RhdHVzID09PSAnY2FuY2VsbGVkJyB8fCBjYW1wYWlnbi5zdGF0dXMgPT09ICdkZWxldGVkJyB8fCBjYW1wYWlnbi5zdGF0dXMgPT09ICdwYXVzZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgZXJyb3I6ICdDYW5ub3QgcmV0cnkgY29udGFjdHMgZm9yIGNhbmNlbGxlZC9kZWxldGVkL3BhdXNlZCBjYW1wYWlnbicgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEVuc3VyZSBhIFJlZGlzIGNhbXBhaWduIGRlZmluaXRpb24gZXhpc3RzICh3b3JrZXIgcmVxdWlyZXMgaXQpXHJcbiAgICAgIGNvbnN0IGhhc0RlZiA9IGF3YWl0IGVuc3VyZUNhbXBhaWduRGVmaW5pdGlvbihpZCwgY2FtcGFpZ24pO1xyXG4gICAgICBpZiAoIWhhc0RlZikge1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7IGVycm9yOiAnTWlzc2luZyBjYW1wYWlnbiBkZWZpbml0aW9uIGluIFJlZGlzIGFuZCB1bmFibGUgdG8gY29uc3RydWN0IG9uZSBmcm9tIGNhbXBhaWduIGRvY3VtZW50LiBSZXRyeSBjYW5ub3QgcHJvY2VlZC4nIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBmaW5kIGZhaWxlZCBjb250YWN0cyB3aXRoIGF0dGVtcHRzIDwgTUFYX0FUVEVNUFRTIEFORCB3aGVyZSBiZ0F0dGVtcHRzID49IE1BWF9BVFRFTVBUUyAobWVhbmluZyBiYWNrZ3JvdW5kIGN5Y2xlIGZpbmlzaGVkKVxyXG4gICAgICAvLyBJZiBiZ0F0dGVtcHRzIGlzIG1pc3NpbmcgKHVuZGVmaW5lZC9udWxsKSwgdHJlYXQgaXQgYXMgZmluaXNoZWQgKGNvbnNlcnZhdGl2ZSkuIEJ1dCBwcmVmZXIgZXhwbGljaXQgPj0uXHJcbiAgICAgIGNvbnN0IGZpbHRlcjogYW55ID0ge1xyXG4gICAgICAgIGNhbXBhaWduSWQ6IGNhbXBhaWduT2JqZWN0SWQsXHJcbiAgICAgICAgc3RhdHVzOiAnZmFpbGVkJyxcclxuICAgICAgICBhdHRlbXB0czogeyAkbHQ6IE1BWF9BVFRFTVBUUyB9LFxyXG4gICAgICAgICRvcjogW1xyXG4gICAgICAgICAgeyBiZ0F0dGVtcHRzOiB7ICRleGlzdHM6IGZhbHNlIH0gfSxcclxuICAgICAgICAgIHsgYmdBdHRlbXB0czogeyAkZ3RlOiBNQVhfQVRURU1QVFMgfSB9LFxyXG4gICAgICAgIF0sXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCBmYWlsZWREb2NzID0gYXdhaXQgZGJcclxuICAgICAgICAuY29sbGVjdGlvbignY2FtcGFpZ25fY29udGFjdHMnKVxyXG4gICAgICAgIC5maW5kKGZpbHRlciwgeyBwcm9qZWN0aW9uOiB7IF9pZDogMSwgY29udGFjdElkOiAxLCBzdGVwOiAxIH0gfSlcclxuICAgICAgICAudG9BcnJheSgpO1xyXG5cclxuICAgICAgY29uc3QgdG9SZXRyeUNvdW50ID0gZmFpbGVkRG9jcy5sZW5ndGg7XHJcbiAgICAgIGlmICh0b1JldHJ5Q291bnQgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oeyBvazogdHJ1ZSwgcmV0cmllZDogMCwgbWVzc2FnZTogJ05vIGVsaWdpYmxlIGZhaWxlZCBjb250YWN0cyB0byByZXRyeSAoZWl0aGVyIG5vbmUgZmFpbGVkLCByZWFjaGVkIG1heCBhdHRlbXB0cywgb3IgYmFja2dyb3VuZCByZXRyaWVzIHN0aWxsIGluIHByb2dyZXNzKS4nIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBzZXJ2ZXItc2lkZSBjYXAgZW5mb3JjZW1lbnRcclxuICAgICAgaWYgKHRvUmV0cnlDb3VudCA+IEJBVENIX1JFVFJZX0xJTUlUKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHtcclxuICAgICAgICAgIGVycm9yOiAnQmF0Y2ggcmV0cnkgZXhjZWVkcyBzZXJ2ZXIgbGltaXQnLFxyXG4gICAgICAgICAgbWVzc2FnZTogYFRyeWluZyB0byByZXRyeSAke3RvUmV0cnlDb3VudH0gY29udGFjdHMgZXhjZWVkcyBzZXJ2ZXIgY2FwIG9mICR7QkFUQ0hfUkVUUllfTElNSVR9LiBVc2UgcGFnaW5hdGlvbiB0byByZXRyeSBpbiBzbWFsbGVyIGJhdGNoZXMuYCxcclxuICAgICAgICAgIHRvUmV0cnlDb3VudCxcclxuICAgICAgICAgIGxpbWl0OiBCQVRDSF9SRVRSWV9MSU1JVCxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQXRvbWljYWxseSBtYXJrIHRoZW0gcGVuZGluZyBhbmQgaW5jcmVtZW50IGNvcmUgYGF0dGVtcHRzYCBhbmQgcmVzZXQgYmdBdHRlbXB0c1xyXG4gICAgICBjb25zdCBpZHMgPSBmYWlsZWREb2NzLm1hcChkID0+IGQuX2lkKTtcclxuICAgICAgY29uc3QgdXBkYXRlUmVzdWx0ID0gYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25fY29udGFjdHMnKS51cGRhdGVNYW55KFxyXG4gICAgICAgIHsgX2lkOiB7ICRpbjogaWRzIH0gfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAkc2V0OiB7IHN0YXR1czogJ3BlbmRpbmcnLCBsYXN0RXJyb3I6IG51bGwsIGJnQXR0ZW1wdHM6IDAgfSxcclxuICAgICAgICAgICRpbmM6IHsgYXR0ZW1wdHM6IDEgfSxcclxuICAgICAgICB9XHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjb25zdCB1cGRhdGVkID0gdXBkYXRlUmVzdWx0Lm1vZGlmaWVkQ291bnQgPz8gMDtcclxuXHJcbiAgICAgIC8vIEVucXVldWUgam9icyAoYmF0Y2gpLCBlbnN1cmUgZWFjaCBqb2IgaGFzIE1RIGF0dGVtcHRzL2JhY2tvZmYgc2V0XHJcbiAgICAgIGNvbnN0IGpvYnM6IFByb21pc2U8YW55PltdID0gW107XHJcbiAgICAgIGNvbnN0IENIVU5LID0gMjAwOyAvLyByZWFzb25hYmxlIGNodW5raW5nXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmFpbGVkRG9jcy5sZW5ndGg7IGkgKz0gQ0hVTkspIHtcclxuICAgICAgICBjb25zdCBjaHVuayA9IGZhaWxlZERvY3Muc2xpY2UoaSwgaSArIENIVU5LKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGRvYyBvZiBjaHVuaykge1xyXG4gICAgICAgICAgY29uc3QgY29udGFjdE9iaklkID0gZG9jLmNvbnRhY3RJZCA/IGRvYy5jb250YWN0SWQgOiBkb2MuX2lkO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGRvYy5zdGVwKSB7XHJcbiAgICAgICAgICAgICAgam9icy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgcXVldWUuYWRkKFxyXG4gICAgICAgICAgICAgICAgICAnZm9sbG93dXAnLFxyXG4gICAgICAgICAgICAgICAgICB7IGNhbXBhaWduSWQ6IGlkLCBjb250YWN0SWQ6IGNvbnRhY3RPYmpJZC50b1N0cmluZyA/IGNvbnRhY3RPYmpJZC50b1N0cmluZygpIDogU3RyaW5nKGNvbnRhY3RPYmpJZCksIHN0ZXA6IGRvYy5zdGVwIH0sXHJcbiAgICAgICAgICAgICAgICAgIHsgcmVtb3ZlT25Db21wbGV0ZTogdHJ1ZSwgcmVtb3ZlT25GYWlsOiB0cnVlLCBhdHRlbXB0czogTUFYX0FUVEVNUFRTLCBiYWNrb2ZmOiB7IHR5cGU6ICdleHBvbmVudGlhbCcsIGRlbGF5OiA2MF8wMDAgfSB9XHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBqb2JzLnB1c2goXHJcbiAgICAgICAgICAgICAgICBxdWV1ZS5hZGQoXHJcbiAgICAgICAgICAgICAgICAgICdpbml0aWFsJyxcclxuICAgICAgICAgICAgICAgICAgeyBjYW1wYWlnbklkOiBpZCwgY29udGFjdElkOiBjb250YWN0T2JqSWQudG9TdHJpbmcgPyBjb250YWN0T2JqSWQudG9TdHJpbmcoKSA6IFN0cmluZyhjb250YWN0T2JqSWQpIH0sXHJcbiAgICAgICAgICAgICAgICAgIHsgcmVtb3ZlT25Db21wbGV0ZTogdHJ1ZSwgcmVtb3ZlT25GYWlsOiB0cnVlLCBhdHRlbXB0czogTUFYX0FUVEVNUFRTLCBiYWNrb2ZmOiB7IHR5cGU6ICdleHBvbmVudGlhbCcsIGRlbGF5OiA2MF8wMDAgfSB9XHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBxdWV1ZSBqb2IgZm9yIHJldHJ5RmFpbGVkIGNodW5rIGl0ZW0nLCBlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFdhaXQgZm9yIGVucXVldWVzIChiZXN0LWVmZm9ydClcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChqb2JzKTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignU29tZSBxdWV1ZS5hZGQgY2FsbHMgZmFpbGVkIGR1cmluZyByZXRyeUZhaWxlZCcsIGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBVcGRhdGUgcmVkaXMgY291bnRlcnM6IGRlY3JlYXNlIGZhaWxlZCBieSB1cGRhdGVkIChiZXN0LWVmZm9ydCwgYnV0IGF2b2lkIG5lZ2F0aXZlKVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRGYWlsZWQgPSBhd2FpdCBzYWZlR2V0TWV0YUludChyZWRpc0tleSwgJ2ZhaWxlZCcpO1xyXG4gICAgICAgIGNvbnN0IGRlYyA9IE1hdGgubWluKHVwZGF0ZWQsIGN1cnJlbnRGYWlsZWQpO1xyXG4gICAgICAgIGlmIChkZWMgPiAwKSB7XHJcbiAgICAgICAgICBhd2FpdCByZWRpcy5oaW5jcmJ5KHJlZGlzS2V5LCAnZmFpbGVkJywgLWRlYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gdXBkYXRlIHJlZGlzIGNvdW50ZXJzIGR1cmluZyByZXRyeUZhaWxlZCcsIGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBbHNvIGNvcnJlY3QgcHJvY2Vzc2VkIGNvdW50ZXIgYmVjYXVzZSB3ZSBhcmUgbW92aW5nIGZpbmFsIGZhaWxlZCAtPiBwZW5kaW5nIChwcm9jZXNzZWQgc2hvdWxkIGRyb3ApXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFByb2Nlc3NlZCA9IGF3YWl0IHNhZmVHZXRNZXRhSW50KHJlZGlzS2V5LCAncHJvY2Vzc2VkJyk7XHJcbiAgICAgICAgY29uc3QgZGVjUHJvYyA9IE1hdGgubWluKHVwZGF0ZWQsIGN1cnJlbnRQcm9jZXNzZWQpO1xyXG4gICAgICAgIGlmIChkZWNQcm9jID4gMCkge1xyXG4gICAgICAgICAgYXdhaXQgcmVkaXMuaGluY3JieShyZWRpc0tleSwgJ3Byb2Nlc3NlZCcsIC1kZWNQcm9jKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byB1cGRhdGUgcHJvY2Vzc2VkIGNvdW50ZXIgZHVyaW5nIHJldHJ5RmFpbGVkJywgZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFB1Ymxpc2ggY29udGFjdC1sZXZlbCB1cGRhdGVzIGZvciBlYWNoIHJldHJpZWQgY29udGFjdCAoYmVzdC1lZmZvcnQpXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBkb2Mgb2YgZmFpbGVkRG9jcykge1xyXG4gICAgICAgICAgY29uc3QgY2lkID0gZG9jLmNvbnRhY3RJZCA/IChkb2MuY29udGFjdElkLnRvU3RyaW5nID8gZG9jLmNvbnRhY3RJZC50b1N0cmluZygpIDogU3RyaW5nKGRvYy5jb250YWN0SWQpKSA6IChkb2MuX2lkLnRvU3RyaW5nID8gZG9jLl9pZC50b1N0cmluZygpIDogU3RyaW5nKGRvYy5faWQpKTtcclxuICAgICAgICAgIGF3YWl0IHNhZmVQdWJsaXNoKGBjYW1wYWlnbjoke2lkfTpjb250YWN0X3VwZGF0ZWAsIHsgY29udGFjdElkOiBjaWQsIHN0YXR1czogJ3BlbmRpbmcnLCBiZ0F0dGVtcHRzOiAwLCBhdHRlbXB0czogMSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKF8pIHtcclxuICAgICAgICAvLyBpZ25vcmUgcHVibGlzaCBlcnJvcnNcclxuICAgICAgfVxyXG5cclxuICAgICAgYXdhaXQgc2FmZVB1Ymxpc2goJ2NhbXBhaWduOm5ldycsIHsgaWQsIGFjdGlvbjogJ3JldHJ5RmFpbGVkJywgcmV0cmllZDogdXBkYXRlZCB9KTtcclxuXHJcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7IG9rOiB0cnVlLCByZXRyaWVkOiB1cGRhdGVkLCBhdHRlbXB0ZWRFbnF1ZXVlOiB0b1JldHJ5Q291bnQgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQUNUSU9OOiBSZXRyeSBhIHNpbmdsZSBmYWlsZWQgY29udGFjdCBieSBjb250YWN0SWRcclxuICAgIGlmIChhY3Rpb24gPT09ICdyZXRyeUNvbnRhY3QnKSB7XHJcbiAgICAgIGlmICghY29udGFjdElkIHx8IHR5cGVvZiBjb250YWN0SWQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgZXJyb3I6ICdNaXNzaW5nIGNvbnRhY3RJZCBmb3IgcmV0cnlDb250YWN0JyB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGlzYWxsb3cgcmV0cnlpbmcgaWYgY2FtcGFpZ24gaXMgY2FuY2VsbGVkL2RlbGV0ZWQvcGF1c2VkXHJcbiAgICAgIGlmIChjYW1wYWlnbi5zdGF0dXMgPT09ICdjYW5jZWxsZWQnIHx8IGNhbXBhaWduLnN0YXR1cyA9PT0gJ2RlbGV0ZWQnIHx8IGNhbXBhaWduLnN0YXR1cyA9PT0gJ3BhdXNlZCcpIHtcclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBlcnJvcjogJ0Nhbm5vdCByZXRyeSBjb250YWN0cyBmb3IgY2FuY2VsbGVkL2RlbGV0ZWQvcGF1c2VkIGNhbXBhaWduJyB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRW5zdXJlIGEgUmVkaXMgY2FtcGFpZ24gZGVmaW5pdGlvbiBleGlzdHMgKHdvcmtlciByZXF1aXJlcyBpdClcclxuICAgICAgY29uc3QgaGFzRGVmID0gYXdhaXQgZW5zdXJlQ2FtcGFpZ25EZWZpbml0aW9uKGlkLCBjYW1wYWlnbik7XHJcbiAgICAgIGlmICghaGFzRGVmKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgZXJyb3I6ICdNaXNzaW5nIGNhbXBhaWduIGRlZmluaXRpb24gaW4gUmVkaXMgYW5kIHVuYWJsZSB0byBjb25zdHJ1Y3Qgb25lIGZyb20gY2FtcGFpZ24gZG9jdW1lbnQuIFJldHJ5IGNhbm5vdCBwcm9jZWVkLicgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEZpbmQgdGhlIGxlZGdlciByb3dcclxuICAgICAgbGV0IGNvbnRhY3RPYmpJZDtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyB0cnkgcGFyc2UgYXMgT2JqZWN0SWQgZmlyc3RcclxuICAgICAgICBjb250YWN0T2JqSWQgPSBuZXcgT2JqZWN0SWQoY29udGFjdElkKTtcclxuICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgLy8gZmFsbGJhY2s6IHVzZSByYXcgc3RyaW5nXHJcbiAgICAgICAgY29udGFjdE9iaklkID0gY29udGFjdElkO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkb2MgPSBhd2FpdCBkYi5jb2xsZWN0aW9uKCdjYW1wYWlnbl9jb250YWN0cycpLmZpbmRPbmUoe1xyXG4gICAgICAgIGNhbXBhaWduSWQ6IGNhbXBhaWduT2JqZWN0SWQsXHJcbiAgICAgICAgY29udGFjdElkOiBjb250YWN0T2JqSWQsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCFkb2MpIHtcclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDQpLmpzb24oeyBlcnJvcjogJ0NvbnRhY3QgbGVkZ2VyIHJvdyBub3QgZm91bmQgZm9yIGNhbXBhaWduJyB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGRvYy5zdGF0dXMgIT09ICdmYWlsZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgZXJyb3I6ICdDb250YWN0IGlzIG5vdCBpbiBmYWlsZWQgc3RhdGUnIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoKGRvYy5hdHRlbXB0cyB8fCAwKSA+PSBNQVhfQVRURU1QVFMpIHtcclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBlcnJvcjogJ0NvbnRhY3QgaGFzIHJlYWNoZWQgbWF4IG1hbnVhbCBhdHRlbXB0cyBhbmQgY2Fubm90IGJlIHJldHJpZWQnIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBQcmV2ZW50IG1hbnVhbCByZXRyeSB3aGlsZSBCdWxsTVEgYmFja2dyb3VuZCByZXRyaWVzIGFyZSBzdGlsbCBydW5uaW5nIGZvciB0aGlzIGNvbnRhY3RcclxuICAgICAgLy8gUmVxdWlyZSBiZ0F0dGVtcHRzID49IE1BWF9BVFRFTVBUUyAob3IgbWlzc2luZykgYmVmb3JlIGFsbG93aW5nIG1hbnVhbCByZXRyeVxyXG4gICAgICBjb25zdCBiZ0RvbmUgPSAodHlwZW9mIGRvYy5iZ0F0dGVtcHRzID09PSAnbnVtYmVyJyA/IGRvYy5iZ0F0dGVtcHRzID49IE1BWF9BVFRFTVBUUyA6IHRydWUpO1xyXG4gICAgICBpZiAoIWJnRG9uZSkge1xyXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IGVycm9yOiAnQmFja2dyb3VuZCByZXRyaWVzIGFyZSBzdGlsbCBpbiBwcm9ncmVzcyBmb3IgdGhpcyBjb250YWN0LiBQbGVhc2Ugd2FpdCB1bnRpbCB0aGUgYmFja2dyb3VuZCByZXRyeSBjeWNsZSBjb21wbGV0ZXMuJyB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVXBkYXRlIHNpbmdsZSBkb2MgdG8gcGVuZGluZywgaW5jcmVtZW50IGNvcmUgYXR0ZW1wdHMsIHJlc2V0IGJnQXR0ZW1wdHNcclxuICAgICAgYXdhaXQgZGIuY29sbGVjdGlvbignY2FtcGFpZ25fY29udGFjdHMnKS51cGRhdGVPbmUoXHJcbiAgICAgICAgeyBfaWQ6IGRvYy5faWQgfSxcclxuICAgICAgICB7ICRzZXQ6IHsgc3RhdHVzOiAncGVuZGluZycsIGxhc3RFcnJvcjogbnVsbCwgYmdBdHRlbXB0czogMCB9LCAkaW5jOiB7IGF0dGVtcHRzOiAxIH0gfVxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gRW5xdWV1ZSBhcHByb3ByaWF0ZSBqb2IgKHVzZSBkb2Muc3RlcCBpZiBwcmVzZW50KSBhbmQgZW5zdXJlIE1RIGF0dGVtcHRzL2JhY2tvZmYgYXJlIHNldFxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmIChkb2Muc3RlcCkge1xyXG4gICAgICAgICAgYXdhaXQgcXVldWUuYWRkKFxyXG4gICAgICAgICAgICAnZm9sbG93dXAnLFxyXG4gICAgICAgICAgICB7IGNhbXBhaWduSWQ6IGlkLCBjb250YWN0SWQ6IGNvbnRhY3RPYmpJZC50b1N0cmluZyA/IGNvbnRhY3RPYmpJZC50b1N0cmluZygpIDogU3RyaW5nKGNvbnRhY3RPYmpJZCksIHN0ZXA6IGRvYy5zdGVwIH0sXHJcbiAgICAgICAgICAgIHsgcmVtb3ZlT25Db21wbGV0ZTogdHJ1ZSwgcmVtb3ZlT25GYWlsOiB0cnVlLCBhdHRlbXB0czogTUFYX0FUVEVNUFRTLCBiYWNrb2ZmOiB7IHR5cGU6ICdleHBvbmVudGlhbCcsIGRlbGF5OiA2MF8wMDAgfSB9XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhd2FpdCBxdWV1ZS5hZGQoXHJcbiAgICAgICAgICAgICdpbml0aWFsJyxcclxuICAgICAgICAgICAgeyBjYW1wYWlnbklkOiBpZCwgY29udGFjdElkOiBjb250YWN0T2JqSWQudG9TdHJpbmcgPyBjb250YWN0T2JqSWQudG9TdHJpbmcoKSA6IFN0cmluZyhjb250YWN0T2JqSWQpIH0sXHJcbiAgICAgICAgICAgIHsgcmVtb3ZlT25Db21wbGV0ZTogdHJ1ZSwgcmVtb3ZlT25GYWlsOiB0cnVlLCBhdHRlbXB0czogTUFYX0FUVEVNUFRTLCBiYWNrb2ZmOiB7IHR5cGU6ICdleHBvbmVudGlhbCcsIGRlbGF5OiA2MF8wMDAgfSB9XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGVucXVldWUgcmV0cnkgam9iIGZvciBjb250YWN0JywgZSk7XHJcbiAgICAgICAgLy8gUm9sbGJhY2s6IHRyeSB0byByZXZlcnQgdGhlIGxlZGdlciByb3cgY2hhbmdlcyAoYmVzdC1lZmZvcnQpXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2NhbXBhaWduX2NvbnRhY3RzJykudXBkYXRlT25lKFxyXG4gICAgICAgICAgICB7IF9pZDogZG9jLl9pZCB9LFxyXG4gICAgICAgICAgICB7ICRzZXQ6IHsgc3RhdHVzOiAnZmFpbGVkJywgbGFzdEVycm9yOiAnZW5xdWV1ZS1mYWlsZWQnIH0sICRpbmM6IHsgYXR0ZW1wdHM6IC0xIH0sICRzZXQ6IHsgYmdBdHRlbXB0czogZG9jLmJnQXR0ZW1wdHMgPz8gMCB9IH0gYXMgYW55XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gY2F0Y2ggKF8pIHt9XHJcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgZXJyb3I6ICdGYWlsZWQgdG8gZW5xdWV1ZSByZXRyeSBqb2InIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBVcGRhdGUgcmVkaXMgY291bnRlcnM6IGRlY3JlYXNlIGZhaWxlZCBieSAxIGlmIHBvc3NpYmxlICh3ZSBtb3ZlZCBpdCBmcm9tIGZhaWxlZCAtPiBwZW5kaW5nKVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRGYWlsZWQgPSBhd2FpdCBzYWZlR2V0TWV0YUludChyZWRpc0tleSwgJ2ZhaWxlZCcpO1xyXG4gICAgICAgIGlmIChjdXJyZW50RmFpbGVkID4gMCkge1xyXG4gICAgICAgICAgYXdhaXQgcmVkaXMuaGluY3JieShyZWRpc0tleSwgJ2ZhaWxlZCcsIC0xKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byB1cGRhdGUgcmVkaXMgY291bnRlcnMgZHVyaW5nIHJldHJ5Q29udGFjdCcsIGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBbHNvIGRlY3JlbWVudCBwcm9jZXNzZWQgc28gdG90YWxzIGFsaWduICh3ZSBhcmUgdW4tZmluYWxpemluZyBhIGNvbnRhY3QpXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFByb2Nlc3NlZCA9IGF3YWl0IHNhZmVHZXRNZXRhSW50KHJlZGlzS2V5LCAncHJvY2Vzc2VkJyk7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRQcm9jZXNzZWQgPiAwKSB7XHJcbiAgICAgICAgICBhd2FpdCByZWRpcy5oaW5jcmJ5KHJlZGlzS2V5LCAncHJvY2Vzc2VkJywgLTEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHVwZGF0ZSBwcm9jZXNzZWQgY291bnRlciBkdXJpbmcgcmV0cnlDb250YWN0JywgZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFB1Ymxpc2ggY29udGFjdCB1cGRhdGVcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBjaWRTdHIgPSBjb250YWN0T2JqSWQudG9TdHJpbmcgPyBjb250YWN0T2JqSWQudG9TdHJpbmcoKSA6IFN0cmluZyhjb250YWN0T2JqSWQpO1xyXG4gICAgICAgIGF3YWl0IHNhZmVQdWJsaXNoKGBjYW1wYWlnbjoke2lkfTpjb250YWN0X3VwZGF0ZWAsIHsgY29udGFjdElkOiBjaWRTdHIsIHN0YXR1czogJ3BlbmRpbmcnLCBhdHRlbXB0czogKGRvYy5hdHRlbXB0cyB8fCAwKSArIDEsIGJnQXR0ZW1wdHM6IDAgfSk7XHJcbiAgICAgIH0gY2F0Y2ggKF8pIHt9XHJcblxyXG4gICAgICBhd2FpdCBzYWZlUHVibGlzaCgnY2FtcGFpZ246bmV3JywgeyBpZCwgYWN0aW9uOiAncmV0cnlDb250YWN0JywgY29udGFjdElkIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHsgb2s6IHRydWUsIHJldHJpZWQ6IDEsIGNvbnRhY3RJZCB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTaG91bGQgbm90IHJlYWNoIGhlcmVcclxuICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IGVycm9yOiAnVW5zdXBwb3J0ZWQgYWN0aW9uJyB9KTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0NhbXBhaWduIGNvbnRyb2wgZXJyb3InLCBlcnIpO1xyXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgZXJyb3I6ICdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3InIH0pO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsiY2xpZW50UHJvbWlzZSIsInJlZGlzIiwiUXVldWUiLCJPYmplY3RJZCIsInF1ZXVlIiwiY29ubmVjdGlvbiIsIk1BWF9BVFRFTVBUUyIsIk51bWJlciIsInByb2Nlc3MiLCJlbnYiLCJCQVRDSF9SRVRSWV9MSU1JVCIsIlJFU1VNRV9FTlFVRVVFX0xJTUlUIiwiU1RBTEVfU0VORElOR19NUyIsInNhZmVIU2V0Iiwia2V5Iiwib2JqIiwiaHNldCIsImVyciIsImNvbnNvbGUiLCJ3YXJuIiwic2FmZVB1Ymxpc2giLCJjaGFubmVsIiwicGF5bG9hZCIsInB1Ymxpc2giLCJKU09OIiwic3RyaW5naWZ5IiwicmVtb3ZlUXVldWVkSm9ic0ZvckNhbXBhaWduIiwiY2FtcGFpZ25JZCIsImpvYnMiLCJnZXRKb2JzIiwibWF0Y2hlZCIsImZpbHRlciIsImoiLCJkYXRhIiwicmVtb3ZlIiwiZSIsImlkIiwibGVuZ3RoIiwicmVtb3ZlUXVldWVkSm9ic0ZvckNhbXBhaWduQ29udGFjdCIsImNvbnRhY3RJZCIsIlN0cmluZyIsInNhZmVHZXRNZXRhSW50IiwicmVkaXNLZXkiLCJmaWVsZCIsInYiLCJoZ2V0IiwiZW5zdXJlQ2FtcGFpZ25EZWZpbml0aW9uIiwiY2FtcGFpZ25Eb2MiLCJleGlzdGluZyIsImdldCIsImJ1aWx0IiwiZGVmaW5pdGlvbiIsImluaXRpYWwiLCJmb2xsb3dVcHMiLCJ0ZW1wbGF0ZSIsInN1YmplY3QiLCJuYW1lIiwiYm9keSIsImNvbnRlbnQiLCJ0aXRsZSIsImh0bWwiLCJzdGVwcyIsInNhbXBsZSIsIk9iamVjdCIsImtleXMiLCJzbGljZSIsInNldCIsImxvZyIsImdldFF1ZXVlZENvbnRhY3RJZHNGb3JDYW1wYWlnbiIsIlNldCIsImFkZCIsInRyeVBhcnNlT2JqZWN0SWQiLCJzIiwidGVzdCIsImhhbmRsZXIiLCJyZXEiLCJyZXMiLCJtZXRob2QiLCJzdGF0dXMiLCJqc29uIiwiZXJyb3IiLCJxdWVyeSIsImFjdGlvbiIsImNvbmZpcm0iLCJlbWFpbCIsInJlYXNvbiIsImJ5IiwiYWxsb3dlZEFjdGlvbnMiLCJpbmNsdWRlcyIsImNsaWVudCIsImRiIiwiY2FtcGFpZ25PYmplY3RJZCIsImNhbXBhaWduIiwiY29sbGVjdGlvbiIsImZpbmRPbmUiLCJfaWQiLCJub3ciLCJEYXRlIiwidG9JU09TdHJpbmciLCJjYW1wYWlnbklkU3RvcmUiLCJpbnNlcnREb2MiLCJhdCIsImluc2VydFJlcyIsImluc2VydE9uZSIsImNvbnRhY3RGaWx0ZXJzIiwibWF5YmVPYmoiLCJwdXNoIiwidXBkYXRlRmlsdGVyIiwiJGFuZCIsIiRvciIsInVwZGF0ZU1hbnkiLCIkc2V0IiwibWFudWFsbHlPdmVycmlkZGVuIiwib3ZlcnJpZGVBdCIsIm92ZXJyaWRlUmVhc29uIiwib3ZlcnJpZGVCeSIsInJlbW92ZWRKb2JzIiwiXyIsIm92ZXJyaWRlSWQiLCJpbnNlcnRlZElkIiwidG9TdHJpbmciLCJvayIsIm92ZXJyaWRlIiwiZGVsUmVzIiwiZGVsZXRlTWFueSIsIiR1bnNldCIsImxhc3RFcnJvciIsImJnQXR0ZW1wdHMiLCJyZW1vdmVkIiwiZGVsZXRlZENvdW50IiwiaXRlbXMiLCJmaW5kIiwic29ydCIsInRvQXJyYXkiLCJtZXNzYWdlIiwidXBkYXRlT25lIiwicXVldWVkU2V0IiwicGVuZGluZ0N1cnNvciIsInByb2plY3Rpb24iLCJzdGVwIiwibGltaXQiLCJwZW5kaW5nIiwiZW5xdWV1ZVByb21pc2VzIiwiZCIsImNpZCIsImhhcyIsInJlbW92ZU9uQ29tcGxldGUiLCJyZW1vdmVPbkZhaWwiLCJhdHRlbXB0cyIsImJhY2tvZmYiLCJ0eXBlIiwiZGVsYXkiLCJQcm9taXNlIiwiYWxsU2V0dGxlZCIsInJlcXVldWVkIiwiY3V0b2ZmIiwic3RhbGVDdXJzb3IiLCJsYXN0QXR0ZW1wdEF0IiwiJGx0Iiwic3RhbGVEb2NzIiwiaWRzIiwibWFwIiwiJGluIiwicXVldWVkU2V0MiIsInJlcXVldWVQcm9taXNlcyIsInVuZGVmaW5lZCIsInJlY292ZXJlZCIsInN0YWxlU2VuZGluZyIsInByb2plY3QiLCJwZW5kaW5nUm93cyIsImFnZyIsImFnZ3JlZ2F0ZSIsIiRtYXRjaCIsIiRncm91cCIsImNvdW50IiwiJHN1bSIsInNlbnQiLCJmYWlsZWQiLCJyIiwicHJvY2Vzc2VkIiwiaW50ZW5kZWQiLCJ0b3RhbHMiLCJjb3VudERvY3VtZW50cyIsInRvdGFsIiwibmV3U3RhdHVzIiwiY29tcGxldGVkQXQiLCJzdGFydHNXaXRoIiwidXBkYXRlIiwiJGluYyIsInVwZGF0ZVJlc3VsdCIsImNhbmNlbGxlZENvdW50IiwibW9kaWZpZWRDb3VudCIsImhpbmNyYnkiLCJtZXRhIiwiaGdldGFsbCIsInByb2Nlc3NlZE5vdyIsInNlbnROb3ciLCJmYWlsZWROb3ciLCJkZWwiLCJzcmVtIiwiY2FtcGFpZ25EZWwiLCJsZWRnZXJEZWwiLCJhbGwiLCJkZWxldGVPbmUiLCJjYW1wYWlnbkRlbGV0ZWQiLCJsZWRnZXJEZWxldGVkIiwiaGFzRGVmIiwiJGV4aXN0cyIsIiRndGUiLCJmYWlsZWREb2NzIiwidG9SZXRyeUNvdW50IiwicmV0cmllZCIsInVwZGF0ZWQiLCJDSFVOSyIsImkiLCJjaHVuayIsImRvYyIsImNvbnRhY3RPYmpJZCIsImN1cnJlbnRGYWlsZWQiLCJkZWMiLCJNYXRoIiwibWluIiwiY3VycmVudFByb2Nlc3NlZCIsImRlY1Byb2MiLCJhdHRlbXB0ZWRFbnF1ZXVlIiwiYmdEb25lIiwiY2lkU3RyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./pages/api/campaign/[id]/control.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fcampaign%2F%5Bid%5D%2Fcontrol&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Ccampaign%5C%5Bid%5D%5Ccontrol.ts&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();